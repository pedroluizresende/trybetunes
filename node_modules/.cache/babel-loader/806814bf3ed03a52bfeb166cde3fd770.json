{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rewriteLiveReferences;\n\nvar _assert = require(\"assert\");\n\nvar _t = require(\"@babel/types\");\n\nvar _template = require(\"@babel/template\");\n\nvar _helperSimpleAccess = require(\"@babel/helper-simple-access\");\n\nconst {\n  assignmentExpression,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  getOuterBindingIdentifiers,\n  identifier,\n  isMemberExpression,\n  isVariableDeclaration,\n  jsxIdentifier,\n  jsxMemberExpression,\n  memberExpression,\n  numericLiteral,\n  sequenceExpression,\n  stringLiteral,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction isInType(path) {\n  do {\n    switch (path.parent.type) {\n      case \"TSTypeAnnotation\":\n      case \"TSTypeAliasDeclaration\":\n      case \"TSTypeReference\":\n      case \"TypeAnnotation\":\n      case \"TypeAlias\":\n        return true;\n\n      case \"ExportSpecifier\":\n        return path.parentPath.parent.exportKind === \"type\";\n\n      default:\n        if (path.parentPath.isStatement() || path.parentPath.isExpression()) {\n          return false;\n        }\n\n    }\n  } while (path = path.parentPath);\n}\n\nfunction rewriteLiveReferences(programPath, metadata) {\n  const imported = new Map();\n  const exported = new Map();\n\n  const requeueInParent = path => {\n    programPath.requeue(path);\n  };\n\n  for (const [source, data] of metadata.source) {\n    for (const [localName, importName] of data.imports) {\n      imported.set(localName, [source, importName, null]);\n    }\n\n    for (const localName of data.importsNamespace) {\n      imported.set(localName, [source, null, localName]);\n    }\n  }\n\n  for (const [local, data] of metadata.local) {\n    let exportMeta = exported.get(local);\n\n    if (!exportMeta) {\n      exportMeta = [];\n      exported.set(local, exportMeta);\n    }\n\n    exportMeta.push(...data.names);\n  }\n\n  const rewriteBindingInitVisitorState = {\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    exported\n  };\n  programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);\n  (0, _helperSimpleAccess.default)(programPath, new Set([...Array.from(imported.keys()), ...Array.from(exported.keys())]), false);\n  const rewriteReferencesVisitorState = {\n    seen: new WeakSet(),\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    imported,\n    exported,\n    buildImportReference: (_ref, identNode) => {\n      let [source, importName, localName] = _ref;\n      const meta = metadata.source.get(source);\n\n      if (localName) {\n        if (meta.lazy) {\n          identNode = callExpression(identNode, []);\n        }\n\n        return identNode;\n      }\n\n      let namespace = identifier(meta.name);\n      if (meta.lazy) namespace = callExpression(namespace, []);\n\n      if (importName === \"default\" && meta.interop === \"node-default\") {\n        return namespace;\n      }\n\n      const computed = metadata.stringSpecifiers.has(importName);\n      return memberExpression(namespace, computed ? stringLiteral(importName) : identifier(importName), computed);\n    }\n  };\n  programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);\n}\n\nconst rewriteBindingInitVisitor = {\n  Scope(path) {\n    path.skip();\n  },\n\n  ClassDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    const {\n      id\n    } = path.node;\n    if (!id) throw new Error(\"Expected class to have a name\");\n    const localName = id.name;\n    const exportNames = exported.get(localName) || [];\n\n    if (exportNames.length > 0) {\n      const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName), path.scope));\n      statement._blockHoist = path.node._blockHoist;\n      requeueInParent(path.insertAfter(statement)[0]);\n    }\n  },\n\n  VariableDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    Object.keys(path.getOuterBindingIdentifiers()).forEach(localName => {\n      const exportNames = exported.get(localName) || [];\n\n      if (exportNames.length > 0) {\n        const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName), path.scope));\n        statement._blockHoist = path.node._blockHoist;\n        requeueInParent(path.insertAfter(statement)[0]);\n      }\n    });\n  }\n\n};\n\nconst buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr, scope) => {\n  const exportsObjectName = metadata.exportName;\n\n  for (let currentScope = scope; currentScope != null; currentScope = currentScope.parent) {\n    if (currentScope.hasOwnBinding(exportsObjectName)) {\n      currentScope.rename(exportsObjectName);\n    }\n  }\n\n  return (exportNames || []).reduce((expr, exportName) => {\n    const {\n      stringSpecifiers\n    } = metadata;\n    const computed = stringSpecifiers.has(exportName);\n    return assignmentExpression(\"=\", memberExpression(identifier(exportsObjectName), computed ? stringLiteral(exportName) : identifier(exportName), computed), expr);\n  }, localExpr);\n};\n\nconst buildImportThrow = localName => {\n  return _template.default.expression.ast`\n    (function() {\n      throw new Error('\"' + '${localName}' + '\" is read-only.');\n    })()\n  `;\n};\n\nconst rewriteReferencesVisitor = {\n  ReferencedIdentifier(path) {\n    const {\n      seen,\n      buildImportReference,\n      scope,\n      imported,\n      requeueInParent\n    } = this;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n    const localName = path.node.name;\n    const importData = imported.get(localName);\n\n    if (importData) {\n      if (isInType(path)) {\n        throw path.buildCodeFrameError(`Cannot transform the imported binding \"${localName}\" since it's also used in a type annotation. ` + `Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);\n      }\n\n      const localBinding = path.scope.getBinding(localName);\n      const rootBinding = scope.getBinding(localName);\n      if (rootBinding !== localBinding) return;\n      const ref = buildImportReference(importData, path.node);\n      ref.loc = path.node.loc;\n\n      if ((path.parentPath.isCallExpression({\n        callee: path.node\n      }) || path.parentPath.isOptionalCallExpression({\n        callee: path.node\n      }) || path.parentPath.isTaggedTemplateExpression({\n        tag: path.node\n      })) && isMemberExpression(ref)) {\n        path.replaceWith(sequenceExpression([numericLiteral(0), ref]));\n      } else if (path.isJSXIdentifier() && isMemberExpression(ref)) {\n        const {\n          object,\n          property\n        } = ref;\n        path.replaceWith(jsxMemberExpression(jsxIdentifier(object.name), jsxIdentifier(property.name)));\n      } else {\n        path.replaceWith(ref);\n      }\n\n      requeueInParent(path);\n      path.skip();\n    }\n  },\n\n  UpdateExpression(path) {\n    const {\n      scope,\n      seen,\n      imported,\n      exported,\n      requeueInParent,\n      buildImportReference\n    } = this;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n    const arg = path.get(\"argument\");\n    if (arg.isMemberExpression()) return;\n    const update = path.node;\n\n    if (arg.isIdentifier()) {\n      const localName = arg.node.name;\n\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n\n      const exportedNames = exported.get(localName);\n      const importData = imported.get(localName);\n\n      if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {\n        if (importData) {\n          path.replaceWith(assignmentExpression(update.operator[0] + \"=\", buildImportReference(importData, arg.node), buildImportThrow(localName)));\n        } else if (update.prefix) {\n          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, cloneNode(update), path.scope));\n        } else {\n          const ref = scope.generateDeclaredUidIdentifier(localName);\n          path.replaceWith(sequenceExpression([assignmentExpression(\"=\", cloneNode(ref), cloneNode(update)), buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier(localName), path.scope), cloneNode(ref)]));\n        }\n      }\n    }\n\n    requeueInParent(path);\n    path.skip();\n  },\n\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        imported,\n        exported,\n        requeueInParent,\n        buildImportReference\n      } = this;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      const left = path.get(\"left\");\n      if (left.isMemberExpression()) return;\n\n      if (left.isIdentifier()) {\n        const localName = left.node.name;\n\n        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n          return;\n        }\n\n        const exportedNames = exported.get(localName);\n        const importData = imported.get(localName);\n\n        if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {\n          _assert(path.node.operator === \"=\", \"Path was not simplified\");\n\n          const assignment = path.node;\n\n          if (importData) {\n            assignment.left = buildImportReference(importData, left.node);\n            assignment.right = sequenceExpression([assignment.right, buildImportThrow(localName)]);\n          }\n\n          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment, path.scope));\n          requeueInParent(path);\n        }\n      } else {\n        const ids = left.getOuterBindingIdentifiers();\n        const programScopeIds = Object.keys(ids).filter(localName => scope.getBinding(localName) === path.scope.getBinding(localName));\n        const id = programScopeIds.find(localName => imported.has(localName));\n\n        if (id) {\n          path.node.right = sequenceExpression([path.node.right, buildImportThrow(id)]);\n        }\n\n        const items = [];\n        programScopeIds.forEach(localName => {\n          const exportedNames = exported.get(localName) || [];\n\n          if (exportedNames.length > 0) {\n            items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier(localName), path.scope));\n          }\n        });\n\n        if (items.length > 0) {\n          let node = sequenceExpression(items);\n\n          if (path.parentPath.isExpressionStatement()) {\n            node = expressionStatement(node);\n            node._blockHoist = path.parentPath.node._blockHoist;\n          }\n\n          const statement = path.insertAfter(node)[0];\n          requeueInParent(statement);\n        }\n      }\n    }\n\n  },\n\n  \"ForOfStatement|ForInStatement\"(path) {\n    const {\n      scope,\n      node\n    } = path;\n    const {\n      left\n    } = node;\n    const {\n      exported,\n      imported,\n      scope: programScope\n    } = this;\n\n    if (!isVariableDeclaration(left)) {\n      let didTransformExport = false,\n          importConstViolationName;\n      const loopBodyScope = path.get(\"body\").scope;\n\n      for (const name of Object.keys(getOuterBindingIdentifiers(left))) {\n        if (programScope.getBinding(name) === scope.getBinding(name)) {\n          if (exported.has(name)) {\n            didTransformExport = true;\n\n            if (loopBodyScope.hasOwnBinding(name)) {\n              loopBodyScope.rename(name);\n            }\n          }\n\n          if (imported.has(name) && !importConstViolationName) {\n            importConstViolationName = name;\n          }\n        }\n      }\n\n      if (!didTransformExport && !importConstViolationName) {\n        return;\n      }\n\n      path.ensureBlock();\n      const bodyPath = path.get(\"body\");\n      const newLoopId = scope.generateUidIdentifierBasedOnNode(left);\n      path.get(\"left\").replaceWith(variableDeclaration(\"let\", [variableDeclarator(cloneNode(newLoopId))]));\n      scope.registerDeclaration(path.get(\"left\"));\n\n      if (didTransformExport) {\n        bodyPath.unshiftContainer(\"body\", expressionStatement(assignmentExpression(\"=\", left, newLoopId)));\n      }\n\n      if (importConstViolationName) {\n        bodyPath.unshiftContainer(\"body\", expressionStatement(buildImportThrow(importConstViolationName)));\n      }\n    }\n  }\n\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","default","rewriteLiveReferences","_assert","require","_t","_template","_helperSimpleAccess","assignmentExpression","callExpression","cloneNode","expressionStatement","getOuterBindingIdentifiers","identifier","isMemberExpression","isVariableDeclaration","jsxIdentifier","jsxMemberExpression","memberExpression","numericLiteral","sequenceExpression","stringLiteral","variableDeclaration","variableDeclarator","isInType","path","parent","type","parentPath","exportKind","isStatement","isExpression","programPath","metadata","imported","Map","exported","requeueInParent","requeue","source","data","localName","importName","imports","set","importsNamespace","local","exportMeta","get","push","names","rewriteBindingInitVisitorState","scope","traverse","rewriteBindingInitVisitor","Set","Array","from","keys","rewriteReferencesVisitorState","seen","WeakSet","buildImportReference","identNode","meta","lazy","namespace","name","interop","computed","stringSpecifiers","has","rewriteReferencesVisitor","Scope","skip","ClassDeclaration","id","node","Error","exportNames","length","statement","buildBindingExportAssignmentExpression","_blockHoist","insertAfter","VariableDeclaration","forEach","localExpr","exportsObjectName","exportName","currentScope","hasOwnBinding","rename","reduce","expr","buildImportThrow","expression","ast","ReferencedIdentifier","add","importData","buildCodeFrameError","localBinding","getBinding","rootBinding","ref","loc","isCallExpression","callee","isOptionalCallExpression","isTaggedTemplateExpression","tag","replaceWith","isJSXIdentifier","object","property","UpdateExpression","arg","update","isIdentifier","exportedNames","operator","prefix","generateDeclaredUidIdentifier","AssignmentExpression","exit","left","assignment","right","ids","programScopeIds","filter","find","items","isExpressionStatement","programScope","didTransformExport","importConstViolationName","loopBodyScope","ensureBlock","bodyPath","newLoopId","generateUidIdentifierBasedOnNode","registerDeclaration","unshiftContainer"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rewriteLiveReferences;\n\nvar _assert = require(\"assert\");\n\nvar _t = require(\"@babel/types\");\n\nvar _template = require(\"@babel/template\");\n\nvar _helperSimpleAccess = require(\"@babel/helper-simple-access\");\n\nconst {\n  assignmentExpression,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  getOuterBindingIdentifiers,\n  identifier,\n  isMemberExpression,\n  isVariableDeclaration,\n  jsxIdentifier,\n  jsxMemberExpression,\n  memberExpression,\n  numericLiteral,\n  sequenceExpression,\n  stringLiteral,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction isInType(path) {\n  do {\n    switch (path.parent.type) {\n      case \"TSTypeAnnotation\":\n      case \"TSTypeAliasDeclaration\":\n      case \"TSTypeReference\":\n      case \"TypeAnnotation\":\n      case \"TypeAlias\":\n        return true;\n\n      case \"ExportSpecifier\":\n        return path.parentPath.parent.exportKind === \"type\";\n\n      default:\n        if (path.parentPath.isStatement() || path.parentPath.isExpression()) {\n          return false;\n        }\n\n    }\n  } while (path = path.parentPath);\n}\n\nfunction rewriteLiveReferences(programPath, metadata) {\n  const imported = new Map();\n  const exported = new Map();\n\n  const requeueInParent = path => {\n    programPath.requeue(path);\n  };\n\n  for (const [source, data] of metadata.source) {\n    for (const [localName, importName] of data.imports) {\n      imported.set(localName, [source, importName, null]);\n    }\n\n    for (const localName of data.importsNamespace) {\n      imported.set(localName, [source, null, localName]);\n    }\n  }\n\n  for (const [local, data] of metadata.local) {\n    let exportMeta = exported.get(local);\n\n    if (!exportMeta) {\n      exportMeta = [];\n      exported.set(local, exportMeta);\n    }\n\n    exportMeta.push(...data.names);\n  }\n\n  const rewriteBindingInitVisitorState = {\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    exported\n  };\n  programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);\n  (0, _helperSimpleAccess.default)(programPath, new Set([...Array.from(imported.keys()), ...Array.from(exported.keys())]), false);\n  const rewriteReferencesVisitorState = {\n    seen: new WeakSet(),\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    imported,\n    exported,\n    buildImportReference: ([source, importName, localName], identNode) => {\n      const meta = metadata.source.get(source);\n\n      if (localName) {\n        if (meta.lazy) {\n          identNode = callExpression(identNode, []);\n        }\n\n        return identNode;\n      }\n\n      let namespace = identifier(meta.name);\n      if (meta.lazy) namespace = callExpression(namespace, []);\n\n      if (importName === \"default\" && meta.interop === \"node-default\") {\n        return namespace;\n      }\n\n      const computed = metadata.stringSpecifiers.has(importName);\n      return memberExpression(namespace, computed ? stringLiteral(importName) : identifier(importName), computed);\n    }\n  };\n  programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);\n}\n\nconst rewriteBindingInitVisitor = {\n  Scope(path) {\n    path.skip();\n  },\n\n  ClassDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    const {\n      id\n    } = path.node;\n    if (!id) throw new Error(\"Expected class to have a name\");\n    const localName = id.name;\n    const exportNames = exported.get(localName) || [];\n\n    if (exportNames.length > 0) {\n      const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName), path.scope));\n      statement._blockHoist = path.node._blockHoist;\n      requeueInParent(path.insertAfter(statement)[0]);\n    }\n  },\n\n  VariableDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    Object.keys(path.getOuterBindingIdentifiers()).forEach(localName => {\n      const exportNames = exported.get(localName) || [];\n\n      if (exportNames.length > 0) {\n        const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName), path.scope));\n        statement._blockHoist = path.node._blockHoist;\n        requeueInParent(path.insertAfter(statement)[0]);\n      }\n    });\n  }\n\n};\n\nconst buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr, scope) => {\n  const exportsObjectName = metadata.exportName;\n\n  for (let currentScope = scope; currentScope != null; currentScope = currentScope.parent) {\n    if (currentScope.hasOwnBinding(exportsObjectName)) {\n      currentScope.rename(exportsObjectName);\n    }\n  }\n\n  return (exportNames || []).reduce((expr, exportName) => {\n    const {\n      stringSpecifiers\n    } = metadata;\n    const computed = stringSpecifiers.has(exportName);\n    return assignmentExpression(\"=\", memberExpression(identifier(exportsObjectName), computed ? stringLiteral(exportName) : identifier(exportName), computed), expr);\n  }, localExpr);\n};\n\nconst buildImportThrow = localName => {\n  return _template.default.expression.ast`\n    (function() {\n      throw new Error('\"' + '${localName}' + '\" is read-only.');\n    })()\n  `;\n};\n\nconst rewriteReferencesVisitor = {\n  ReferencedIdentifier(path) {\n    const {\n      seen,\n      buildImportReference,\n      scope,\n      imported,\n      requeueInParent\n    } = this;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n    const localName = path.node.name;\n    const importData = imported.get(localName);\n\n    if (importData) {\n      if (isInType(path)) {\n        throw path.buildCodeFrameError(`Cannot transform the imported binding \"${localName}\" since it's also used in a type annotation. ` + `Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);\n      }\n\n      const localBinding = path.scope.getBinding(localName);\n      const rootBinding = scope.getBinding(localName);\n      if (rootBinding !== localBinding) return;\n      const ref = buildImportReference(importData, path.node);\n      ref.loc = path.node.loc;\n\n      if ((path.parentPath.isCallExpression({\n        callee: path.node\n      }) || path.parentPath.isOptionalCallExpression({\n        callee: path.node\n      }) || path.parentPath.isTaggedTemplateExpression({\n        tag: path.node\n      })) && isMemberExpression(ref)) {\n        path.replaceWith(sequenceExpression([numericLiteral(0), ref]));\n      } else if (path.isJSXIdentifier() && isMemberExpression(ref)) {\n        const {\n          object,\n          property\n        } = ref;\n        path.replaceWith(jsxMemberExpression(jsxIdentifier(object.name), jsxIdentifier(property.name)));\n      } else {\n        path.replaceWith(ref);\n      }\n\n      requeueInParent(path);\n      path.skip();\n    }\n  },\n\n  UpdateExpression(path) {\n    const {\n      scope,\n      seen,\n      imported,\n      exported,\n      requeueInParent,\n      buildImportReference\n    } = this;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n    const arg = path.get(\"argument\");\n    if (arg.isMemberExpression()) return;\n    const update = path.node;\n\n    if (arg.isIdentifier()) {\n      const localName = arg.node.name;\n\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n\n      const exportedNames = exported.get(localName);\n      const importData = imported.get(localName);\n\n      if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {\n        if (importData) {\n          path.replaceWith(assignmentExpression(update.operator[0] + \"=\", buildImportReference(importData, arg.node), buildImportThrow(localName)));\n        } else if (update.prefix) {\n          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, cloneNode(update), path.scope));\n        } else {\n          const ref = scope.generateDeclaredUidIdentifier(localName);\n          path.replaceWith(sequenceExpression([assignmentExpression(\"=\", cloneNode(ref), cloneNode(update)), buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier(localName), path.scope), cloneNode(ref)]));\n        }\n      }\n    }\n\n    requeueInParent(path);\n    path.skip();\n  },\n\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        imported,\n        exported,\n        requeueInParent,\n        buildImportReference\n      } = this;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      const left = path.get(\"left\");\n      if (left.isMemberExpression()) return;\n\n      if (left.isIdentifier()) {\n        const localName = left.node.name;\n\n        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n          return;\n        }\n\n        const exportedNames = exported.get(localName);\n        const importData = imported.get(localName);\n\n        if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {\n          _assert(path.node.operator === \"=\", \"Path was not simplified\");\n\n          const assignment = path.node;\n\n          if (importData) {\n            assignment.left = buildImportReference(importData, left.node);\n            assignment.right = sequenceExpression([assignment.right, buildImportThrow(localName)]);\n          }\n\n          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment, path.scope));\n          requeueInParent(path);\n        }\n      } else {\n        const ids = left.getOuterBindingIdentifiers();\n        const programScopeIds = Object.keys(ids).filter(localName => scope.getBinding(localName) === path.scope.getBinding(localName));\n        const id = programScopeIds.find(localName => imported.has(localName));\n\n        if (id) {\n          path.node.right = sequenceExpression([path.node.right, buildImportThrow(id)]);\n        }\n\n        const items = [];\n        programScopeIds.forEach(localName => {\n          const exportedNames = exported.get(localName) || [];\n\n          if (exportedNames.length > 0) {\n            items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier(localName), path.scope));\n          }\n        });\n\n        if (items.length > 0) {\n          let node = sequenceExpression(items);\n\n          if (path.parentPath.isExpressionStatement()) {\n            node = expressionStatement(node);\n            node._blockHoist = path.parentPath.node._blockHoist;\n          }\n\n          const statement = path.insertAfter(node)[0];\n          requeueInParent(statement);\n        }\n      }\n    }\n\n  },\n\n  \"ForOfStatement|ForInStatement\"(path) {\n    const {\n      scope,\n      node\n    } = path;\n    const {\n      left\n    } = node;\n    const {\n      exported,\n      imported,\n      scope: programScope\n    } = this;\n\n    if (!isVariableDeclaration(left)) {\n      let didTransformExport = false,\n          importConstViolationName;\n      const loopBodyScope = path.get(\"body\").scope;\n\n      for (const name of Object.keys(getOuterBindingIdentifiers(left))) {\n        if (programScope.getBinding(name) === scope.getBinding(name)) {\n          if (exported.has(name)) {\n            didTransformExport = true;\n\n            if (loopBodyScope.hasOwnBinding(name)) {\n              loopBodyScope.rename(name);\n            }\n          }\n\n          if (imported.has(name) && !importConstViolationName) {\n            importConstViolationName = name;\n          }\n        }\n      }\n\n      if (!didTransformExport && !importConstViolationName) {\n        return;\n      }\n\n      path.ensureBlock();\n      const bodyPath = path.get(\"body\");\n      const newLoopId = scope.generateUidIdentifierBasedOnNode(left);\n      path.get(\"left\").replaceWith(variableDeclaration(\"let\", [variableDeclarator(cloneNode(newLoopId))]));\n      scope.registerDeclaration(path.get(\"left\"));\n\n      if (didTransformExport) {\n        bodyPath.unshiftContainer(\"body\", expressionStatement(assignmentExpression(\"=\", left, newLoopId)));\n      }\n\n      if (importConstViolationName) {\n        bodyPath.unshiftContainer(\"body\", expressionStatement(buildImportThrow(importConstViolationName)));\n      }\n    }\n  }\n\n};"],"mappings":"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"},"metadata":{},"sourceType":"script"}