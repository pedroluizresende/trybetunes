{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _template = require(\"@babel/template\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  NOT_LOCAL_BINDING,\n  cloneNode,\n  identifier,\n  isAssignmentExpression,\n  isAssignmentPattern,\n  isFunction,\n  isIdentifier,\n  isLiteral,\n  isNullLiteral,\n  isObjectMethod,\n  isObjectProperty,\n  isRegExpLiteral,\n  isRestElement,\n  isTemplateLiteral,\n  isVariableDeclarator,\n  toBindingIdentifierName\n} = _t;\n\nfunction getFunctionArity(node) {\n  const count = node.params.findIndex(param => isAssignmentPattern(param) || isRestElement(param));\n  return count === -1 ? node.params.length : count;\n}\n\nconst buildPropertyMethodAssignmentWrapper = _template.default.statement(`\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n`);\n\nconst buildGeneratorPropertyMethodAssignmentWrapper = _template.default.statement(`\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n`);\n\nconst visitor = {\n  \"ReferencedIdentifier|BindingIdentifier\"(path, state) {\n    if (path.node.name !== state.name) return;\n    const localDeclar = path.scope.getBindingIdentifier(state.name);\n    if (localDeclar !== state.outerDeclar) return;\n    state.selfReference = true;\n    path.stop();\n  }\n\n};\n\nfunction getNameFromLiteralId(id) {\n  if (isNullLiteral(id)) {\n    return \"null\";\n  }\n\n  if (isRegExpLiteral(id)) {\n    return `_${id.pattern}_${id.flags}`;\n  }\n\n  if (isTemplateLiteral(id)) {\n    return id.quasis.map(quasi => quasi.value.raw).join(\"\");\n  }\n\n  if (id.value !== undefined) {\n    return id.value + \"\";\n  }\n\n  return \"\";\n}\n\nfunction wrap(state, method, id, scope) {\n  if (state.selfReference) {\n    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {\n      scope.rename(id.name);\n    } else {\n      if (!isFunction(method)) return;\n      let build = buildPropertyMethodAssignmentWrapper;\n\n      if (method.generator) {\n        build = buildGeneratorPropertyMethodAssignmentWrapper;\n      }\n\n      const template = build({\n        FUNCTION: method,\n        FUNCTION_ID: id,\n        FUNCTION_KEY: scope.generateUidIdentifier(id.name)\n      }).expression;\n      const params = template.callee.body.body[0].params;\n\n      for (let i = 0, len = getFunctionArity(method); i < len; i++) {\n        params.push(scope.generateUidIdentifier(\"x\"));\n      }\n\n      return template;\n    }\n  }\n\n  method.id = id;\n  scope.getProgramParent().references[id.name] = true;\n}\n\nfunction visit(node, name, scope) {\n  const state = {\n    selfAssignment: false,\n    selfReference: false,\n    outerDeclar: scope.getBindingIdentifier(name),\n    name: name\n  };\n  const binding = scope.getOwnBinding(name);\n\n  if (binding) {\n    if (binding.kind === \"param\") {\n      state.selfReference = true;\n    } else {}\n  } else if (state.outerDeclar || scope.hasGlobal(name)) {\n    scope.traverse(node, visitor, state);\n  }\n\n  return state;\n}\n\nfunction _default(_ref) {\n  let {\n    node,\n    parent,\n    scope,\n    id\n  } = _ref;\n  let localBinding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let supportUnicodeId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (node.id) return;\n\n  if ((isObjectProperty(parent) || isObjectMethod(parent, {\n    kind: \"method\"\n  })) && (!parent.computed || isLiteral(parent.key))) {\n    id = parent.key;\n  } else if (isVariableDeclarator(parent)) {\n    id = parent.id;\n\n    if (isIdentifier(id) && !localBinding) {\n      const binding = scope.parent.getBinding(id.name);\n\n      if (binding && binding.constant && scope.getBinding(id.name) === binding) {\n        node.id = cloneNode(id);\n        node.id[NOT_LOCAL_BINDING] = true;\n        return;\n      }\n    }\n  } else if (isAssignmentExpression(parent, {\n    operator: \"=\"\n  })) {\n    id = parent.left;\n  } else if (!id) {\n    return;\n  }\n\n  let name;\n\n  if (id && isLiteral(id)) {\n    name = getNameFromLiteralId(id);\n  } else if (id && isIdentifier(id)) {\n    name = id.name;\n  }\n\n  if (name === undefined) {\n    return;\n  }\n\n  if (!supportUnicodeId && isFunction(node) && /[\\uD800-\\uDFFF]/.test(name)) {\n    return;\n  }\n\n  name = toBindingIdentifierName(name);\n  const newId = identifier(name);\n  newId[NOT_LOCAL_BINDING] = true;\n  const state = visit(node, name, scope);\n  return wrap(state, node, newId, scope) || node;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_default","_template","require","_t","NOT_LOCAL_BINDING","cloneNode","identifier","isAssignmentExpression","isAssignmentPattern","isFunction","isIdentifier","isLiteral","isNullLiteral","isObjectMethod","isObjectProperty","isRegExpLiteral","isRestElement","isTemplateLiteral","isVariableDeclarator","toBindingIdentifierName","getFunctionArity","node","count","params","findIndex","param","length","buildPropertyMethodAssignmentWrapper","statement","buildGeneratorPropertyMethodAssignmentWrapper","visitor","path","state","name","localDeclar","scope","getBindingIdentifier","outerDeclar","selfReference","stop","getNameFromLiteralId","id","pattern","flags","quasis","map","quasi","raw","join","undefined","wrap","method","hasBinding","hasGlobal","rename","build","generator","template","FUNCTION","FUNCTION_ID","FUNCTION_KEY","generateUidIdentifier","expression","callee","body","i","len","push","getProgramParent","references","visit","selfAssignment","binding","getOwnBinding","kind","traverse","parent","localBinding","supportUnicodeId","computed","key","getBinding","constant","operator","left","test","newId"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/@babel/helper-function-name/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _template = require(\"@babel/template\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  NOT_LOCAL_BINDING,\n  cloneNode,\n  identifier,\n  isAssignmentExpression,\n  isAssignmentPattern,\n  isFunction,\n  isIdentifier,\n  isLiteral,\n  isNullLiteral,\n  isObjectMethod,\n  isObjectProperty,\n  isRegExpLiteral,\n  isRestElement,\n  isTemplateLiteral,\n  isVariableDeclarator,\n  toBindingIdentifierName\n} = _t;\n\nfunction getFunctionArity(node) {\n  const count = node.params.findIndex(param => isAssignmentPattern(param) || isRestElement(param));\n  return count === -1 ? node.params.length : count;\n}\n\nconst buildPropertyMethodAssignmentWrapper = _template.default.statement(`\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n`);\n\nconst buildGeneratorPropertyMethodAssignmentWrapper = _template.default.statement(`\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n`);\n\nconst visitor = {\n  \"ReferencedIdentifier|BindingIdentifier\"(path, state) {\n    if (path.node.name !== state.name) return;\n    const localDeclar = path.scope.getBindingIdentifier(state.name);\n    if (localDeclar !== state.outerDeclar) return;\n    state.selfReference = true;\n    path.stop();\n  }\n\n};\n\nfunction getNameFromLiteralId(id) {\n  if (isNullLiteral(id)) {\n    return \"null\";\n  }\n\n  if (isRegExpLiteral(id)) {\n    return `_${id.pattern}_${id.flags}`;\n  }\n\n  if (isTemplateLiteral(id)) {\n    return id.quasis.map(quasi => quasi.value.raw).join(\"\");\n  }\n\n  if (id.value !== undefined) {\n    return id.value + \"\";\n  }\n\n  return \"\";\n}\n\nfunction wrap(state, method, id, scope) {\n  if (state.selfReference) {\n    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {\n      scope.rename(id.name);\n    } else {\n      if (!isFunction(method)) return;\n      let build = buildPropertyMethodAssignmentWrapper;\n\n      if (method.generator) {\n        build = buildGeneratorPropertyMethodAssignmentWrapper;\n      }\n\n      const template = build({\n        FUNCTION: method,\n        FUNCTION_ID: id,\n        FUNCTION_KEY: scope.generateUidIdentifier(id.name)\n      }).expression;\n      const params = template.callee.body.body[0].params;\n\n      for (let i = 0, len = getFunctionArity(method); i < len; i++) {\n        params.push(scope.generateUidIdentifier(\"x\"));\n      }\n\n      return template;\n    }\n  }\n\n  method.id = id;\n  scope.getProgramParent().references[id.name] = true;\n}\n\nfunction visit(node, name, scope) {\n  const state = {\n    selfAssignment: false,\n    selfReference: false,\n    outerDeclar: scope.getBindingIdentifier(name),\n    name: name\n  };\n  const binding = scope.getOwnBinding(name);\n\n  if (binding) {\n    if (binding.kind === \"param\") {\n      state.selfReference = true;\n    } else {}\n  } else if (state.outerDeclar || scope.hasGlobal(name)) {\n    scope.traverse(node, visitor, state);\n  }\n\n  return state;\n}\n\nfunction _default({\n  node,\n  parent,\n  scope,\n  id\n}, localBinding = false, supportUnicodeId = false) {\n  if (node.id) return;\n\n  if ((isObjectProperty(parent) || isObjectMethod(parent, {\n    kind: \"method\"\n  })) && (!parent.computed || isLiteral(parent.key))) {\n    id = parent.key;\n  } else if (isVariableDeclarator(parent)) {\n    id = parent.id;\n\n    if (isIdentifier(id) && !localBinding) {\n      const binding = scope.parent.getBinding(id.name);\n\n      if (binding && binding.constant && scope.getBinding(id.name) === binding) {\n        node.id = cloneNode(id);\n        node.id[NOT_LOCAL_BINDING] = true;\n        return;\n      }\n    }\n  } else if (isAssignmentExpression(parent, {\n    operator: \"=\"\n  })) {\n    id = parent.left;\n  } else if (!id) {\n    return;\n  }\n\n  let name;\n\n  if (id && isLiteral(id)) {\n    name = getNameFromLiteralId(id);\n  } else if (id && isIdentifier(id)) {\n    name = id.name;\n  }\n\n  if (name === undefined) {\n    return;\n  }\n\n  if (!supportUnicodeId && isFunction(node) && /[\\uD800-\\uDFFF]/.test(name)) {\n    return;\n  }\n\n  name = toBindingIdentifierName(name);\n  const newId = identifier(name);\n  newId[NOT_LOCAL_BINDING] = true;\n  const state = visit(node, name, scope);\n  return wrap(state, node, newId, scope) || node;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}