{"ast":null,"code":"import { d as defaultTagPrefix, _ as _createForOfIteratorHelper, a as _typeof, b as _createClass, c as _classCallCheck, e as _defineProperty, Y as YAMLSyntaxError, T as Type, f as YAMLWarning, g as YAMLSemanticError, h as _slicedToArray, i as YAMLError, j as _inherits, k as _createSuper } from './PlainValue-b8036b75.js';\nimport { parse as parse$1 } from './parse-cst.js';\nimport { b as binaryOptions, a as boolOptions, i as intOptions, n as nullOptions, s as strOptions, N as Node, P as Pair, S as Scalar, c as stringifyString, A as Alias, Y as YAMLSeq, d as YAMLMap, M as Merge, C as Collection, r as resolveNode, e as isEmptyPath, t as toJSON, f as addComment } from './resolveSeq-492ab440.js';\nimport { S as Schema } from './Schema-e94716c8.js';\nimport { w as warn } from './warnings-df54cb69.js';\nvar defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nvar scalarOptions = {\n  get binary() {\n    return binaryOptions;\n  },\n\n  set binary(opt) {\n    Object.assign(binaryOptions, opt);\n  },\n\n  get bool() {\n    return boolOptions;\n  },\n\n  set bool(opt) {\n    Object.assign(boolOptions, opt);\n  },\n\n  get int() {\n    return intOptions;\n  },\n\n  set int(opt) {\n    Object.assign(intOptions, opt);\n  },\n\n  get null() {\n    return nullOptions;\n  },\n\n  set null(opt) {\n    Object.assign(nullOptions, opt);\n  },\n\n  get str() {\n    return strOptions;\n  },\n\n  set str(opt) {\n    Object.assign(strOptions, opt);\n  }\n\n};\nvar documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: defaultTagPrefix\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  1.1: {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: defaultTagPrefix\n    }]\n  },\n  1.2: {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: defaultTagPrefix\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    var priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    var vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? \"!\".concat(vocab[1], \"/\").concat(vocab[2]) : \"!\".concat(tag.replace(/^tag:/, ''));\n  }\n\n  var p = doc.tagPrefixes.find(function (p) {\n    return tag.indexOf(p.prefix) === 0;\n  });\n\n  if (!p) {\n    var dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(function (p) {\n      return tag.indexOf(p.prefix) === 0;\n    });\n  }\n\n  if (!p) return tag[0] === '!' ? tag : \"!<\".concat(tag, \">\");\n  var suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, function (ch) {\n    return {\n      '!': '%21',\n      ',': '%2C',\n      '[': '%5B',\n      ']': '%5D',\n      '{': '%7B',\n      '}': '%7D'\n    }[ch];\n  });\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof Alias) return Alias;\n\n  if (item.tag) {\n    var match = tags.filter(function (t) {\n      return t.tag === item.tag;\n    });\n    if (match.length > 0) return match.find(function (t) {\n      return t.format === item.format;\n    }) || match[0];\n  }\n\n  var tagObj, obj;\n\n  if (item instanceof Scalar) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    var _match = tags.filter(function (t) {\n      return t.identify && t.identify(obj) || t.class && obj instanceof t.class;\n    });\n\n    tagObj = _match.find(function (t) {\n      return t.format === item.format;\n    }) || _match.find(function (t) {\n      return !t.format;\n    });\n  } else {\n    obj = item;\n    tagObj = tags.find(function (t) {\n      return t.nodeClass && obj instanceof t.nodeClass;\n    });\n  }\n\n  if (!tagObj) {\n    var name = obj && obj.constructor ? obj.constructor.name : _typeof(obj);\n    throw new Error(\"Tag not resolved for \".concat(name, \" value\"));\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, _ref) {\n  var anchors = _ref.anchors,\n      doc = _ref.doc;\n  var props = [];\n  var anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(\"&\".concat(anchor));\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj.default) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify$1(item, ctx, onComment, onChompKeep) {\n  var _ctx$doc = ctx.doc,\n      anchors = _ctx$doc.anchors,\n      schema = _ctx$doc.schema;\n  var tagObj;\n\n  if (!(item instanceof Node)) {\n    var createCtx = {\n      aliasNodes: [],\n      onTagObj: function onTagObj(o) {\n        return tagObj = o;\n      },\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    var _iterator = _createForOfIteratorHelper(createCtx.aliasNodes),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var alias = _step.value;\n        alias.source = alias.source.node;\n        var name = anchors.getName(alias.source);\n\n        if (!name) {\n          name = anchors.newName();\n          anchors.map[name] = alias.source;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  if (item instanceof Pair) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  var props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  var str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof Scalar ? stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof Scalar || str[0] === '{' || str[0] === '[' ? \"\".concat(props, \" \").concat(str) : \"\".concat(props, \"\\n\").concat(ctx.indent).concat(str);\n}\n\nvar Anchors = /*#__PURE__*/function () {\n  function Anchors(prefix) {\n    _classCallCheck(this, Anchors);\n\n    _defineProperty(this, \"map\", Object.create(null));\n\n    this.prefix = prefix;\n  }\n\n  _createClass(Anchors, [{\n    key: \"createAlias\",\n    value: function createAlias(node, name) {\n      this.setAnchor(node, name);\n      return new Alias(node);\n    }\n  }, {\n    key: \"createMergePair\",\n    value: function createMergePair() {\n      var _this = this;\n\n      var merge = new Merge();\n\n      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      merge.value.items = sources.map(function (s) {\n        if (s instanceof Alias) {\n          if (s.source instanceof YAMLMap) return s;\n        } else if (s instanceof YAMLMap) {\n          return _this.createAlias(s);\n        }\n\n        throw new Error('Merge sources must be Map nodes or their Aliases');\n      });\n      return merge;\n    }\n  }, {\n    key: \"getName\",\n    value: function getName(node) {\n      var map = this.map;\n      return Object.keys(map).find(function (a) {\n        return map[a] === node;\n      });\n    }\n  }, {\n    key: \"getNames\",\n    value: function getNames() {\n      return Object.keys(this.map);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(name) {\n      return this.map[name];\n    }\n  }, {\n    key: \"newName\",\n    value: function newName(prefix) {\n      if (!prefix) prefix = this.prefix;\n      var names = Object.keys(this.map);\n\n      for (var i = 1; true; ++i) {\n        var name = \"\".concat(prefix).concat(i);\n        if (!names.includes(name)) return name;\n      }\n    } // During parsing, map & aliases contain CST nodes\n\n  }, {\n    key: \"resolveNodes\",\n    value: function resolveNodes() {\n      var map = this.map,\n          _cstAliases = this._cstAliases;\n      Object.keys(map).forEach(function (a) {\n        map[a] = map[a].resolved;\n      });\n\n      _cstAliases.forEach(function (a) {\n        a.source = a.source.resolved;\n      });\n\n      delete this._cstAliases;\n    }\n  }, {\n    key: \"setAnchor\",\n    value: function setAnchor(node, name) {\n      if (node != null && !Anchors.validAnchorNode(node)) {\n        throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n      }\n\n      if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n        throw new Error('Anchor names must not contain whitespace or control characters');\n      }\n\n      var map = this.map;\n      var prev = node && Object.keys(map).find(function (a) {\n        return map[a] === node;\n      });\n\n      if (prev) {\n        if (!name) {\n          return prev;\n        } else if (prev !== name) {\n          delete map[prev];\n          map[name] = node;\n        }\n      } else {\n        if (!name) {\n          if (!node) return null;\n          name = this.newName();\n        }\n\n        map[name] = node;\n      }\n\n      return name;\n    }\n  }], [{\n    key: \"validAnchorNode\",\n    value: function validAnchorNode(node) {\n      return node instanceof Scalar || node instanceof YAMLSeq || node instanceof YAMLMap;\n    }\n  }]);\n\n  return Anchors;\n}();\n\nvar visit = function visit(node, tags) {\n  if (node && _typeof(node) === 'object') {\n    var tag = node.tag;\n\n    if (node instanceof Collection) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(function (n) {\n        return visit(n, tags);\n      });\n    } else if (node instanceof Pair) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof Scalar) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nvar listTagNames = function listTagNames(node) {\n  return Object.keys(visit(node, {}));\n};\n\nfunction parseContents(doc, contents) {\n  var comments = {\n    before: [],\n    after: []\n  };\n  var body = undefined;\n  var spaceBefore = false;\n\n  var _iterator = _createForOfIteratorHelper(contents),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var node = _step.value;\n\n      if (node.valueRange) {\n        if (body !== undefined) {\n          var msg = 'Document contains trailing content not separated by a ... or --- line';\n          doc.errors.push(new YAMLSyntaxError(node, msg));\n          break;\n        }\n\n        var res = resolveNode(doc, node);\n\n        if (spaceBefore) {\n          res.spaceBefore = true;\n          spaceBefore = false;\n        }\n\n        body = res;\n      } else if (node.comment !== null) {\n        var cc = body === undefined ? comments.before : comments.after;\n        cc.push(node.comment);\n      } else if (node.type === Type.BLANK_LINE) {\n        spaceBefore = true;\n\n        if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n          // space-separated comments at start are parsed as document comments\n          doc.commentBefore = comments.before.join('\\n');\n          comments.before = [];\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    var cb = comments.before.join('\\n');\n\n    if (cb) {\n      var cbNode = body instanceof Collection && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? \"\".concat(cb, \"\\n\").concat(cbNode.commentBefore) : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective(_ref, directive) {\n  var tagPrefixes = _ref.tagPrefixes;\n\n  var _directive$parameters = _slicedToArray(directive.parameters, 2),\n      handle = _directive$parameters[0],\n      prefix = _directive$parameters[1];\n\n  if (!handle || !prefix) {\n    var msg = 'Insufficient parameters given for %TAG directive';\n    throw new YAMLSemanticError(directive, msg);\n  }\n\n  if (tagPrefixes.some(function (p) {\n    return p.handle === handle;\n  })) {\n    var _msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new YAMLSemanticError(directive, _msg);\n  }\n\n  return {\n    handle: handle,\n    prefix: prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  var _directive$parameters2 = _slicedToArray(directive.parameters, 1),\n      version = _directive$parameters2[0];\n\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    var msg = 'Insufficient parameters given for %YAML directive';\n    throw new YAMLSemanticError(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    var v0 = doc.version || doc.options.version;\n\n    var _msg2 = \"Document will be parsed as YAML \".concat(v0, \" rather than YAML \").concat(version);\n\n    doc.warnings.push(new YAMLWarning(directive, _msg2));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  var directiveComments = [];\n  var hasDirectives = false;\n\n  var _iterator = _createForOfIteratorHelper(directives),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var directive = _step.value;\n      var comment = directive.comment,\n          name = directive.name;\n\n      switch (name) {\n        case 'TAG':\n          try {\n            doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n          } catch (error) {\n            doc.errors.push(error);\n          }\n\n          hasDirectives = true;\n          break;\n\n        case 'YAML':\n        case 'YAML:1.0':\n          if (doc.version) {\n            var msg = 'The %YAML directive must only be given at most once per document.';\n            doc.errors.push(new YAMLSemanticError(directive, msg));\n          }\n\n          try {\n            doc.version = resolveYamlDirective(doc, directive);\n          } catch (error) {\n            doc.errors.push(error);\n          }\n\n          hasDirectives = true;\n          break;\n\n        default:\n          if (name) {\n            var _msg3 = \"YAML only supports %TAG and %YAML directives, and not %\".concat(name);\n\n            doc.warnings.push(new YAMLWarning(directive, _msg3));\n          }\n\n      }\n\n      if (comment) directiveComments.push(comment);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    var copyTagPrefix = function copyTagPrefix(_ref2) {\n      var handle = _ref2.handle,\n          prefix = _ref2.prefix;\n      return {\n        handle: handle,\n        prefix: prefix\n      };\n    };\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof Collection) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nvar Document$1 = /*#__PURE__*/function () {\n  function Document(options) {\n    _classCallCheck(this, Document);\n\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  _createClass(Document, [{\n    key: \"add\",\n    value: function add(value) {\n      assertCollection(this.contents);\n      return this.contents.add(value);\n    }\n  }, {\n    key: \"addIn\",\n    value: function addIn(path, value) {\n      assertCollection(this.contents);\n      this.contents.addIn(path, value);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      assertCollection(this.contents);\n      return this.contents.delete(key);\n    }\n  }, {\n    key: \"deleteIn\",\n    value: function deleteIn(path) {\n      if (isEmptyPath(path)) {\n        if (this.contents == null) return false;\n        this.contents = null;\n        return true;\n      }\n\n      assertCollection(this.contents);\n      return this.contents.deleteIn(path);\n    }\n  }, {\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepScalar) {\n      return this.contents instanceof Collection ? this.contents.get(key, keepScalar) : undefined;\n    }\n  }, {\n    key: \"getIn\",\n    value: function getIn(path, keepScalar) {\n      if (isEmptyPath(path)) return !keepScalar && this.contents instanceof Scalar ? this.contents.value : this.contents;\n      return this.contents instanceof Collection ? this.contents.getIn(path, keepScalar) : undefined;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return this.contents instanceof Collection ? this.contents.has(key) : false;\n    }\n  }, {\n    key: \"hasIn\",\n    value: function hasIn(path) {\n      if (isEmptyPath(path)) return this.contents !== undefined;\n      return this.contents instanceof Collection ? this.contents.hasIn(path) : false;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      assertCollection(this.contents);\n      this.contents.set(key, value);\n    }\n  }, {\n    key: \"setIn\",\n    value: function setIn(path, value) {\n      if (isEmptyPath(path)) this.contents = value;else {\n        assertCollection(this.contents);\n        this.contents.setIn(path, value);\n      }\n    }\n  }, {\n    key: \"setSchema\",\n    value: function setSchema(id, customTags) {\n      if (!id && !customTags && this.schema) return;\n      if (typeof id === 'number') id = id.toFixed(1);\n\n      if (id === '1.0' || id === '1.1' || id === '1.2') {\n        if (this.version) this.version = id;else this.options.version = id;\n        delete this.options.schema;\n      } else if (id && typeof id === 'string') {\n        this.options.schema = id;\n      }\n\n      if (Array.isArray(customTags)) this.options.customTags = customTags;\n      var opt = Object.assign({}, this.getDefaults(), this.options);\n      this.schema = new Schema(opt);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(node, prevDoc) {\n      if (this.options.keepCstNodes) this.cstNode = node;\n      if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n      var _node$directives = node.directives,\n          directives = _node$directives === void 0 ? [] : _node$directives,\n          _node$contents = node.contents,\n          contents = _node$contents === void 0 ? [] : _node$contents,\n          directivesEndMarker = node.directivesEndMarker,\n          error = node.error,\n          valueRange = node.valueRange;\n\n      if (error) {\n        if (!error.source) error.source = this;\n        this.errors.push(error);\n      }\n\n      parseDirectives(this, directives, prevDoc);\n      if (directivesEndMarker) this.directivesEndMarker = true;\n      this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n      this.setSchema();\n      this.anchors._cstAliases = [];\n      parseContents(this, contents);\n      this.anchors.resolveNodes();\n\n      if (this.options.prettyErrors) {\n        var _iterator = _createForOfIteratorHelper(this.errors),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _error = _step.value;\n            if (_error instanceof YAMLError) _error.makePretty();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        var _iterator2 = _createForOfIteratorHelper(this.warnings),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var warn = _step2.value;\n            if (warn instanceof YAMLError) warn.makePretty();\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"listNonDefaultTags\",\n    value: function listNonDefaultTags() {\n      return listTagNames(this.contents).filter(function (t) {\n        return t.indexOf(Schema.defaultPrefix) !== 0;\n      });\n    }\n  }, {\n    key: \"setTagPrefix\",\n    value: function setTagPrefix(handle, prefix) {\n      if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n      if (prefix) {\n        var prev = this.tagPrefixes.find(function (p) {\n          return p.handle === handle;\n        });\n        if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n          handle: handle,\n          prefix: prefix\n        });\n      } else {\n        this.tagPrefixes = this.tagPrefixes.filter(function (p) {\n          return p.handle !== handle;\n        });\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON$1(arg, onAnchor) {\n      var _this = this;\n\n      var _this$options = this.options,\n          keepBlobsInJSON = _this$options.keepBlobsInJSON,\n          mapAsMap = _this$options.mapAsMap,\n          maxAliasCount = _this$options.maxAliasCount;\n      var keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof Scalar));\n      var ctx = {\n        doc: this,\n        indentStep: '  ',\n        keep: keep,\n        mapAsMap: keep && !!mapAsMap,\n        maxAliasCount: maxAliasCount,\n        stringify: stringify$1 // Requiring directly in Pair would create circular dependencies\n\n      };\n      var anchorNames = Object.keys(this.anchors.map);\n      if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(function (name) {\n        return [_this.anchors.map[name], {\n          alias: [],\n          aliasCount: 0,\n          count: 1\n        }];\n      }));\n      var res = toJSON(this.contents, arg, ctx);\n\n      if (typeof onAnchor === 'function' && ctx.anchors) {\n        var _iterator3 = _createForOfIteratorHelper(ctx.anchors.values()),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _step3$value = _step3.value,\n                count = _step3$value.count,\n                _res = _step3$value.res;\n            onAnchor(_res, count);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      return res;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n      var indentSize = this.options.indent;\n\n      if (!Number.isInteger(indentSize) || indentSize <= 0) {\n        var s = JSON.stringify(indentSize);\n        throw new Error(\"\\\"indent\\\" option must be a positive integer, not \".concat(s));\n      }\n\n      this.setSchema();\n      var lines = [];\n      var hasDirectives = false;\n\n      if (this.version) {\n        var vd = '%YAML 1.2';\n\n        if (this.schema.name === 'yaml-1.1') {\n          if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n        }\n\n        lines.push(vd);\n        hasDirectives = true;\n      }\n\n      var tagNames = this.listNonDefaultTags();\n      this.tagPrefixes.forEach(function (_ref) {\n        var handle = _ref.handle,\n            prefix = _ref.prefix;\n\n        if (tagNames.some(function (t) {\n          return t.indexOf(prefix) === 0;\n        })) {\n          lines.push(\"%TAG \".concat(handle, \" \").concat(prefix));\n          hasDirectives = true;\n        }\n      });\n      if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n      if (this.commentBefore) {\n        if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n        lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n      }\n\n      var ctx = {\n        anchors: Object.create(null),\n        doc: this,\n        indent: '',\n        indentStep: ' '.repeat(indentSize),\n        stringify: stringify$1 // Requiring directly in nodes would create circular dependencies\n\n      };\n      var chompKeep = false;\n      var contentComment = null;\n\n      if (this.contents) {\n        if (this.contents instanceof Node) {\n          if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n          if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n          ctx.forceBlockIndent = !!this.comment;\n          contentComment = this.contents.comment;\n        }\n\n        var onChompKeep = contentComment ? null : function () {\n          return chompKeep = true;\n        };\n        var body = stringify$1(this.contents, ctx, function () {\n          return contentComment = null;\n        }, onChompKeep);\n        lines.push(addComment(body, '', contentComment));\n      } else if (this.contents !== undefined) {\n        lines.push(stringify$1(this.contents, ctx));\n      }\n\n      if (this.comment) {\n        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n        lines.push(this.comment.replace(/^/gm, '#'));\n      }\n\n      return lines.join('\\n') + '\\n';\n    }\n  }]);\n\n  return Document;\n}();\n\n_defineProperty(Document$1, \"defaults\", documentOptions);\n\nfunction createNode(value) {\n  var wrapScalars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var tag = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (tag === undefined && typeof wrapScalars === 'string') {\n    tag = wrapScalars;\n    wrapScalars = true;\n  }\n\n  var options = Object.assign({}, Document$1.defaults[defaultOptions.version], defaultOptions);\n  var schema = new Schema(options);\n  return schema.createNode(value, wrapScalars, tag);\n}\n\nvar Document = /*#__PURE__*/function (_YAMLDocument) {\n  _inherits(Document, _YAMLDocument);\n\n  var _super = _createSuper(Document);\n\n  function Document(options) {\n    _classCallCheck(this, Document);\n\n    return _super.call(this, Object.assign({}, defaultOptions, options));\n  }\n\n  return Document;\n}(Document$1);\n\nfunction parseAllDocuments(src, options) {\n  var stream = [];\n  var prev;\n\n  var _iterator = _createForOfIteratorHelper(parse$1(src)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var cstDoc = _step.value;\n      var doc = new Document(options);\n      doc.parse(cstDoc, prev);\n      stream.push(doc);\n      prev = doc;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return stream;\n}\n\nfunction parseDocument(src, options) {\n  var cst = parse$1(src);\n  var doc = new Document(options).parse(cst[0]);\n\n  if (cst.length > 1) {\n    var errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';\n    doc.errors.unshift(new YAMLSemanticError(cst[1], errMsg));\n  }\n\n  return doc;\n}\n\nfunction parse(src, options) {\n  var doc = parseDocument(src, options);\n  doc.warnings.forEach(function (warning) {\n    return warn(warning);\n  });\n  if (doc.errors.length > 0) throw doc.errors[0];\n  return doc.toJSON();\n}\n\nfunction stringify(value, options) {\n  var doc = new Document(options);\n  doc.contents = value;\n  return String(doc);\n}\n\nvar YAML = {\n  createNode: createNode,\n  defaultOptions: defaultOptions,\n  Document: Document,\n  parse: parse,\n  parseAllDocuments: parseAllDocuments,\n  parseCST: parse$1,\n  parseDocument: parseDocument,\n  scalarOptions: scalarOptions,\n  stringify: stringify\n};\nexport { YAML };","map":{"version":3,"names":["d","defaultTagPrefix","_","_createForOfIteratorHelper","a","_typeof","b","_createClass","c","_classCallCheck","e","_defineProperty","Y","YAMLSyntaxError","T","Type","f","YAMLWarning","g","YAMLSemanticError","h","_slicedToArray","i","YAMLError","j","_inherits","k","_createSuper","parse","parse$1","binaryOptions","boolOptions","intOptions","n","nullOptions","s","strOptions","N","Node","P","Pair","S","Scalar","stringifyString","A","Alias","YAMLSeq","YAMLMap","M","Merge","C","Collection","r","resolveNode","isEmptyPath","t","toJSON","addComment","Schema","w","warn","defaultOptions","anchorPrefix","customTags","indent","indentSeq","keepCstNodes","keepNodeTypes","keepBlobsInJSON","mapAsMap","maxAliasCount","prettyErrors","simpleKeys","version","scalarOptions","binary","opt","Object","assign","bool","int","null","str","documentOptions","schema","merge","tagPrefixes","handle","prefix","stringifyTag","doc","tag","options","priv","match","vocab","concat","replace","p","find","indexOf","dtp","getDefaults","suffix","substr","length","ch","getTagObject","tags","item","filter","format","tagObj","obj","value","_match","identify","class","nodeClass","name","constructor","Error","stringifyProps","node","_ref","anchors","props","anchor","getName","push","default","join","stringify$1","ctx","onComment","onChompKeep","_ctx$doc","createCtx","aliasNodes","onTagObj","o","prevObjects","Map","createNode","_iterator","_step","done","alias","source","newName","map","err","toString","indentAtStart","stringify","Anchors","create","key","createAlias","setAnchor","createMergePair","_this","_len","arguments","sources","Array","_key","items","keys","getNames","getNode","names","includes","resolveNodes","_cstAliases","forEach","resolved","validAnchorNode","test","prev","visit","listTagNames","parseContents","contents","comments","before","after","body","undefined","spaceBefore","valueRange","msg","errors","res","comment","cc","type","BLANK_LINE","commentBefore","cb","cbNode","resolveTagDirective","directive","_directive$parameters","parameters","some","_msg","resolveYamlDirective","_directive$parameters2","v0","_msg2","warnings","parseDirectives","directives","prevDoc","directiveComments","hasDirectives","error","_msg3","copyTagPrefix","_ref2","assertCollection","Document$1","Document","directivesEndMarker","add","addIn","path","_delete","delete","deleteIn","defaults","get","keepScalar","getIn","has","hasIn","set","setIn","setSchema","id","toFixed","isArray","cstNode","_node$directives","_node$contents","range","start","end","_error","makePretty","_iterator2","_step2","listNonDefaultTags","defaultPrefix","setTagPrefix","toJSON$1","arg","onAnchor","_this$options","keep","indentStep","anchorNames","aliasCount","count","_iterator3","values","_step3","_step3$value","_res","indentSize","Number","isInteger","JSON","lines","vd","tagNames","unshift","repeat","chompKeep","contentComment","forceBlockIndent","wrapScalars","_YAMLDocument","_super","call","parseAllDocuments","src","stream","cstDoc","parseDocument","cst","errMsg","warning","String","YAML","parseCST"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/yaml/browser/dist/index.js"],"sourcesContent":["import { d as defaultTagPrefix, _ as _createForOfIteratorHelper, a as _typeof, b as _createClass, c as _classCallCheck, e as _defineProperty, Y as YAMLSyntaxError, T as Type, f as YAMLWarning, g as YAMLSemanticError, h as _slicedToArray, i as YAMLError, j as _inherits, k as _createSuper } from './PlainValue-b8036b75.js';\nimport { parse as parse$1 } from './parse-cst.js';\nimport { b as binaryOptions, a as boolOptions, i as intOptions, n as nullOptions, s as strOptions, N as Node, P as Pair, S as Scalar, c as stringifyString, A as Alias, Y as YAMLSeq, d as YAMLMap, M as Merge, C as Collection, r as resolveNode, e as isEmptyPath, t as toJSON, f as addComment } from './resolveSeq-492ab440.js';\nimport { S as Schema } from './Schema-e94716c8.js';\nimport { w as warn } from './warnings-df54cb69.js';\n\nvar defaultOptions = {\n  anchorPrefix: 'a',\n  customTags: null,\n  indent: 2,\n  indentSeq: true,\n  keepCstNodes: false,\n  keepNodeTypes: true,\n  keepBlobsInJSON: true,\n  mapAsMap: false,\n  maxAliasCount: 100,\n  prettyErrors: false,\n  // TODO Set true in v2\n  simpleKeys: false,\n  version: '1.2'\n};\nvar scalarOptions = {\n  get binary() {\n    return binaryOptions;\n  },\n\n  set binary(opt) {\n    Object.assign(binaryOptions, opt);\n  },\n\n  get bool() {\n    return boolOptions;\n  },\n\n  set bool(opt) {\n    Object.assign(boolOptions, opt);\n  },\n\n  get int() {\n    return intOptions;\n  },\n\n  set int(opt) {\n    Object.assign(intOptions, opt);\n  },\n\n  get null() {\n    return nullOptions;\n  },\n\n  set null(opt) {\n    Object.assign(nullOptions, opt);\n  },\n\n  get str() {\n    return strOptions;\n  },\n\n  set str(opt) {\n    Object.assign(strOptions, opt);\n  }\n\n};\nvar documentOptions = {\n  '1.0': {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: defaultTagPrefix\n    }, {\n      handle: '!!',\n      prefix: 'tag:private.yaml.org,2002:'\n    }]\n  },\n  1.1: {\n    schema: 'yaml-1.1',\n    merge: true,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: defaultTagPrefix\n    }]\n  },\n  1.2: {\n    schema: 'core',\n    merge: false,\n    tagPrefixes: [{\n      handle: '!',\n      prefix: '!'\n    }, {\n      handle: '!!',\n      prefix: defaultTagPrefix\n    }]\n  }\n};\n\nfunction stringifyTag(doc, tag) {\n  if ((doc.version || doc.options.version) === '1.0') {\n    var priv = tag.match(/^tag:private\\.yaml\\.org,2002:([^:/]+)$/);\n    if (priv) return '!' + priv[1];\n    var vocab = tag.match(/^tag:([a-zA-Z0-9-]+)\\.yaml\\.org,2002:(.*)/);\n    return vocab ? \"!\".concat(vocab[1], \"/\").concat(vocab[2]) : \"!\".concat(tag.replace(/^tag:/, ''));\n  }\n\n  var p = doc.tagPrefixes.find(function (p) {\n    return tag.indexOf(p.prefix) === 0;\n  });\n\n  if (!p) {\n    var dtp = doc.getDefaults().tagPrefixes;\n    p = dtp && dtp.find(function (p) {\n      return tag.indexOf(p.prefix) === 0;\n    });\n  }\n\n  if (!p) return tag[0] === '!' ? tag : \"!<\".concat(tag, \">\");\n  var suffix = tag.substr(p.prefix.length).replace(/[!,[\\]{}]/g, function (ch) {\n    return {\n      '!': '%21',\n      ',': '%2C',\n      '[': '%5B',\n      ']': '%5D',\n      '{': '%7B',\n      '}': '%7D'\n    }[ch];\n  });\n  return p.handle + suffix;\n}\n\nfunction getTagObject(tags, item) {\n  if (item instanceof Alias) return Alias;\n\n  if (item.tag) {\n    var match = tags.filter(function (t) {\n      return t.tag === item.tag;\n    });\n    if (match.length > 0) return match.find(function (t) {\n      return t.format === item.format;\n    }) || match[0];\n  }\n\n  var tagObj, obj;\n\n  if (item instanceof Scalar) {\n    obj = item.value; // TODO: deprecate/remove class check\n\n    var _match = tags.filter(function (t) {\n      return t.identify && t.identify(obj) || t.class && obj instanceof t.class;\n    });\n\n    tagObj = _match.find(function (t) {\n      return t.format === item.format;\n    }) || _match.find(function (t) {\n      return !t.format;\n    });\n  } else {\n    obj = item;\n    tagObj = tags.find(function (t) {\n      return t.nodeClass && obj instanceof t.nodeClass;\n    });\n  }\n\n  if (!tagObj) {\n    var name = obj && obj.constructor ? obj.constructor.name : _typeof(obj);\n    throw new Error(\"Tag not resolved for \".concat(name, \" value\"));\n  }\n\n  return tagObj;\n} // needs to be called before value stringifier to allow for circular anchor refs\n\n\nfunction stringifyProps(node, tagObj, _ref) {\n  var anchors = _ref.anchors,\n      doc = _ref.doc;\n  var props = [];\n  var anchor = doc.anchors.getName(node);\n\n  if (anchor) {\n    anchors[anchor] = node;\n    props.push(\"&\".concat(anchor));\n  }\n\n  if (node.tag) {\n    props.push(stringifyTag(doc, node.tag));\n  } else if (!tagObj.default) {\n    props.push(stringifyTag(doc, tagObj.tag));\n  }\n\n  return props.join(' ');\n}\n\nfunction stringify$1(item, ctx, onComment, onChompKeep) {\n  var _ctx$doc = ctx.doc,\n      anchors = _ctx$doc.anchors,\n      schema = _ctx$doc.schema;\n  var tagObj;\n\n  if (!(item instanceof Node)) {\n    var createCtx = {\n      aliasNodes: [],\n      onTagObj: function onTagObj(o) {\n        return tagObj = o;\n      },\n      prevObjects: new Map()\n    };\n    item = schema.createNode(item, true, null, createCtx);\n\n    var _iterator = _createForOfIteratorHelper(createCtx.aliasNodes),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var alias = _step.value;\n        alias.source = alias.source.node;\n        var name = anchors.getName(alias.source);\n\n        if (!name) {\n          name = anchors.newName();\n          anchors.map[name] = alias.source;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  if (item instanceof Pair) return item.toString(ctx, onComment, onChompKeep);\n  if (!tagObj) tagObj = getTagObject(schema.tags, item);\n  var props = stringifyProps(item, tagObj, ctx);\n  if (props.length > 0) ctx.indentAtStart = (ctx.indentAtStart || 0) + props.length + 1;\n  var str = typeof tagObj.stringify === 'function' ? tagObj.stringify(item, ctx, onComment, onChompKeep) : item instanceof Scalar ? stringifyString(item, ctx, onComment, onChompKeep) : item.toString(ctx, onComment, onChompKeep);\n  if (!props) return str;\n  return item instanceof Scalar || str[0] === '{' || str[0] === '[' ? \"\".concat(props, \" \").concat(str) : \"\".concat(props, \"\\n\").concat(ctx.indent).concat(str);\n}\n\nvar Anchors = /*#__PURE__*/function () {\n  function Anchors(prefix) {\n    _classCallCheck(this, Anchors);\n\n    _defineProperty(this, \"map\", Object.create(null));\n\n    this.prefix = prefix;\n  }\n\n  _createClass(Anchors, [{\n    key: \"createAlias\",\n    value: function createAlias(node, name) {\n      this.setAnchor(node, name);\n      return new Alias(node);\n    }\n  }, {\n    key: \"createMergePair\",\n    value: function createMergePair() {\n      var _this = this;\n\n      var merge = new Merge();\n\n      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {\n        sources[_key] = arguments[_key];\n      }\n\n      merge.value.items = sources.map(function (s) {\n        if (s instanceof Alias) {\n          if (s.source instanceof YAMLMap) return s;\n        } else if (s instanceof YAMLMap) {\n          return _this.createAlias(s);\n        }\n\n        throw new Error('Merge sources must be Map nodes or their Aliases');\n      });\n      return merge;\n    }\n  }, {\n    key: \"getName\",\n    value: function getName(node) {\n      var map = this.map;\n      return Object.keys(map).find(function (a) {\n        return map[a] === node;\n      });\n    }\n  }, {\n    key: \"getNames\",\n    value: function getNames() {\n      return Object.keys(this.map);\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(name) {\n      return this.map[name];\n    }\n  }, {\n    key: \"newName\",\n    value: function newName(prefix) {\n      if (!prefix) prefix = this.prefix;\n      var names = Object.keys(this.map);\n\n      for (var i = 1; true; ++i) {\n        var name = \"\".concat(prefix).concat(i);\n        if (!names.includes(name)) return name;\n      }\n    } // During parsing, map & aliases contain CST nodes\n\n  }, {\n    key: \"resolveNodes\",\n    value: function resolveNodes() {\n      var map = this.map,\n          _cstAliases = this._cstAliases;\n      Object.keys(map).forEach(function (a) {\n        map[a] = map[a].resolved;\n      });\n\n      _cstAliases.forEach(function (a) {\n        a.source = a.source.resolved;\n      });\n\n      delete this._cstAliases;\n    }\n  }, {\n    key: \"setAnchor\",\n    value: function setAnchor(node, name) {\n      if (node != null && !Anchors.validAnchorNode(node)) {\n        throw new Error('Anchors may only be set for Scalar, Seq and Map nodes');\n      }\n\n      if (name && /[\\x00-\\x19\\s,[\\]{}]/.test(name)) {\n        throw new Error('Anchor names must not contain whitespace or control characters');\n      }\n\n      var map = this.map;\n      var prev = node && Object.keys(map).find(function (a) {\n        return map[a] === node;\n      });\n\n      if (prev) {\n        if (!name) {\n          return prev;\n        } else if (prev !== name) {\n          delete map[prev];\n          map[name] = node;\n        }\n      } else {\n        if (!name) {\n          if (!node) return null;\n          name = this.newName();\n        }\n\n        map[name] = node;\n      }\n\n      return name;\n    }\n  }], [{\n    key: \"validAnchorNode\",\n    value: function validAnchorNode(node) {\n      return node instanceof Scalar || node instanceof YAMLSeq || node instanceof YAMLMap;\n    }\n  }]);\n\n  return Anchors;\n}();\n\nvar visit = function visit(node, tags) {\n  if (node && _typeof(node) === 'object') {\n    var tag = node.tag;\n\n    if (node instanceof Collection) {\n      if (tag) tags[tag] = true;\n      node.items.forEach(function (n) {\n        return visit(n, tags);\n      });\n    } else if (node instanceof Pair) {\n      visit(node.key, tags);\n      visit(node.value, tags);\n    } else if (node instanceof Scalar) {\n      if (tag) tags[tag] = true;\n    }\n  }\n\n  return tags;\n};\n\nvar listTagNames = function listTagNames(node) {\n  return Object.keys(visit(node, {}));\n};\n\nfunction parseContents(doc, contents) {\n  var comments = {\n    before: [],\n    after: []\n  };\n  var body = undefined;\n  var spaceBefore = false;\n\n  var _iterator = _createForOfIteratorHelper(contents),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var node = _step.value;\n\n      if (node.valueRange) {\n        if (body !== undefined) {\n          var msg = 'Document contains trailing content not separated by a ... or --- line';\n          doc.errors.push(new YAMLSyntaxError(node, msg));\n          break;\n        }\n\n        var res = resolveNode(doc, node);\n\n        if (spaceBefore) {\n          res.spaceBefore = true;\n          spaceBefore = false;\n        }\n\n        body = res;\n      } else if (node.comment !== null) {\n        var cc = body === undefined ? comments.before : comments.after;\n        cc.push(node.comment);\n      } else if (node.type === Type.BLANK_LINE) {\n        spaceBefore = true;\n\n        if (body === undefined && comments.before.length > 0 && !doc.commentBefore) {\n          // space-separated comments at start are parsed as document comments\n          doc.commentBefore = comments.before.join('\\n');\n          comments.before = [];\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  doc.contents = body || null;\n\n  if (!body) {\n    doc.comment = comments.before.concat(comments.after).join('\\n') || null;\n  } else {\n    var cb = comments.before.join('\\n');\n\n    if (cb) {\n      var cbNode = body instanceof Collection && body.items[0] ? body.items[0] : body;\n      cbNode.commentBefore = cbNode.commentBefore ? \"\".concat(cb, \"\\n\").concat(cbNode.commentBefore) : cb;\n    }\n\n    doc.comment = comments.after.join('\\n') || null;\n  }\n}\n\nfunction resolveTagDirective(_ref, directive) {\n  var tagPrefixes = _ref.tagPrefixes;\n\n  var _directive$parameters = _slicedToArray(directive.parameters, 2),\n      handle = _directive$parameters[0],\n      prefix = _directive$parameters[1];\n\n  if (!handle || !prefix) {\n    var msg = 'Insufficient parameters given for %TAG directive';\n    throw new YAMLSemanticError(directive, msg);\n  }\n\n  if (tagPrefixes.some(function (p) {\n    return p.handle === handle;\n  })) {\n    var _msg = 'The %TAG directive must only be given at most once per handle in the same document.';\n    throw new YAMLSemanticError(directive, _msg);\n  }\n\n  return {\n    handle: handle,\n    prefix: prefix\n  };\n}\n\nfunction resolveYamlDirective(doc, directive) {\n  var _directive$parameters2 = _slicedToArray(directive.parameters, 1),\n      version = _directive$parameters2[0];\n\n  if (directive.name === 'YAML:1.0') version = '1.0';\n\n  if (!version) {\n    var msg = 'Insufficient parameters given for %YAML directive';\n    throw new YAMLSemanticError(directive, msg);\n  }\n\n  if (!documentOptions[version]) {\n    var v0 = doc.version || doc.options.version;\n\n    var _msg2 = \"Document will be parsed as YAML \".concat(v0, \" rather than YAML \").concat(version);\n\n    doc.warnings.push(new YAMLWarning(directive, _msg2));\n  }\n\n  return version;\n}\n\nfunction parseDirectives(doc, directives, prevDoc) {\n  var directiveComments = [];\n  var hasDirectives = false;\n\n  var _iterator = _createForOfIteratorHelper(directives),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var directive = _step.value;\n      var comment = directive.comment,\n          name = directive.name;\n\n      switch (name) {\n        case 'TAG':\n          try {\n            doc.tagPrefixes.push(resolveTagDirective(doc, directive));\n          } catch (error) {\n            doc.errors.push(error);\n          }\n\n          hasDirectives = true;\n          break;\n\n        case 'YAML':\n        case 'YAML:1.0':\n          if (doc.version) {\n            var msg = 'The %YAML directive must only be given at most once per document.';\n            doc.errors.push(new YAMLSemanticError(directive, msg));\n          }\n\n          try {\n            doc.version = resolveYamlDirective(doc, directive);\n          } catch (error) {\n            doc.errors.push(error);\n          }\n\n          hasDirectives = true;\n          break;\n\n        default:\n          if (name) {\n            var _msg3 = \"YAML only supports %TAG and %YAML directives, and not %\".concat(name);\n\n            doc.warnings.push(new YAMLWarning(directive, _msg3));\n          }\n\n      }\n\n      if (comment) directiveComments.push(comment);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (prevDoc && !hasDirectives && '1.1' === (doc.version || prevDoc.version || doc.options.version)) {\n    var copyTagPrefix = function copyTagPrefix(_ref2) {\n      var handle = _ref2.handle,\n          prefix = _ref2.prefix;\n      return {\n        handle: handle,\n        prefix: prefix\n      };\n    };\n\n    doc.tagPrefixes = prevDoc.tagPrefixes.map(copyTagPrefix);\n    doc.version = prevDoc.version;\n  }\n\n  doc.commentBefore = directiveComments.join('\\n') || null;\n}\n\nfunction assertCollection(contents) {\n  if (contents instanceof Collection) return true;\n  throw new Error('Expected a YAML collection as document contents');\n}\n\nvar Document$1 = /*#__PURE__*/function () {\n  function Document(options) {\n    _classCallCheck(this, Document);\n\n    this.anchors = new Anchors(options.anchorPrefix);\n    this.commentBefore = null;\n    this.comment = null;\n    this.contents = null;\n    this.directivesEndMarker = null;\n    this.errors = [];\n    this.options = options;\n    this.schema = null;\n    this.tagPrefixes = [];\n    this.version = null;\n    this.warnings = [];\n  }\n\n  _createClass(Document, [{\n    key: \"add\",\n    value: function add(value) {\n      assertCollection(this.contents);\n      return this.contents.add(value);\n    }\n  }, {\n    key: \"addIn\",\n    value: function addIn(path, value) {\n      assertCollection(this.contents);\n      this.contents.addIn(path, value);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      assertCollection(this.contents);\n      return this.contents.delete(key);\n    }\n  }, {\n    key: \"deleteIn\",\n    value: function deleteIn(path) {\n      if (isEmptyPath(path)) {\n        if (this.contents == null) return false;\n        this.contents = null;\n        return true;\n      }\n\n      assertCollection(this.contents);\n      return this.contents.deleteIn(path);\n    }\n  }, {\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Document.defaults[this.version] || Document.defaults[this.options.version] || {};\n    }\n  }, {\n    key: \"get\",\n    value: function get(key, keepScalar) {\n      return this.contents instanceof Collection ? this.contents.get(key, keepScalar) : undefined;\n    }\n  }, {\n    key: \"getIn\",\n    value: function getIn(path, keepScalar) {\n      if (isEmptyPath(path)) return !keepScalar && this.contents instanceof Scalar ? this.contents.value : this.contents;\n      return this.contents instanceof Collection ? this.contents.getIn(path, keepScalar) : undefined;\n    }\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return this.contents instanceof Collection ? this.contents.has(key) : false;\n    }\n  }, {\n    key: \"hasIn\",\n    value: function hasIn(path) {\n      if (isEmptyPath(path)) return this.contents !== undefined;\n      return this.contents instanceof Collection ? this.contents.hasIn(path) : false;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      assertCollection(this.contents);\n      this.contents.set(key, value);\n    }\n  }, {\n    key: \"setIn\",\n    value: function setIn(path, value) {\n      if (isEmptyPath(path)) this.contents = value;else {\n        assertCollection(this.contents);\n        this.contents.setIn(path, value);\n      }\n    }\n  }, {\n    key: \"setSchema\",\n    value: function setSchema(id, customTags) {\n      if (!id && !customTags && this.schema) return;\n      if (typeof id === 'number') id = id.toFixed(1);\n\n      if (id === '1.0' || id === '1.1' || id === '1.2') {\n        if (this.version) this.version = id;else this.options.version = id;\n        delete this.options.schema;\n      } else if (id && typeof id === 'string') {\n        this.options.schema = id;\n      }\n\n      if (Array.isArray(customTags)) this.options.customTags = customTags;\n      var opt = Object.assign({}, this.getDefaults(), this.options);\n      this.schema = new Schema(opt);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(node, prevDoc) {\n      if (this.options.keepCstNodes) this.cstNode = node;\n      if (this.options.keepNodeTypes) this.type = 'DOCUMENT';\n      var _node$directives = node.directives,\n          directives = _node$directives === void 0 ? [] : _node$directives,\n          _node$contents = node.contents,\n          contents = _node$contents === void 0 ? [] : _node$contents,\n          directivesEndMarker = node.directivesEndMarker,\n          error = node.error,\n          valueRange = node.valueRange;\n\n      if (error) {\n        if (!error.source) error.source = this;\n        this.errors.push(error);\n      }\n\n      parseDirectives(this, directives, prevDoc);\n      if (directivesEndMarker) this.directivesEndMarker = true;\n      this.range = valueRange ? [valueRange.start, valueRange.end] : null;\n      this.setSchema();\n      this.anchors._cstAliases = [];\n      parseContents(this, contents);\n      this.anchors.resolveNodes();\n\n      if (this.options.prettyErrors) {\n        var _iterator = _createForOfIteratorHelper(this.errors),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var _error = _step.value;\n            if (_error instanceof YAMLError) _error.makePretty();\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        var _iterator2 = _createForOfIteratorHelper(this.warnings),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var warn = _step2.value;\n            if (warn instanceof YAMLError) warn.makePretty();\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"listNonDefaultTags\",\n    value: function listNonDefaultTags() {\n      return listTagNames(this.contents).filter(function (t) {\n        return t.indexOf(Schema.defaultPrefix) !== 0;\n      });\n    }\n  }, {\n    key: \"setTagPrefix\",\n    value: function setTagPrefix(handle, prefix) {\n      if (handle[0] !== '!' || handle[handle.length - 1] !== '!') throw new Error('Handle must start and end with !');\n\n      if (prefix) {\n        var prev = this.tagPrefixes.find(function (p) {\n          return p.handle === handle;\n        });\n        if (prev) prev.prefix = prefix;else this.tagPrefixes.push({\n          handle: handle,\n          prefix: prefix\n        });\n      } else {\n        this.tagPrefixes = this.tagPrefixes.filter(function (p) {\n          return p.handle !== handle;\n        });\n      }\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON$1(arg, onAnchor) {\n      var _this = this;\n\n      var _this$options = this.options,\n          keepBlobsInJSON = _this$options.keepBlobsInJSON,\n          mapAsMap = _this$options.mapAsMap,\n          maxAliasCount = _this$options.maxAliasCount;\n      var keep = keepBlobsInJSON && (typeof arg !== 'string' || !(this.contents instanceof Scalar));\n      var ctx = {\n        doc: this,\n        indentStep: '  ',\n        keep: keep,\n        mapAsMap: keep && !!mapAsMap,\n        maxAliasCount: maxAliasCount,\n        stringify: stringify$1 // Requiring directly in Pair would create circular dependencies\n\n      };\n      var anchorNames = Object.keys(this.anchors.map);\n      if (anchorNames.length > 0) ctx.anchors = new Map(anchorNames.map(function (name) {\n        return [_this.anchors.map[name], {\n          alias: [],\n          aliasCount: 0,\n          count: 1\n        }];\n      }));\n\n      var res = toJSON(this.contents, arg, ctx);\n\n      if (typeof onAnchor === 'function' && ctx.anchors) {\n        var _iterator3 = _createForOfIteratorHelper(ctx.anchors.values()),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var _step3$value = _step3.value,\n                count = _step3$value.count,\n                _res = _step3$value.res;\n            onAnchor(_res, count);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      return res;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      if (this.errors.length > 0) throw new Error('Document with errors cannot be stringified');\n      var indentSize = this.options.indent;\n\n      if (!Number.isInteger(indentSize) || indentSize <= 0) {\n        var s = JSON.stringify(indentSize);\n        throw new Error(\"\\\"indent\\\" option must be a positive integer, not \".concat(s));\n      }\n\n      this.setSchema();\n      var lines = [];\n      var hasDirectives = false;\n\n      if (this.version) {\n        var vd = '%YAML 1.2';\n\n        if (this.schema.name === 'yaml-1.1') {\n          if (this.version === '1.0') vd = '%YAML:1.0';else if (this.version === '1.1') vd = '%YAML 1.1';\n        }\n\n        lines.push(vd);\n        hasDirectives = true;\n      }\n\n      var tagNames = this.listNonDefaultTags();\n      this.tagPrefixes.forEach(function (_ref) {\n        var handle = _ref.handle,\n            prefix = _ref.prefix;\n\n        if (tagNames.some(function (t) {\n          return t.indexOf(prefix) === 0;\n        })) {\n          lines.push(\"%TAG \".concat(handle, \" \").concat(prefix));\n          hasDirectives = true;\n        }\n      });\n      if (hasDirectives || this.directivesEndMarker) lines.push('---');\n\n      if (this.commentBefore) {\n        if (hasDirectives || !this.directivesEndMarker) lines.unshift('');\n        lines.unshift(this.commentBefore.replace(/^/gm, '#'));\n      }\n\n      var ctx = {\n        anchors: Object.create(null),\n        doc: this,\n        indent: '',\n        indentStep: ' '.repeat(indentSize),\n        stringify: stringify$1 // Requiring directly in nodes would create circular dependencies\n\n      };\n      var chompKeep = false;\n      var contentComment = null;\n\n      if (this.contents) {\n        if (this.contents instanceof Node) {\n          if (this.contents.spaceBefore && (hasDirectives || this.directivesEndMarker)) lines.push('');\n          if (this.contents.commentBefore) lines.push(this.contents.commentBefore.replace(/^/gm, '#')); // top-level block scalars need to be indented if followed by a comment\n\n          ctx.forceBlockIndent = !!this.comment;\n          contentComment = this.contents.comment;\n        }\n\n        var onChompKeep = contentComment ? null : function () {\n          return chompKeep = true;\n        };\n        var body = stringify$1(this.contents, ctx, function () {\n          return contentComment = null;\n        }, onChompKeep);\n        lines.push(addComment(body, '', contentComment));\n      } else if (this.contents !== undefined) {\n        lines.push(stringify$1(this.contents, ctx));\n      }\n\n      if (this.comment) {\n        if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '') lines.push('');\n        lines.push(this.comment.replace(/^/gm, '#'));\n      }\n\n      return lines.join('\\n') + '\\n';\n    }\n  }]);\n\n  return Document;\n}();\n\n_defineProperty(Document$1, \"defaults\", documentOptions);\n\nfunction createNode(value) {\n  var wrapScalars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var tag = arguments.length > 2 ? arguments[2] : undefined;\n\n  if (tag === undefined && typeof wrapScalars === 'string') {\n    tag = wrapScalars;\n    wrapScalars = true;\n  }\n\n  var options = Object.assign({}, Document$1.defaults[defaultOptions.version], defaultOptions);\n  var schema = new Schema(options);\n  return schema.createNode(value, wrapScalars, tag);\n}\n\nvar Document = /*#__PURE__*/function (_YAMLDocument) {\n  _inherits(Document, _YAMLDocument);\n\n  var _super = _createSuper(Document);\n\n  function Document(options) {\n    _classCallCheck(this, Document);\n\n    return _super.call(this, Object.assign({}, defaultOptions, options));\n  }\n\n  return Document;\n}(Document$1);\n\nfunction parseAllDocuments(src, options) {\n  var stream = [];\n  var prev;\n\n  var _iterator = _createForOfIteratorHelper(parse$1(src)),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var cstDoc = _step.value;\n      var doc = new Document(options);\n      doc.parse(cstDoc, prev);\n      stream.push(doc);\n      prev = doc;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return stream;\n}\n\nfunction parseDocument(src, options) {\n  var cst = parse$1(src);\n  var doc = new Document(options).parse(cst[0]);\n\n  if (cst.length > 1) {\n    var errMsg = 'Source contains multiple documents; please use YAML.parseAllDocuments()';\n    doc.errors.unshift(new YAMLSemanticError(cst[1], errMsg));\n  }\n\n  return doc;\n}\n\nfunction parse(src, options) {\n  var doc = parseDocument(src, options);\n  doc.warnings.forEach(function (warning) {\n    return warn(warning);\n  });\n  if (doc.errors.length > 0) throw doc.errors[0];\n  return doc.toJSON();\n}\n\nfunction stringify(value, options) {\n  var doc = new Document(options);\n  doc.contents = value;\n  return String(doc);\n}\n\nvar YAML = {\n  createNode: createNode,\n  defaultOptions: defaultOptions,\n  Document: Document,\n  parse: parse,\n  parseAllDocuments: parseAllDocuments,\n  parseCST: parse$1,\n  parseDocument: parseDocument,\n  scalarOptions: scalarOptions,\n  stringify: stringify\n};\n\nexport { YAML };\n"],"mappings":"AAAA,SAASA,CAAC,IAAIC,gBAAd,EAAgCC,CAAC,IAAIC,0BAArC,EAAiEC,CAAC,IAAIC,OAAtE,EAA+EC,CAAC,IAAIC,YAApF,EAAkGC,CAAC,IAAIC,eAAvG,EAAwHC,CAAC,IAAIC,eAA7H,EAA8IC,CAAC,IAAIC,eAAnJ,EAAoKC,CAAC,IAAIC,IAAzK,EAA+KC,CAAC,IAAIC,WAApL,EAAiMC,CAAC,IAAIC,iBAAtM,EAAyNC,CAAC,IAAIC,cAA9N,EAA8OC,CAAC,IAAIC,SAAnP,EAA8PC,CAAC,IAAIC,SAAnQ,EAA8QC,CAAC,IAAIC,YAAnR,QAAuS,0BAAvS;AACA,SAASC,KAAK,IAAIC,OAAlB,QAAiC,gBAAjC;AACA,SAASvB,CAAC,IAAIwB,aAAd,EAA6B1B,CAAC,IAAI2B,WAAlC,EAA+CT,CAAC,IAAIU,UAApD,EAAgEC,CAAC,IAAIC,WAArE,EAAkFC,CAAC,IAAIC,UAAvF,EAAmGC,CAAC,IAAIC,IAAxG,EAA8GC,CAAC,IAAIC,IAAnH,EAAyHC,CAAC,IAAIC,MAA9H,EAAsIlC,CAAC,IAAImC,eAA3I,EAA4JC,CAAC,IAAIC,KAAjK,EAAwKjC,CAAC,IAAIkC,OAA7K,EAAsL9C,CAAC,IAAI+C,OAA3L,EAAoMC,CAAC,IAAIC,KAAzM,EAAgNC,CAAC,IAAIC,UAArN,EAAiOC,CAAC,IAAIC,WAAtO,EAAmP3C,CAAC,IAAI4C,WAAxP,EAAqQC,CAAC,IAAIC,MAA1Q,EAAkRxC,CAAC,IAAIyC,UAAvR,QAAyS,0BAAzS;AACA,SAAShB,CAAC,IAAIiB,MAAd,QAA4B,sBAA5B;AACA,SAASC,CAAC,IAAIC,IAAd,QAA0B,wBAA1B;AAEA,IAAIC,cAAc,GAAG;EACnBC,YAAY,EAAE,GADK;EAEnBC,UAAU,EAAE,IAFO;EAGnBC,MAAM,EAAE,CAHW;EAInBC,SAAS,EAAE,IAJQ;EAKnBC,YAAY,EAAE,KALK;EAMnBC,aAAa,EAAE,IANI;EAOnBC,eAAe,EAAE,IAPE;EAQnBC,QAAQ,EAAE,KARS;EASnBC,aAAa,EAAE,GATI;EAUnBC,YAAY,EAAE,KAVK;EAWnB;EACAC,UAAU,EAAE,KAZO;EAanBC,OAAO,EAAE;AAbU,CAArB;AAeA,IAAIC,aAAa,GAAG;EAClB,IAAIC,MAAJ,GAAa;IACX,OAAO7C,aAAP;EACD,CAHiB;;EAKlB,IAAI6C,MAAJ,CAAWC,GAAX,EAAgB;IACdC,MAAM,CAACC,MAAP,CAAchD,aAAd,EAA6B8C,GAA7B;EACD,CAPiB;;EASlB,IAAIG,IAAJ,GAAW;IACT,OAAOhD,WAAP;EACD,CAXiB;;EAalB,IAAIgD,IAAJ,CAASH,GAAT,EAAc;IACZC,MAAM,CAACC,MAAP,CAAc/C,WAAd,EAA2B6C,GAA3B;EACD,CAfiB;;EAiBlB,IAAII,GAAJ,GAAU;IACR,OAAOhD,UAAP;EACD,CAnBiB;;EAqBlB,IAAIgD,GAAJ,CAAQJ,GAAR,EAAa;IACXC,MAAM,CAACC,MAAP,CAAc9C,UAAd,EAA0B4C,GAA1B;EACD,CAvBiB;;EAyBlB,IAAIK,IAAJ,GAAW;IACT,OAAO/C,WAAP;EACD,CA3BiB;;EA6BlB,IAAI+C,IAAJ,CAASL,GAAT,EAAc;IACZC,MAAM,CAACC,MAAP,CAAc5C,WAAd,EAA2B0C,GAA3B;EACD,CA/BiB;;EAiClB,IAAIM,GAAJ,GAAU;IACR,OAAO9C,UAAP;EACD,CAnCiB;;EAqClB,IAAI8C,GAAJ,CAAQN,GAAR,EAAa;IACXC,MAAM,CAACC,MAAP,CAAc1C,UAAd,EAA0BwC,GAA1B;EACD;;AAvCiB,CAApB;AA0CA,IAAIO,eAAe,GAAG;EACpB,OAAO;IACLC,MAAM,EAAE,UADH;IAELC,KAAK,EAAE,IAFF;IAGLC,WAAW,EAAE,CAAC;MACZC,MAAM,EAAE,GADI;MAEZC,MAAM,EAAEvF;IAFI,CAAD,EAGV;MACDsF,MAAM,EAAE,IADP;MAEDC,MAAM,EAAE;IAFP,CAHU;EAHR,CADa;EAYpB,KAAK;IACHJ,MAAM,EAAE,UADL;IAEHC,KAAK,EAAE,IAFJ;IAGHC,WAAW,EAAE,CAAC;MACZC,MAAM,EAAE,GADI;MAEZC,MAAM,EAAE;IAFI,CAAD,EAGV;MACDD,MAAM,EAAE,IADP;MAEDC,MAAM,EAAEvF;IAFP,CAHU;EAHV,CAZe;EAuBpB,KAAK;IACHmF,MAAM,EAAE,MADL;IAEHC,KAAK,EAAE,KAFJ;IAGHC,WAAW,EAAE,CAAC;MACZC,MAAM,EAAE,GADI;MAEZC,MAAM,EAAE;IAFI,CAAD,EAGV;MACDD,MAAM,EAAE,IADP;MAEDC,MAAM,EAAEvF;IAFP,CAHU;EAHV;AAvBe,CAAtB;;AAoCA,SAASwF,YAAT,CAAsBC,GAAtB,EAA2BC,GAA3B,EAAgC;EAC9B,IAAI,CAACD,GAAG,CAACjB,OAAJ,IAAeiB,GAAG,CAACE,OAAJ,CAAYnB,OAA5B,MAAyC,KAA7C,EAAoD;IAClD,IAAIoB,IAAI,GAAGF,GAAG,CAACG,KAAJ,CAAU,wCAAV,CAAX;IACA,IAAID,IAAJ,EAAU,OAAO,MAAMA,IAAI,CAAC,CAAD,CAAjB;IACV,IAAIE,KAAK,GAAGJ,GAAG,CAACG,KAAJ,CAAU,2CAAV,CAAZ;IACA,OAAOC,KAAK,GAAG,IAAIC,MAAJ,CAAWD,KAAK,CAAC,CAAD,CAAhB,EAAqB,GAArB,EAA0BC,MAA1B,CAAiCD,KAAK,CAAC,CAAD,CAAtC,CAAH,GAAgD,IAAIC,MAAJ,CAAWL,GAAG,CAACM,OAAJ,CAAY,OAAZ,EAAqB,EAArB,CAAX,CAA5D;EACD;;EAED,IAAIC,CAAC,GAAGR,GAAG,CAACJ,WAAJ,CAAgBa,IAAhB,CAAqB,UAAUD,CAAV,EAAa;IACxC,OAAOP,GAAG,CAACS,OAAJ,CAAYF,CAAC,CAACV,MAAd,MAA0B,CAAjC;EACD,CAFO,CAAR;;EAIA,IAAI,CAACU,CAAL,EAAQ;IACN,IAAIG,GAAG,GAAGX,GAAG,CAACY,WAAJ,GAAkBhB,WAA5B;IACAY,CAAC,GAAGG,GAAG,IAAIA,GAAG,CAACF,IAAJ,CAAS,UAAUD,CAAV,EAAa;MAC/B,OAAOP,GAAG,CAACS,OAAJ,CAAYF,CAAC,CAACV,MAAd,MAA0B,CAAjC;IACD,CAFU,CAAX;EAGD;;EAED,IAAI,CAACU,CAAL,EAAQ,OAAOP,GAAG,CAAC,CAAD,CAAH,KAAW,GAAX,GAAiBA,GAAjB,GAAuB,KAAKK,MAAL,CAAYL,GAAZ,EAAiB,GAAjB,CAA9B;EACR,IAAIY,MAAM,GAAGZ,GAAG,CAACa,MAAJ,CAAWN,CAAC,CAACV,MAAF,CAASiB,MAApB,EAA4BR,OAA5B,CAAoC,YAApC,EAAkD,UAAUS,EAAV,EAAc;IAC3E,OAAO;MACL,KAAK,KADA;MAEL,KAAK,KAFA;MAGL,KAAK,KAHA;MAIL,KAAK,KAJA;MAKL,KAAK,KALA;MAML,KAAK;IANA,EAOLA,EAPK,CAAP;EAQD,CATY,CAAb;EAUA,OAAOR,CAAC,CAACX,MAAF,GAAWgB,MAAlB;AACD;;AAED,SAASI,YAAT,CAAsBC,IAAtB,EAA4BC,IAA5B,EAAkC;EAChC,IAAIA,IAAI,YAAYhE,KAApB,EAA2B,OAAOA,KAAP;;EAE3B,IAAIgE,IAAI,CAAClB,GAAT,EAAc;IACZ,IAAIG,KAAK,GAAGc,IAAI,CAACE,MAAL,CAAY,UAAUvD,CAAV,EAAa;MACnC,OAAOA,CAAC,CAACoC,GAAF,KAAUkB,IAAI,CAAClB,GAAtB;IACD,CAFW,CAAZ;IAGA,IAAIG,KAAK,CAACW,MAAN,GAAe,CAAnB,EAAsB,OAAOX,KAAK,CAACK,IAAN,CAAW,UAAU5C,CAAV,EAAa;MACnD,OAAOA,CAAC,CAACwD,MAAF,KAAaF,IAAI,CAACE,MAAzB;IACD,CAF4B,KAEvBjB,KAAK,CAAC,CAAD,CAFW;EAGvB;;EAED,IAAIkB,MAAJ,EAAYC,GAAZ;;EAEA,IAAIJ,IAAI,YAAYnE,MAApB,EAA4B;IAC1BuE,GAAG,GAAGJ,IAAI,CAACK,KAAX,CAD0B,CACR;;IAElB,IAAIC,MAAM,GAAGP,IAAI,CAACE,MAAL,CAAY,UAAUvD,CAAV,EAAa;MACpC,OAAOA,CAAC,CAAC6D,QAAF,IAAc7D,CAAC,CAAC6D,QAAF,CAAWH,GAAX,CAAd,IAAiC1D,CAAC,CAAC8D,KAAF,IAAWJ,GAAG,YAAY1D,CAAC,CAAC8D,KAApE;IACD,CAFY,CAAb;;IAIAL,MAAM,GAAGG,MAAM,CAAChB,IAAP,CAAY,UAAU5C,CAAV,EAAa;MAChC,OAAOA,CAAC,CAACwD,MAAF,KAAaF,IAAI,CAACE,MAAzB;IACD,CAFQ,KAEHI,MAAM,CAAChB,IAAP,CAAY,UAAU5C,CAAV,EAAa;MAC7B,OAAO,CAACA,CAAC,CAACwD,MAAV;IACD,CAFK,CAFN;EAKD,CAZD,MAYO;IACLE,GAAG,GAAGJ,IAAN;IACAG,MAAM,GAAGJ,IAAI,CAACT,IAAL,CAAU,UAAU5C,CAAV,EAAa;MAC9B,OAAOA,CAAC,CAAC+D,SAAF,IAAeL,GAAG,YAAY1D,CAAC,CAAC+D,SAAvC;IACD,CAFQ,CAAT;EAGD;;EAED,IAAI,CAACN,MAAL,EAAa;IACX,IAAIO,IAAI,GAAGN,GAAG,IAAIA,GAAG,CAACO,WAAX,GAAyBP,GAAG,CAACO,WAAJ,CAAgBD,IAAzC,GAAgDlH,OAAO,CAAC4G,GAAD,CAAlE;IACA,MAAM,IAAIQ,KAAJ,CAAU,wBAAwBzB,MAAxB,CAA+BuB,IAA/B,EAAqC,QAArC,CAAV,CAAN;EACD;;EAED,OAAOP,MAAP;AACD,C,CAAC;;;AAGF,SAASU,cAAT,CAAwBC,IAAxB,EAA8BX,MAA9B,EAAsCY,IAAtC,EAA4C;EAC1C,IAAIC,OAAO,GAAGD,IAAI,CAACC,OAAnB;EAAA,IACInC,GAAG,GAAGkC,IAAI,CAAClC,GADf;EAEA,IAAIoC,KAAK,GAAG,EAAZ;EACA,IAAIC,MAAM,GAAGrC,GAAG,CAACmC,OAAJ,CAAYG,OAAZ,CAAoBL,IAApB,CAAb;;EAEA,IAAII,MAAJ,EAAY;IACVF,OAAO,CAACE,MAAD,CAAP,GAAkBJ,IAAlB;IACAG,KAAK,CAACG,IAAN,CAAW,IAAIjC,MAAJ,CAAW+B,MAAX,CAAX;EACD;;EAED,IAAIJ,IAAI,CAAChC,GAAT,EAAc;IACZmC,KAAK,CAACG,IAAN,CAAWxC,YAAY,CAACC,GAAD,EAAMiC,IAAI,CAAChC,GAAX,CAAvB;EACD,CAFD,MAEO,IAAI,CAACqB,MAAM,CAACkB,OAAZ,EAAqB;IAC1BJ,KAAK,CAACG,IAAN,CAAWxC,YAAY,CAACC,GAAD,EAAMsB,MAAM,CAACrB,GAAb,CAAvB;EACD;;EAED,OAAOmC,KAAK,CAACK,IAAN,CAAW,GAAX,CAAP;AACD;;AAED,SAASC,WAAT,CAAqBvB,IAArB,EAA2BwB,GAA3B,EAAgCC,SAAhC,EAA2CC,WAA3C,EAAwD;EACtD,IAAIC,QAAQ,GAAGH,GAAG,CAAC3C,GAAnB;EAAA,IACImC,OAAO,GAAGW,QAAQ,CAACX,OADvB;EAAA,IAEIzC,MAAM,GAAGoD,QAAQ,CAACpD,MAFtB;EAGA,IAAI4B,MAAJ;;EAEA,IAAI,EAAEH,IAAI,YAAYvE,IAAlB,CAAJ,EAA6B;IAC3B,IAAImG,SAAS,GAAG;MACdC,UAAU,EAAE,EADE;MAEdC,QAAQ,EAAE,SAASA,QAAT,CAAkBC,CAAlB,EAAqB;QAC7B,OAAO5B,MAAM,GAAG4B,CAAhB;MACD,CAJa;MAKdC,WAAW,EAAE,IAAIC,GAAJ;IALC,CAAhB;IAOAjC,IAAI,GAAGzB,MAAM,CAAC2D,UAAP,CAAkBlC,IAAlB,EAAwB,IAAxB,EAA8B,IAA9B,EAAoC4B,SAApC,CAAP;;IAEA,IAAIO,SAAS,GAAG7I,0BAA0B,CAACsI,SAAS,CAACC,UAAX,CAA1C;IAAA,IACIO,KADJ;;IAGA,IAAI;MACF,KAAKD,SAAS,CAAC7G,CAAV,EAAL,EAAoB,CAAC,CAAC8G,KAAK,GAAGD,SAAS,CAAC/G,CAAV,EAAT,EAAwBiH,IAA7C,GAAoD;QAClD,IAAIC,KAAK,GAAGF,KAAK,CAAC/B,KAAlB;QACAiC,KAAK,CAACC,MAAN,GAAeD,KAAK,CAACC,MAAN,CAAazB,IAA5B;QACA,IAAIJ,IAAI,GAAGM,OAAO,CAACG,OAAR,CAAgBmB,KAAK,CAACC,MAAtB,CAAX;;QAEA,IAAI,CAAC7B,IAAL,EAAW;UACTA,IAAI,GAAGM,OAAO,CAACwB,OAAR,EAAP;UACAxB,OAAO,CAACyB,GAAR,CAAY/B,IAAZ,IAAoB4B,KAAK,CAACC,MAA1B;QACD;MACF;IACF,CAXD,CAWE,OAAOG,GAAP,EAAY;MACZP,SAAS,CAACtI,CAAV,CAAY6I,GAAZ;IACD,CAbD,SAaU;MACRP,SAAS,CAAChI,CAAV;IACD;EACF;;EAED,IAAI6F,IAAI,YAAYrE,IAApB,EAA0B,OAAOqE,IAAI,CAAC2C,QAAL,CAAcnB,GAAd,EAAmBC,SAAnB,EAA8BC,WAA9B,CAAP;EAC1B,IAAI,CAACvB,MAAL,EAAaA,MAAM,GAAGL,YAAY,CAACvB,MAAM,CAACwB,IAAR,EAAcC,IAAd,CAArB;EACb,IAAIiB,KAAK,GAAGJ,cAAc,CAACb,IAAD,EAAOG,MAAP,EAAeqB,GAAf,CAA1B;EACA,IAAIP,KAAK,CAACrB,MAAN,GAAe,CAAnB,EAAsB4B,GAAG,CAACoB,aAAJ,GAAoB,CAACpB,GAAG,CAACoB,aAAJ,IAAqB,CAAtB,IAA2B3B,KAAK,CAACrB,MAAjC,GAA0C,CAA9D;EACtB,IAAIvB,GAAG,GAAG,OAAO8B,MAAM,CAAC0C,SAAd,KAA4B,UAA5B,GAAyC1C,MAAM,CAAC0C,SAAP,CAAiB7C,IAAjB,EAAuBwB,GAAvB,EAA4BC,SAA5B,EAAuCC,WAAvC,CAAzC,GAA+F1B,IAAI,YAAYnE,MAAhB,GAAyBC,eAAe,CAACkE,IAAD,EAAOwB,GAAP,EAAYC,SAAZ,EAAuBC,WAAvB,CAAxC,GAA8E1B,IAAI,CAAC2C,QAAL,CAAcnB,GAAd,EAAmBC,SAAnB,EAA8BC,WAA9B,CAAvL;EACA,IAAI,CAACT,KAAL,EAAY,OAAO5C,GAAP;EACZ,OAAO2B,IAAI,YAAYnE,MAAhB,IAA0BwC,GAAG,CAAC,CAAD,CAAH,KAAW,GAArC,IAA4CA,GAAG,CAAC,CAAD,CAAH,KAAW,GAAvD,GAA6D,GAAGc,MAAH,CAAU8B,KAAV,EAAiB,GAAjB,EAAsB9B,MAAtB,CAA6Bd,GAA7B,CAA7D,GAAiG,GAAGc,MAAH,CAAU8B,KAAV,EAAiB,IAAjB,EAAuB9B,MAAvB,CAA8BqC,GAAG,CAACrE,MAAlC,EAA0CgC,MAA1C,CAAiDd,GAAjD,CAAxG;AACD;;AAED,IAAIyE,OAAO,GAAG,aAAa,YAAY;EACrC,SAASA,OAAT,CAAiBnE,MAAjB,EAAyB;IACvB/E,eAAe,CAAC,IAAD,EAAOkJ,OAAP,CAAf;;IAEAhJ,eAAe,CAAC,IAAD,EAAO,KAAP,EAAckE,MAAM,CAAC+E,MAAP,CAAc,IAAd,CAAd,CAAf;;IAEA,KAAKpE,MAAL,GAAcA,MAAd;EACD;;EAEDjF,YAAY,CAACoJ,OAAD,EAAU,CAAC;IACrBE,GAAG,EAAE,aADgB;IAErB3C,KAAK,EAAE,SAAS4C,WAAT,CAAqBnC,IAArB,EAA2BJ,IAA3B,EAAiC;MACtC,KAAKwC,SAAL,CAAepC,IAAf,EAAqBJ,IAArB;MACA,OAAO,IAAI1E,KAAJ,CAAU8E,IAAV,CAAP;IACD;EALoB,CAAD,EAMnB;IACDkC,GAAG,EAAE,iBADJ;IAED3C,KAAK,EAAE,SAAS8C,eAAT,GAA2B;MAChC,IAAIC,KAAK,GAAG,IAAZ;;MAEA,IAAI5E,KAAK,GAAG,IAAIpC,KAAJ,EAAZ;;MAEA,KAAK,IAAIiH,IAAI,GAAGC,SAAS,CAAC1D,MAArB,EAA6B2D,OAAO,GAAG,IAAIC,KAAJ,CAAUH,IAAV,CAAvC,EAAwDI,IAAI,GAAG,CAApE,EAAuEA,IAAI,GAAGJ,IAA9E,EAAoFI,IAAI,EAAxF,EAA4F;QAC1FF,OAAO,CAACE,IAAD,CAAP,GAAgBH,SAAS,CAACG,IAAD,CAAzB;MACD;;MAEDjF,KAAK,CAAC6B,KAAN,CAAYqD,KAAZ,GAAoBH,OAAO,CAACd,GAAR,CAAY,UAAUnH,CAAV,EAAa;QAC3C,IAAIA,CAAC,YAAYU,KAAjB,EAAwB;UACtB,IAAIV,CAAC,CAACiH,MAAF,YAAoBrG,OAAxB,EAAiC,OAAOZ,CAAP;QAClC,CAFD,MAEO,IAAIA,CAAC,YAAYY,OAAjB,EAA0B;UAC/B,OAAOkH,KAAK,CAACH,WAAN,CAAkB3H,CAAlB,CAAP;QACD;;QAED,MAAM,IAAIsF,KAAJ,CAAU,kDAAV,CAAN;MACD,CARmB,CAApB;MASA,OAAOpC,KAAP;IACD;EArBA,CANmB,EA4BnB;IACDwE,GAAG,EAAE,SADJ;IAED3C,KAAK,EAAE,SAASc,OAAT,CAAiBL,IAAjB,EAAuB;MAC5B,IAAI2B,GAAG,GAAG,KAAKA,GAAf;MACA,OAAOzE,MAAM,CAAC2F,IAAP,CAAYlB,GAAZ,EAAiBnD,IAAjB,CAAsB,UAAU/F,CAAV,EAAa;QACxC,OAAOkJ,GAAG,CAAClJ,CAAD,CAAH,KAAWuH,IAAlB;MACD,CAFM,CAAP;IAGD;EAPA,CA5BmB,EAoCnB;IACDkC,GAAG,EAAE,UADJ;IAED3C,KAAK,EAAE,SAASuD,QAAT,GAAoB;MACzB,OAAO5F,MAAM,CAAC2F,IAAP,CAAY,KAAKlB,GAAjB,CAAP;IACD;EAJA,CApCmB,EAyCnB;IACDO,GAAG,EAAE,SADJ;IAED3C,KAAK,EAAE,SAASwD,OAAT,CAAiBnD,IAAjB,EAAuB;MAC5B,OAAO,KAAK+B,GAAL,CAAS/B,IAAT,CAAP;IACD;EAJA,CAzCmB,EA8CnB;IACDsC,GAAG,EAAE,SADJ;IAED3C,KAAK,EAAE,SAASmC,OAAT,CAAiB7D,MAAjB,EAAyB;MAC9B,IAAI,CAACA,MAAL,EAAaA,MAAM,GAAG,KAAKA,MAAd;MACb,IAAImF,KAAK,GAAG9F,MAAM,CAAC2F,IAAP,CAAY,KAAKlB,GAAjB,CAAZ;;MAEA,KAAK,IAAIhI,CAAC,GAAG,CAAb,EAAgB,IAAhB,EAAsB,EAAEA,CAAxB,EAA2B;QACzB,IAAIiG,IAAI,GAAG,GAAGvB,MAAH,CAAUR,MAAV,EAAkBQ,MAAlB,CAAyB1E,CAAzB,CAAX;QACA,IAAI,CAACqJ,KAAK,CAACC,QAAN,CAAerD,IAAf,CAAL,EAA2B,OAAOA,IAAP;MAC5B;IACF,CAVA,CAUC;;EAVD,CA9CmB,EA0DnB;IACDsC,GAAG,EAAE,cADJ;IAED3C,KAAK,EAAE,SAAS2D,YAAT,GAAwB;MAC7B,IAAIvB,GAAG,GAAG,KAAKA,GAAf;MAAA,IACIwB,WAAW,GAAG,KAAKA,WADvB;MAEAjG,MAAM,CAAC2F,IAAP,CAAYlB,GAAZ,EAAiByB,OAAjB,CAAyB,UAAU3K,CAAV,EAAa;QACpCkJ,GAAG,CAAClJ,CAAD,CAAH,GAASkJ,GAAG,CAAClJ,CAAD,CAAH,CAAO4K,QAAhB;MACD,CAFD;;MAIAF,WAAW,CAACC,OAAZ,CAAoB,UAAU3K,CAAV,EAAa;QAC/BA,CAAC,CAACgJ,MAAF,GAAWhJ,CAAC,CAACgJ,MAAF,CAAS4B,QAApB;MACD,CAFD;;MAIA,OAAO,KAAKF,WAAZ;IACD;EAdA,CA1DmB,EAyEnB;IACDjB,GAAG,EAAE,WADJ;IAED3C,KAAK,EAAE,SAAS6C,SAAT,CAAmBpC,IAAnB,EAAyBJ,IAAzB,EAA+B;MACpC,IAAII,IAAI,IAAI,IAAR,IAAgB,CAACgC,OAAO,CAACsB,eAAR,CAAwBtD,IAAxB,CAArB,EAAoD;QAClD,MAAM,IAAIF,KAAJ,CAAU,uDAAV,CAAN;MACD;;MAED,IAAIF,IAAI,IAAI,sBAAsB2D,IAAtB,CAA2B3D,IAA3B,CAAZ,EAA8C;QAC5C,MAAM,IAAIE,KAAJ,CAAU,gEAAV,CAAN;MACD;;MAED,IAAI6B,GAAG,GAAG,KAAKA,GAAf;MACA,IAAI6B,IAAI,GAAGxD,IAAI,IAAI9C,MAAM,CAAC2F,IAAP,CAAYlB,GAAZ,EAAiBnD,IAAjB,CAAsB,UAAU/F,CAAV,EAAa;QACpD,OAAOkJ,GAAG,CAAClJ,CAAD,CAAH,KAAWuH,IAAlB;MACD,CAFkB,CAAnB;;MAIA,IAAIwD,IAAJ,EAAU;QACR,IAAI,CAAC5D,IAAL,EAAW;UACT,OAAO4D,IAAP;QACD,CAFD,MAEO,IAAIA,IAAI,KAAK5D,IAAb,EAAmB;UACxB,OAAO+B,GAAG,CAAC6B,IAAD,CAAV;UACA7B,GAAG,CAAC/B,IAAD,CAAH,GAAYI,IAAZ;QACD;MACF,CAPD,MAOO;QACL,IAAI,CAACJ,IAAL,EAAW;UACT,IAAI,CAACI,IAAL,EAAW,OAAO,IAAP;UACXJ,IAAI,GAAG,KAAK8B,OAAL,EAAP;QACD;;QAEDC,GAAG,CAAC/B,IAAD,CAAH,GAAYI,IAAZ;MACD;;MAED,OAAOJ,IAAP;IACD;EAjCA,CAzEmB,CAAV,EA2GR,CAAC;IACHsC,GAAG,EAAE,iBADF;IAEH3C,KAAK,EAAE,SAAS+D,eAAT,CAAyBtD,IAAzB,EAA+B;MACpC,OAAOA,IAAI,YAAYjF,MAAhB,IAA0BiF,IAAI,YAAY7E,OAA1C,IAAqD6E,IAAI,YAAY5E,OAA5E;IACD;EAJE,CAAD,CA3GQ,CAAZ;;EAkHA,OAAO4G,OAAP;AACD,CA5H0B,EAA3B;;AA8HA,IAAIyB,KAAK,GAAG,SAASA,KAAT,CAAezD,IAAf,EAAqBf,IAArB,EAA2B;EACrC,IAAIe,IAAI,IAAItH,OAAO,CAACsH,IAAD,CAAP,KAAkB,QAA9B,EAAwC;IACtC,IAAIhC,GAAG,GAAGgC,IAAI,CAAChC,GAAf;;IAEA,IAAIgC,IAAI,YAAYxE,UAApB,EAAgC;MAC9B,IAAIwC,GAAJ,EAASiB,IAAI,CAACjB,GAAD,CAAJ,GAAY,IAAZ;MACTgC,IAAI,CAAC4C,KAAL,CAAWQ,OAAX,CAAmB,UAAU9I,CAAV,EAAa;QAC9B,OAAOmJ,KAAK,CAACnJ,CAAD,EAAI2E,IAAJ,CAAZ;MACD,CAFD;IAGD,CALD,MAKO,IAAIe,IAAI,YAAYnF,IAApB,EAA0B;MAC/B4I,KAAK,CAACzD,IAAI,CAACkC,GAAN,EAAWjD,IAAX,CAAL;MACAwE,KAAK,CAACzD,IAAI,CAACT,KAAN,EAAaN,IAAb,CAAL;IACD,CAHM,MAGA,IAAIe,IAAI,YAAYjF,MAApB,EAA4B;MACjC,IAAIiD,GAAJ,EAASiB,IAAI,CAACjB,GAAD,CAAJ,GAAY,IAAZ;IACV;EACF;;EAED,OAAOiB,IAAP;AACD,CAlBD;;AAoBA,IAAIyE,YAAY,GAAG,SAASA,YAAT,CAAsB1D,IAAtB,EAA4B;EAC7C,OAAO9C,MAAM,CAAC2F,IAAP,CAAYY,KAAK,CAACzD,IAAD,EAAO,EAAP,CAAjB,CAAP;AACD,CAFD;;AAIA,SAAS2D,aAAT,CAAuB5F,GAAvB,EAA4B6F,QAA5B,EAAsC;EACpC,IAAIC,QAAQ,GAAG;IACbC,MAAM,EAAE,EADK;IAEbC,KAAK,EAAE;EAFM,CAAf;EAIA,IAAIC,IAAI,GAAGC,SAAX;EACA,IAAIC,WAAW,GAAG,KAAlB;;EAEA,IAAI7C,SAAS,GAAG7I,0BAA0B,CAACoL,QAAD,CAA1C;EAAA,IACItC,KADJ;;EAGA,IAAI;IACF,KAAKD,SAAS,CAAC7G,CAAV,EAAL,EAAoB,CAAC,CAAC8G,KAAK,GAAGD,SAAS,CAAC/G,CAAV,EAAT,EAAwBiH,IAA7C,GAAoD;MAClD,IAAIvB,IAAI,GAAGsB,KAAK,CAAC/B,KAAjB;;MAEA,IAAIS,IAAI,CAACmE,UAAT,EAAqB;QACnB,IAAIH,IAAI,KAAKC,SAAb,EAAwB;UACtB,IAAIG,GAAG,GAAG,uEAAV;UACArG,GAAG,CAACsG,MAAJ,CAAW/D,IAAX,CAAgB,IAAIpH,eAAJ,CAAoB8G,IAApB,EAA0BoE,GAA1B,CAAhB;UACA;QACD;;QAED,IAAIE,GAAG,GAAG5I,WAAW,CAACqC,GAAD,EAAMiC,IAAN,CAArB;;QAEA,IAAIkE,WAAJ,EAAiB;UACfI,GAAG,CAACJ,WAAJ,GAAkB,IAAlB;UACAA,WAAW,GAAG,KAAd;QACD;;QAEDF,IAAI,GAAGM,GAAP;MACD,CAfD,MAeO,IAAItE,IAAI,CAACuE,OAAL,KAAiB,IAArB,EAA2B;QAChC,IAAIC,EAAE,GAAGR,IAAI,KAAKC,SAAT,GAAqBJ,QAAQ,CAACC,MAA9B,GAAuCD,QAAQ,CAACE,KAAzD;QACAS,EAAE,CAAClE,IAAH,CAAQN,IAAI,CAACuE,OAAb;MACD,CAHM,MAGA,IAAIvE,IAAI,CAACyE,IAAL,KAAcrL,IAAI,CAACsL,UAAvB,EAAmC;QACxCR,WAAW,GAAG,IAAd;;QAEA,IAAIF,IAAI,KAAKC,SAAT,IAAsBJ,QAAQ,CAACC,MAAT,CAAgBhF,MAAhB,GAAyB,CAA/C,IAAoD,CAACf,GAAG,CAAC4G,aAA7D,EAA4E;UAC1E;UACA5G,GAAG,CAAC4G,aAAJ,GAAoBd,QAAQ,CAACC,MAAT,CAAgBtD,IAAhB,CAAqB,IAArB,CAApB;UACAqD,QAAQ,CAACC,MAAT,GAAkB,EAAlB;QACD;MACF;IACF;EACF,CAhCD,CAgCE,OAAOlC,GAAP,EAAY;IACZP,SAAS,CAACtI,CAAV,CAAY6I,GAAZ;EACD,CAlCD,SAkCU;IACRP,SAAS,CAAChI,CAAV;EACD;;EAED0E,GAAG,CAAC6F,QAAJ,GAAeI,IAAI,IAAI,IAAvB;;EAEA,IAAI,CAACA,IAAL,EAAW;IACTjG,GAAG,CAACwG,OAAJ,GAAcV,QAAQ,CAACC,MAAT,CAAgBzF,MAAhB,CAAuBwF,QAAQ,CAACE,KAAhC,EAAuCvD,IAAvC,CAA4C,IAA5C,KAAqD,IAAnE;EACD,CAFD,MAEO;IACL,IAAIoE,EAAE,GAAGf,QAAQ,CAACC,MAAT,CAAgBtD,IAAhB,CAAqB,IAArB,CAAT;;IAEA,IAAIoE,EAAJ,EAAQ;MACN,IAAIC,MAAM,GAAGb,IAAI,YAAYxI,UAAhB,IAA8BwI,IAAI,CAACpB,KAAL,CAAW,CAAX,CAA9B,GAA8CoB,IAAI,CAACpB,KAAL,CAAW,CAAX,CAA9C,GAA8DoB,IAA3E;MACAa,MAAM,CAACF,aAAP,GAAuBE,MAAM,CAACF,aAAP,GAAuB,GAAGtG,MAAH,CAAUuG,EAAV,EAAc,IAAd,EAAoBvG,MAApB,CAA2BwG,MAAM,CAACF,aAAlC,CAAvB,GAA0EC,EAAjG;IACD;;IAED7G,GAAG,CAACwG,OAAJ,GAAcV,QAAQ,CAACE,KAAT,CAAevD,IAAf,CAAoB,IAApB,KAA6B,IAA3C;EACD;AACF;;AAED,SAASsE,mBAAT,CAA6B7E,IAA7B,EAAmC8E,SAAnC,EAA8C;EAC5C,IAAIpH,WAAW,GAAGsC,IAAI,CAACtC,WAAvB;;EAEA,IAAIqH,qBAAqB,GAAGtL,cAAc,CAACqL,SAAS,CAACE,UAAX,EAAuB,CAAvB,CAA1C;EAAA,IACIrH,MAAM,GAAGoH,qBAAqB,CAAC,CAAD,CADlC;EAAA,IAEInH,MAAM,GAAGmH,qBAAqB,CAAC,CAAD,CAFlC;;EAIA,IAAI,CAACpH,MAAD,IAAW,CAACC,MAAhB,EAAwB;IACtB,IAAIuG,GAAG,GAAG,kDAAV;IACA,MAAM,IAAI5K,iBAAJ,CAAsBuL,SAAtB,EAAiCX,GAAjC,CAAN;EACD;;EAED,IAAIzG,WAAW,CAACuH,IAAZ,CAAiB,UAAU3G,CAAV,EAAa;IAChC,OAAOA,CAAC,CAACX,MAAF,KAAaA,MAApB;EACD,CAFG,CAAJ,EAEI;IACF,IAAIuH,IAAI,GAAG,qFAAX;IACA,MAAM,IAAI3L,iBAAJ,CAAsBuL,SAAtB,EAAiCI,IAAjC,CAAN;EACD;;EAED,OAAO;IACLvH,MAAM,EAAEA,MADH;IAELC,MAAM,EAAEA;EAFH,CAAP;AAID;;AAED,SAASuH,oBAAT,CAA8BrH,GAA9B,EAAmCgH,SAAnC,EAA8C;EAC5C,IAAIM,sBAAsB,GAAG3L,cAAc,CAACqL,SAAS,CAACE,UAAX,EAAuB,CAAvB,CAA3C;EAAA,IACInI,OAAO,GAAGuI,sBAAsB,CAAC,CAAD,CADpC;;EAGA,IAAIN,SAAS,CAACnF,IAAV,KAAmB,UAAvB,EAAmC9C,OAAO,GAAG,KAAV;;EAEnC,IAAI,CAACA,OAAL,EAAc;IACZ,IAAIsH,GAAG,GAAG,mDAAV;IACA,MAAM,IAAI5K,iBAAJ,CAAsBuL,SAAtB,EAAiCX,GAAjC,CAAN;EACD;;EAED,IAAI,CAAC5G,eAAe,CAACV,OAAD,CAApB,EAA+B;IAC7B,IAAIwI,EAAE,GAAGvH,GAAG,CAACjB,OAAJ,IAAeiB,GAAG,CAACE,OAAJ,CAAYnB,OAApC;;IAEA,IAAIyI,KAAK,GAAG,mCAAmClH,MAAnC,CAA0CiH,EAA1C,EAA8C,oBAA9C,EAAoEjH,MAApE,CAA2EvB,OAA3E,CAAZ;;IAEAiB,GAAG,CAACyH,QAAJ,CAAalF,IAAb,CAAkB,IAAIhH,WAAJ,CAAgByL,SAAhB,EAA2BQ,KAA3B,CAAlB;EACD;;EAED,OAAOzI,OAAP;AACD;;AAED,SAAS2I,eAAT,CAAyB1H,GAAzB,EAA8B2H,UAA9B,EAA0CC,OAA1C,EAAmD;EACjD,IAAIC,iBAAiB,GAAG,EAAxB;EACA,IAAIC,aAAa,GAAG,KAApB;;EAEA,IAAIxE,SAAS,GAAG7I,0BAA0B,CAACkN,UAAD,CAA1C;EAAA,IACIpE,KADJ;;EAGA,IAAI;IACF,KAAKD,SAAS,CAAC7G,CAAV,EAAL,EAAoB,CAAC,CAAC8G,KAAK,GAAGD,SAAS,CAAC/G,CAAV,EAAT,EAAwBiH,IAA7C,GAAoD;MAClD,IAAIwD,SAAS,GAAGzD,KAAK,CAAC/B,KAAtB;MACA,IAAIgF,OAAO,GAAGQ,SAAS,CAACR,OAAxB;MAAA,IACI3E,IAAI,GAAGmF,SAAS,CAACnF,IADrB;;MAGA,QAAQA,IAAR;QACE,KAAK,KAAL;UACE,IAAI;YACF7B,GAAG,CAACJ,WAAJ,CAAgB2C,IAAhB,CAAqBwE,mBAAmB,CAAC/G,GAAD,EAAMgH,SAAN,CAAxC;UACD,CAFD,CAEE,OAAOe,KAAP,EAAc;YACd/H,GAAG,CAACsG,MAAJ,CAAW/D,IAAX,CAAgBwF,KAAhB;UACD;;UAEDD,aAAa,GAAG,IAAhB;UACA;;QAEF,KAAK,MAAL;QACA,KAAK,UAAL;UACE,IAAI9H,GAAG,CAACjB,OAAR,EAAiB;YACf,IAAIsH,GAAG,GAAG,mEAAV;YACArG,GAAG,CAACsG,MAAJ,CAAW/D,IAAX,CAAgB,IAAI9G,iBAAJ,CAAsBuL,SAAtB,EAAiCX,GAAjC,CAAhB;UACD;;UAED,IAAI;YACFrG,GAAG,CAACjB,OAAJ,GAAcsI,oBAAoB,CAACrH,GAAD,EAAMgH,SAAN,CAAlC;UACD,CAFD,CAEE,OAAOe,KAAP,EAAc;YACd/H,GAAG,CAACsG,MAAJ,CAAW/D,IAAX,CAAgBwF,KAAhB;UACD;;UAEDD,aAAa,GAAG,IAAhB;UACA;;QAEF;UACE,IAAIjG,IAAJ,EAAU;YACR,IAAImG,KAAK,GAAG,0DAA0D1H,MAA1D,CAAiEuB,IAAjE,CAAZ;;YAEA7B,GAAG,CAACyH,QAAJ,CAAalF,IAAb,CAAkB,IAAIhH,WAAJ,CAAgByL,SAAhB,EAA2BgB,KAA3B,CAAlB;UACD;;MAhCL;;MAoCA,IAAIxB,OAAJ,EAAaqB,iBAAiB,CAACtF,IAAlB,CAAuBiE,OAAvB;IACd;EACF,CA5CD,CA4CE,OAAO3C,GAAP,EAAY;IACZP,SAAS,CAACtI,CAAV,CAAY6I,GAAZ;EACD,CA9CD,SA8CU;IACRP,SAAS,CAAChI,CAAV;EACD;;EAED,IAAIsM,OAAO,IAAI,CAACE,aAAZ,IAA6B,WAAW9H,GAAG,CAACjB,OAAJ,IAAe6I,OAAO,CAAC7I,OAAvB,IAAkCiB,GAAG,CAACE,OAAJ,CAAYnB,OAAzD,CAAjC,EAAoG;IAClG,IAAIkJ,aAAa,GAAG,SAASA,aAAT,CAAuBC,KAAvB,EAA8B;MAChD,IAAIrI,MAAM,GAAGqI,KAAK,CAACrI,MAAnB;MAAA,IACIC,MAAM,GAAGoI,KAAK,CAACpI,MADnB;MAEA,OAAO;QACLD,MAAM,EAAEA,MADH;QAELC,MAAM,EAAEA;MAFH,CAAP;IAID,CAPD;;IASAE,GAAG,CAACJ,WAAJ,GAAkBgI,OAAO,CAAChI,WAAR,CAAoBgE,GAApB,CAAwBqE,aAAxB,CAAlB;IACAjI,GAAG,CAACjB,OAAJ,GAAc6I,OAAO,CAAC7I,OAAtB;EACD;;EAEDiB,GAAG,CAAC4G,aAAJ,GAAoBiB,iBAAiB,CAACpF,IAAlB,CAAuB,IAAvB,KAAgC,IAApD;AACD;;AAED,SAAS0F,gBAAT,CAA0BtC,QAA1B,EAAoC;EAClC,IAAIA,QAAQ,YAAYpI,UAAxB,EAAoC,OAAO,IAAP;EACpC,MAAM,IAAIsE,KAAJ,CAAU,iDAAV,CAAN;AACD;;AAED,IAAIqG,UAAU,GAAG,aAAa,YAAY;EACxC,SAASC,QAAT,CAAkBnI,OAAlB,EAA2B;IACzBnF,eAAe,CAAC,IAAD,EAAOsN,QAAP,CAAf;;IAEA,KAAKlG,OAAL,GAAe,IAAI8B,OAAJ,CAAY/D,OAAO,CAAC9B,YAApB,CAAf;IACA,KAAKwI,aAAL,GAAqB,IAArB;IACA,KAAKJ,OAAL,GAAe,IAAf;IACA,KAAKX,QAAL,GAAgB,IAAhB;IACA,KAAKyC,mBAAL,GAA2B,IAA3B;IACA,KAAKhC,MAAL,GAAc,EAAd;IACA,KAAKpG,OAAL,GAAeA,OAAf;IACA,KAAKR,MAAL,GAAc,IAAd;IACA,KAAKE,WAAL,GAAmB,EAAnB;IACA,KAAKb,OAAL,GAAe,IAAf;IACA,KAAK0I,QAAL,GAAgB,EAAhB;EACD;;EAED5M,YAAY,CAACwN,QAAD,EAAW,CAAC;IACtBlE,GAAG,EAAE,KADiB;IAEtB3C,KAAK,EAAE,SAAS+G,GAAT,CAAa/G,KAAb,EAAoB;MACzB2G,gBAAgB,CAAC,KAAKtC,QAAN,CAAhB;MACA,OAAO,KAAKA,QAAL,CAAc0C,GAAd,CAAkB/G,KAAlB,CAAP;IACD;EALqB,CAAD,EAMpB;IACD2C,GAAG,EAAE,OADJ;IAED3C,KAAK,EAAE,SAASgH,KAAT,CAAeC,IAAf,EAAqBjH,KAArB,EAA4B;MACjC2G,gBAAgB,CAAC,KAAKtC,QAAN,CAAhB;MACA,KAAKA,QAAL,CAAc2C,KAAd,CAAoBC,IAApB,EAA0BjH,KAA1B;IACD;EALA,CANoB,EAYpB;IACD2C,GAAG,EAAE,QADJ;IAED3C,KAAK,EAAE,SAASkH,OAAT,CAAiBvE,GAAjB,EAAsB;MAC3BgE,gBAAgB,CAAC,KAAKtC,QAAN,CAAhB;MACA,OAAO,KAAKA,QAAL,CAAc8C,MAAd,CAAqBxE,GAArB,CAAP;IACD;EALA,CAZoB,EAkBpB;IACDA,GAAG,EAAE,UADJ;IAED3C,KAAK,EAAE,SAASoH,QAAT,CAAkBH,IAAlB,EAAwB;MAC7B,IAAI7K,WAAW,CAAC6K,IAAD,CAAf,EAAuB;QACrB,IAAI,KAAK5C,QAAL,IAAiB,IAArB,EAA2B,OAAO,KAAP;QAC3B,KAAKA,QAAL,GAAgB,IAAhB;QACA,OAAO,IAAP;MACD;;MAEDsC,gBAAgB,CAAC,KAAKtC,QAAN,CAAhB;MACA,OAAO,KAAKA,QAAL,CAAc+C,QAAd,CAAuBH,IAAvB,CAAP;IACD;EAXA,CAlBoB,EA8BpB;IACDtE,GAAG,EAAE,aADJ;IAED3C,KAAK,EAAE,SAASZ,WAAT,GAAuB;MAC5B,OAAOyH,QAAQ,CAACQ,QAAT,CAAkB,KAAK9J,OAAvB,KAAmCsJ,QAAQ,CAACQ,QAAT,CAAkB,KAAK3I,OAAL,CAAanB,OAA/B,CAAnC,IAA8E,EAArF;IACD;EAJA,CA9BoB,EAmCpB;IACDoF,GAAG,EAAE,KADJ;IAED3C,KAAK,EAAE,SAASsH,GAAT,CAAa3E,GAAb,EAAkB4E,UAAlB,EAA8B;MACnC,OAAO,KAAKlD,QAAL,YAAyBpI,UAAzB,GAAsC,KAAKoI,QAAL,CAAciD,GAAd,CAAkB3E,GAAlB,EAAuB4E,UAAvB,CAAtC,GAA2E7C,SAAlF;IACD;EAJA,CAnCoB,EAwCpB;IACD/B,GAAG,EAAE,OADJ;IAED3C,KAAK,EAAE,SAASwH,KAAT,CAAeP,IAAf,EAAqBM,UAArB,EAAiC;MACtC,IAAInL,WAAW,CAAC6K,IAAD,CAAf,EAAuB,OAAO,CAACM,UAAD,IAAe,KAAKlD,QAAL,YAAyB7I,MAAxC,GAAiD,KAAK6I,QAAL,CAAcrE,KAA/D,GAAuE,KAAKqE,QAAnF;MACvB,OAAO,KAAKA,QAAL,YAAyBpI,UAAzB,GAAsC,KAAKoI,QAAL,CAAcmD,KAAd,CAAoBP,IAApB,EAA0BM,UAA1B,CAAtC,GAA8E7C,SAArF;IACD;EALA,CAxCoB,EA8CpB;IACD/B,GAAG,EAAE,KADJ;IAED3C,KAAK,EAAE,SAASyH,GAAT,CAAa9E,GAAb,EAAkB;MACvB,OAAO,KAAK0B,QAAL,YAAyBpI,UAAzB,GAAsC,KAAKoI,QAAL,CAAcoD,GAAd,CAAkB9E,GAAlB,CAAtC,GAA+D,KAAtE;IACD;EAJA,CA9CoB,EAmDpB;IACDA,GAAG,EAAE,OADJ;IAED3C,KAAK,EAAE,SAAS0H,KAAT,CAAeT,IAAf,EAAqB;MAC1B,IAAI7K,WAAW,CAAC6K,IAAD,CAAf,EAAuB,OAAO,KAAK5C,QAAL,KAAkBK,SAAzB;MACvB,OAAO,KAAKL,QAAL,YAAyBpI,UAAzB,GAAsC,KAAKoI,QAAL,CAAcqD,KAAd,CAAoBT,IAApB,CAAtC,GAAkE,KAAzE;IACD;EALA,CAnDoB,EAyDpB;IACDtE,GAAG,EAAE,KADJ;IAED3C,KAAK,EAAE,SAAS2H,GAAT,CAAahF,GAAb,EAAkB3C,KAAlB,EAAyB;MAC9B2G,gBAAgB,CAAC,KAAKtC,QAAN,CAAhB;MACA,KAAKA,QAAL,CAAcsD,GAAd,CAAkBhF,GAAlB,EAAuB3C,KAAvB;IACD;EALA,CAzDoB,EA+DpB;IACD2C,GAAG,EAAE,OADJ;IAED3C,KAAK,EAAE,SAAS4H,KAAT,CAAeX,IAAf,EAAqBjH,KAArB,EAA4B;MACjC,IAAI5D,WAAW,CAAC6K,IAAD,CAAf,EAAuB,KAAK5C,QAAL,GAAgBrE,KAAhB,CAAvB,KAAkD;QAChD2G,gBAAgB,CAAC,KAAKtC,QAAN,CAAhB;QACA,KAAKA,QAAL,CAAcuD,KAAd,CAAoBX,IAApB,EAA0BjH,KAA1B;MACD;IACF;EAPA,CA/DoB,EAuEpB;IACD2C,GAAG,EAAE,WADJ;IAED3C,KAAK,EAAE,SAAS6H,SAAT,CAAmBC,EAAnB,EAAuBjL,UAAvB,EAAmC;MACxC,IAAI,CAACiL,EAAD,IAAO,CAACjL,UAAR,IAAsB,KAAKqB,MAA/B,EAAuC;MACvC,IAAI,OAAO4J,EAAP,KAAc,QAAlB,EAA4BA,EAAE,GAAGA,EAAE,CAACC,OAAH,CAAW,CAAX,CAAL;;MAE5B,IAAID,EAAE,KAAK,KAAP,IAAgBA,EAAE,KAAK,KAAvB,IAAgCA,EAAE,KAAK,KAA3C,EAAkD;QAChD,IAAI,KAAKvK,OAAT,EAAkB,KAAKA,OAAL,GAAeuK,EAAf,CAAlB,KAAyC,KAAKpJ,OAAL,CAAanB,OAAb,GAAuBuK,EAAvB;QACzC,OAAO,KAAKpJ,OAAL,CAAaR,MAApB;MACD,CAHD,MAGO,IAAI4J,EAAE,IAAI,OAAOA,EAAP,KAAc,QAAxB,EAAkC;QACvC,KAAKpJ,OAAL,CAAaR,MAAb,GAAsB4J,EAAtB;MACD;;MAED,IAAI3E,KAAK,CAAC6E,OAAN,CAAcnL,UAAd,CAAJ,EAA+B,KAAK6B,OAAL,CAAa7B,UAAb,GAA0BA,UAA1B;MAC/B,IAAIa,GAAG,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB,KAAKwB,WAAL,EAAlB,EAAsC,KAAKV,OAA3C,CAAV;MACA,KAAKR,MAAL,GAAc,IAAI1B,MAAJ,CAAWkB,GAAX,CAAd;IACD;EAhBA,CAvEoB,EAwFpB;IACDiF,GAAG,EAAE,OADJ;IAED3C,KAAK,EAAE,SAAStF,KAAT,CAAe+F,IAAf,EAAqB2F,OAArB,EAA8B;MACnC,IAAI,KAAK1H,OAAL,CAAa1B,YAAjB,EAA+B,KAAKiL,OAAL,GAAexH,IAAf;MAC/B,IAAI,KAAK/B,OAAL,CAAazB,aAAjB,EAAgC,KAAKiI,IAAL,GAAY,UAAZ;MAChC,IAAIgD,gBAAgB,GAAGzH,IAAI,CAAC0F,UAA5B;MAAA,IACIA,UAAU,GAAG+B,gBAAgB,KAAK,KAAK,CAA1B,GAA8B,EAA9B,GAAmCA,gBADpD;MAAA,IAEIC,cAAc,GAAG1H,IAAI,CAAC4D,QAF1B;MAAA,IAGIA,QAAQ,GAAG8D,cAAc,KAAK,KAAK,CAAxB,GAA4B,EAA5B,GAAiCA,cAHhD;MAAA,IAIIrB,mBAAmB,GAAGrG,IAAI,CAACqG,mBAJ/B;MAAA,IAKIP,KAAK,GAAG9F,IAAI,CAAC8F,KALjB;MAAA,IAMI3B,UAAU,GAAGnE,IAAI,CAACmE,UANtB;;MAQA,IAAI2B,KAAJ,EAAW;QACT,IAAI,CAACA,KAAK,CAACrE,MAAX,EAAmBqE,KAAK,CAACrE,MAAN,GAAe,IAAf;QACnB,KAAK4C,MAAL,CAAY/D,IAAZ,CAAiBwF,KAAjB;MACD;;MAEDL,eAAe,CAAC,IAAD,EAAOC,UAAP,EAAmBC,OAAnB,CAAf;MACA,IAAIU,mBAAJ,EAAyB,KAAKA,mBAAL,GAA2B,IAA3B;MACzB,KAAKsB,KAAL,GAAaxD,UAAU,GAAG,CAACA,UAAU,CAACyD,KAAZ,EAAmBzD,UAAU,CAAC0D,GAA9B,CAAH,GAAwC,IAA/D;MACA,KAAKT,SAAL;MACA,KAAKlH,OAAL,CAAaiD,WAAb,GAA2B,EAA3B;MACAQ,aAAa,CAAC,IAAD,EAAOC,QAAP,CAAb;MACA,KAAK1D,OAAL,CAAagD,YAAb;;MAEA,IAAI,KAAKjF,OAAL,CAAarB,YAAjB,EAA+B;QAC7B,IAAIyE,SAAS,GAAG7I,0BAA0B,CAAC,KAAK6L,MAAN,CAA1C;QAAA,IACI/C,KADJ;;QAGA,IAAI;UACF,KAAKD,SAAS,CAAC7G,CAAV,EAAL,EAAoB,CAAC,CAAC8G,KAAK,GAAGD,SAAS,CAAC/G,CAAV,EAAT,EAAwBiH,IAA7C,GAAoD;YAClD,IAAIuG,MAAM,GAAGxG,KAAK,CAAC/B,KAAnB;YACA,IAAIuI,MAAM,YAAYlO,SAAtB,EAAiCkO,MAAM,CAACC,UAAP;UAClC;QACF,CALD,CAKE,OAAOnG,GAAP,EAAY;UACZP,SAAS,CAACtI,CAAV,CAAY6I,GAAZ;QACD,CAPD,SAOU;UACRP,SAAS,CAAChI,CAAV;QACD;;QAED,IAAI2O,UAAU,GAAGxP,0BAA0B,CAAC,KAAKgN,QAAN,CAA3C;QAAA,IACIyC,MADJ;;QAGA,IAAI;UACF,KAAKD,UAAU,CAACxN,CAAX,EAAL,EAAqB,CAAC,CAACyN,MAAM,GAAGD,UAAU,CAAC1N,CAAX,EAAV,EAA0BiH,IAAhD,GAAuD;YACrD,IAAItF,IAAI,GAAGgM,MAAM,CAAC1I,KAAlB;YACA,IAAItD,IAAI,YAAYrC,SAApB,EAA+BqC,IAAI,CAAC8L,UAAL;UAChC;QACF,CALD,CAKE,OAAOnG,GAAP,EAAY;UACZoG,UAAU,CAACjP,CAAX,CAAa6I,GAAb;QACD,CAPD,SAOU;UACRoG,UAAU,CAAC3O,CAAX;QACD;MACF;;MAED,OAAO,IAAP;IACD;EAzDA,CAxFoB,EAkJpB;IACD6I,GAAG,EAAE,oBADJ;IAED3C,KAAK,EAAE,SAAS2I,kBAAT,GAA8B;MACnC,OAAOxE,YAAY,CAAC,KAAKE,QAAN,CAAZ,CAA4BzE,MAA5B,CAAmC,UAAUvD,CAAV,EAAa;QACrD,OAAOA,CAAC,CAAC6C,OAAF,CAAU1C,MAAM,CAACoM,aAAjB,MAAoC,CAA3C;MACD,CAFM,CAAP;IAGD;EANA,CAlJoB,EAyJpB;IACDjG,GAAG,EAAE,cADJ;IAED3C,KAAK,EAAE,SAAS6I,YAAT,CAAsBxK,MAAtB,EAA8BC,MAA9B,EAAsC;MAC3C,IAAID,MAAM,CAAC,CAAD,CAAN,KAAc,GAAd,IAAqBA,MAAM,CAACA,MAAM,CAACkB,MAAP,GAAgB,CAAjB,CAAN,KAA8B,GAAvD,EAA4D,MAAM,IAAIgB,KAAJ,CAAU,kCAAV,CAAN;;MAE5D,IAAIjC,MAAJ,EAAY;QACV,IAAI2F,IAAI,GAAG,KAAK7F,WAAL,CAAiBa,IAAjB,CAAsB,UAAUD,CAAV,EAAa;UAC5C,OAAOA,CAAC,CAACX,MAAF,KAAaA,MAApB;QACD,CAFU,CAAX;QAGA,IAAI4F,IAAJ,EAAUA,IAAI,CAAC3F,MAAL,GAAcA,MAAd,CAAV,KAAoC,KAAKF,WAAL,CAAiB2C,IAAjB,CAAsB;UACxD1C,MAAM,EAAEA,MADgD;UAExDC,MAAM,EAAEA;QAFgD,CAAtB;MAIrC,CARD,MAQO;QACL,KAAKF,WAAL,GAAmB,KAAKA,WAAL,CAAiBwB,MAAjB,CAAwB,UAAUZ,CAAV,EAAa;UACtD,OAAOA,CAAC,CAACX,MAAF,KAAaA,MAApB;QACD,CAFkB,CAAnB;MAGD;IACF;EAlBA,CAzJoB,EA4KpB;IACDsE,GAAG,EAAE,QADJ;IAED3C,KAAK,EAAE,SAAS8I,QAAT,CAAkBC,GAAlB,EAAuBC,QAAvB,EAAiC;MACtC,IAAIjG,KAAK,GAAG,IAAZ;;MAEA,IAAIkG,aAAa,GAAG,KAAKvK,OAAzB;MAAA,IACIxB,eAAe,GAAG+L,aAAa,CAAC/L,eADpC;MAAA,IAEIC,QAAQ,GAAG8L,aAAa,CAAC9L,QAF7B;MAAA,IAGIC,aAAa,GAAG6L,aAAa,CAAC7L,aAHlC;MAIA,IAAI8L,IAAI,GAAGhM,eAAe,KAAK,OAAO6L,GAAP,KAAe,QAAf,IAA2B,EAAE,KAAK1E,QAAL,YAAyB7I,MAA3B,CAAhC,CAA1B;MACA,IAAI2F,GAAG,GAAG;QACR3C,GAAG,EAAE,IADG;QAER2K,UAAU,EAAE,IAFJ;QAGRD,IAAI,EAAEA,IAHE;QAIR/L,QAAQ,EAAE+L,IAAI,IAAI,CAAC,CAAC/L,QAJZ;QAKRC,aAAa,EAAEA,aALP;QAMRoF,SAAS,EAAEtB,WANH,CAMe;;MANf,CAAV;MASA,IAAIkI,WAAW,GAAGzL,MAAM,CAAC2F,IAAP,CAAY,KAAK3C,OAAL,CAAayB,GAAzB,CAAlB;MACA,IAAIgH,WAAW,CAAC7J,MAAZ,GAAqB,CAAzB,EAA4B4B,GAAG,CAACR,OAAJ,GAAc,IAAIiB,GAAJ,CAAQwH,WAAW,CAAChH,GAAZ,CAAgB,UAAU/B,IAAV,EAAgB;QAChF,OAAO,CAAC0C,KAAK,CAACpC,OAAN,CAAcyB,GAAd,CAAkB/B,IAAlB,CAAD,EAA0B;UAC/B4B,KAAK,EAAE,EADwB;UAE/BoH,UAAU,EAAE,CAFmB;UAG/BC,KAAK,EAAE;QAHwB,CAA1B,CAAP;MAKD,CANiD,CAAR,CAAd;MAQ5B,IAAIvE,GAAG,GAAGzI,MAAM,CAAC,KAAK+H,QAAN,EAAgB0E,GAAhB,EAAqB5H,GAArB,CAAhB;;MAEA,IAAI,OAAO6H,QAAP,KAAoB,UAApB,IAAkC7H,GAAG,CAACR,OAA1C,EAAmD;QACjD,IAAI4I,UAAU,GAAGtQ,0BAA0B,CAACkI,GAAG,CAACR,OAAJ,CAAY6I,MAAZ,EAAD,CAA3C;QAAA,IACIC,MADJ;;QAGA,IAAI;UACF,KAAKF,UAAU,CAACtO,CAAX,EAAL,EAAqB,CAAC,CAACwO,MAAM,GAAGF,UAAU,CAACxO,CAAX,EAAV,EAA0BiH,IAAhD,GAAuD;YACrD,IAAI0H,YAAY,GAAGD,MAAM,CAACzJ,KAA1B;YAAA,IACIsJ,KAAK,GAAGI,YAAY,CAACJ,KADzB;YAAA,IAEIK,IAAI,GAAGD,YAAY,CAAC3E,GAFxB;YAGAiE,QAAQ,CAACW,IAAD,EAAOL,KAAP,CAAR;UACD;QACF,CAPD,CAOE,OAAOjH,GAAP,EAAY;UACZkH,UAAU,CAAC/P,CAAX,CAAa6I,GAAb;QACD,CATD,SASU;UACRkH,UAAU,CAACzP,CAAX;QACD;MACF;;MAED,OAAOiL,GAAP;IACD;EAjDA,CA5KoB,EA8NpB;IACDpC,GAAG,EAAE,UADJ;IAED3C,KAAK,EAAE,SAASsC,QAAT,GAAoB;MACzB,IAAI,KAAKwC,MAAL,CAAYvF,MAAZ,GAAqB,CAAzB,EAA4B,MAAM,IAAIgB,KAAJ,CAAU,4CAAV,CAAN;MAC5B,IAAIqJ,UAAU,GAAG,KAAKlL,OAAL,CAAa5B,MAA9B;;MAEA,IAAI,CAAC+M,MAAM,CAACC,SAAP,CAAiBF,UAAjB,CAAD,IAAiCA,UAAU,IAAI,CAAnD,EAAsD;QACpD,IAAI3O,CAAC,GAAG8O,IAAI,CAACvH,SAAL,CAAeoH,UAAf,CAAR;QACA,MAAM,IAAIrJ,KAAJ,CAAU,qDAAqDzB,MAArD,CAA4D7D,CAA5D,CAAV,CAAN;MACD;;MAED,KAAK4M,SAAL;MACA,IAAImC,KAAK,GAAG,EAAZ;MACA,IAAI1D,aAAa,GAAG,KAApB;;MAEA,IAAI,KAAK/I,OAAT,EAAkB;QAChB,IAAI0M,EAAE,GAAG,WAAT;;QAEA,IAAI,KAAK/L,MAAL,CAAYmC,IAAZ,KAAqB,UAAzB,EAAqC;UACnC,IAAI,KAAK9C,OAAL,KAAiB,KAArB,EAA4B0M,EAAE,GAAG,WAAL,CAA5B,KAAkD,IAAI,KAAK1M,OAAL,KAAiB,KAArB,EAA4B0M,EAAE,GAAG,WAAL;QAC/E;;QAEDD,KAAK,CAACjJ,IAAN,CAAWkJ,EAAX;QACA3D,aAAa,GAAG,IAAhB;MACD;;MAED,IAAI4D,QAAQ,GAAG,KAAKvB,kBAAL,EAAf;MACA,KAAKvK,WAAL,CAAiByF,OAAjB,CAAyB,UAAUnD,IAAV,EAAgB;QACvC,IAAIrC,MAAM,GAAGqC,IAAI,CAACrC,MAAlB;QAAA,IACIC,MAAM,GAAGoC,IAAI,CAACpC,MADlB;;QAGA,IAAI4L,QAAQ,CAACvE,IAAT,CAAc,UAAUtJ,CAAV,EAAa;UAC7B,OAAOA,CAAC,CAAC6C,OAAF,CAAUZ,MAAV,MAAsB,CAA7B;QACD,CAFG,CAAJ,EAEI;UACF0L,KAAK,CAACjJ,IAAN,CAAW,QAAQjC,MAAR,CAAeT,MAAf,EAAuB,GAAvB,EAA4BS,MAA5B,CAAmCR,MAAnC,CAAX;UACAgI,aAAa,GAAG,IAAhB;QACD;MACF,CAVD;MAWA,IAAIA,aAAa,IAAI,KAAKQ,mBAA1B,EAA+CkD,KAAK,CAACjJ,IAAN,CAAW,KAAX;;MAE/C,IAAI,KAAKqE,aAAT,EAAwB;QACtB,IAAIkB,aAAa,IAAI,CAAC,KAAKQ,mBAA3B,EAAgDkD,KAAK,CAACG,OAAN,CAAc,EAAd;QAChDH,KAAK,CAACG,OAAN,CAAc,KAAK/E,aAAL,CAAmBrG,OAAnB,CAA2B,KAA3B,EAAkC,GAAlC,CAAd;MACD;;MAED,IAAIoC,GAAG,GAAG;QACRR,OAAO,EAAEhD,MAAM,CAAC+E,MAAP,CAAc,IAAd,CADD;QAERlE,GAAG,EAAE,IAFG;QAGR1B,MAAM,EAAE,EAHA;QAIRqM,UAAU,EAAE,IAAIiB,MAAJ,CAAWR,UAAX,CAJJ;QAKRpH,SAAS,EAAEtB,WALH,CAKe;;MALf,CAAV;MAQA,IAAImJ,SAAS,GAAG,KAAhB;MACA,IAAIC,cAAc,GAAG,IAArB;;MAEA,IAAI,KAAKjG,QAAT,EAAmB;QACjB,IAAI,KAAKA,QAAL,YAAyBjJ,IAA7B,EAAmC;UACjC,IAAI,KAAKiJ,QAAL,CAAcM,WAAd,KAA8B2B,aAAa,IAAI,KAAKQ,mBAApD,CAAJ,EAA8EkD,KAAK,CAACjJ,IAAN,CAAW,EAAX;UAC9E,IAAI,KAAKsD,QAAL,CAAce,aAAlB,EAAiC4E,KAAK,CAACjJ,IAAN,CAAW,KAAKsD,QAAL,CAAce,aAAd,CAA4BrG,OAA5B,CAAoC,KAApC,EAA2C,GAA3C,CAAX,EAFA,CAE6D;;UAE9FoC,GAAG,CAACoJ,gBAAJ,GAAuB,CAAC,CAAC,KAAKvF,OAA9B;UACAsF,cAAc,GAAG,KAAKjG,QAAL,CAAcW,OAA/B;QACD;;QAED,IAAI3D,WAAW,GAAGiJ,cAAc,GAAG,IAAH,GAAU,YAAY;UACpD,OAAOD,SAAS,GAAG,IAAnB;QACD,CAFD;QAGA,IAAI5F,IAAI,GAAGvD,WAAW,CAAC,KAAKmD,QAAN,EAAgBlD,GAAhB,EAAqB,YAAY;UACrD,OAAOmJ,cAAc,GAAG,IAAxB;QACD,CAFqB,EAEnBjJ,WAFmB,CAAtB;QAGA2I,KAAK,CAACjJ,IAAN,CAAWxE,UAAU,CAACkI,IAAD,EAAO,EAAP,EAAW6F,cAAX,CAArB;MACD,CAhBD,MAgBO,IAAI,KAAKjG,QAAL,KAAkBK,SAAtB,EAAiC;QACtCsF,KAAK,CAACjJ,IAAN,CAAWG,WAAW,CAAC,KAAKmD,QAAN,EAAgBlD,GAAhB,CAAtB;MACD;;MAED,IAAI,KAAK6D,OAAT,EAAkB;QAChB,IAAI,CAAC,CAACqF,SAAD,IAAcC,cAAf,KAAkCN,KAAK,CAACA,KAAK,CAACzK,MAAN,GAAe,CAAhB,CAAL,KAA4B,EAAlE,EAAsEyK,KAAK,CAACjJ,IAAN,CAAW,EAAX;QACtEiJ,KAAK,CAACjJ,IAAN,CAAW,KAAKiE,OAAL,CAAajG,OAAb,CAAqB,KAArB,EAA4B,GAA5B,CAAX;MACD;;MAED,OAAOiL,KAAK,CAAC/I,IAAN,CAAW,IAAX,IAAmB,IAA1B;IACD;EAlFA,CA9NoB,CAAX,CAAZ;;EAmTA,OAAO4F,QAAP;AACD,CArU6B,EAA9B;;AAuUApN,eAAe,CAACmN,UAAD,EAAa,UAAb,EAAyB3I,eAAzB,CAAf;;AAEA,SAAS4D,UAAT,CAAoB7B,KAApB,EAA2B;EACzB,IAAIwK,WAAW,GAAGvH,SAAS,CAAC1D,MAAV,GAAmB,CAAnB,IAAwB0D,SAAS,CAAC,CAAD,CAAT,KAAiByB,SAAzC,GAAqDzB,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAAtF;EACA,IAAIxE,GAAG,GAAGwE,SAAS,CAAC1D,MAAV,GAAmB,CAAnB,GAAuB0D,SAAS,CAAC,CAAD,CAAhC,GAAsCyB,SAAhD;;EAEA,IAAIjG,GAAG,KAAKiG,SAAR,IAAqB,OAAO8F,WAAP,KAAuB,QAAhD,EAA0D;IACxD/L,GAAG,GAAG+L,WAAN;IACAA,WAAW,GAAG,IAAd;EACD;;EAED,IAAI9L,OAAO,GAAGf,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBgJ,UAAU,CAACS,QAAX,CAAoB1K,cAAc,CAACY,OAAnC,CAAlB,EAA+DZ,cAA/D,CAAd;EACA,IAAIuB,MAAM,GAAG,IAAI1B,MAAJ,CAAWkC,OAAX,CAAb;EACA,OAAOR,MAAM,CAAC2D,UAAP,CAAkB7B,KAAlB,EAAyBwK,WAAzB,EAAsC/L,GAAtC,CAAP;AACD;;AAED,IAAIoI,QAAQ,GAAG,aAAa,UAAU4D,aAAV,EAAyB;EACnDlQ,SAAS,CAACsM,QAAD,EAAW4D,aAAX,CAAT;;EAEA,IAAIC,MAAM,GAAGjQ,YAAY,CAACoM,QAAD,CAAzB;;EAEA,SAASA,QAAT,CAAkBnI,OAAlB,EAA2B;IACzBnF,eAAe,CAAC,IAAD,EAAOsN,QAAP,CAAf;;IAEA,OAAO6D,MAAM,CAACC,IAAP,CAAY,IAAZ,EAAkBhN,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBjB,cAAlB,EAAkC+B,OAAlC,CAAlB,CAAP;EACD;;EAED,OAAOmI,QAAP;AACD,CAZ2B,CAY1BD,UAZ0B,CAA5B;;AAcA,SAASgE,iBAAT,CAA2BC,GAA3B,EAAgCnM,OAAhC,EAAyC;EACvC,IAAIoM,MAAM,GAAG,EAAb;EACA,IAAI7G,IAAJ;;EAEA,IAAInC,SAAS,GAAG7I,0BAA0B,CAAC0B,OAAO,CAACkQ,GAAD,CAAR,CAA1C;EAAA,IACI9I,KADJ;;EAGA,IAAI;IACF,KAAKD,SAAS,CAAC7G,CAAV,EAAL,EAAoB,CAAC,CAAC8G,KAAK,GAAGD,SAAS,CAAC/G,CAAV,EAAT,EAAwBiH,IAA7C,GAAoD;MAClD,IAAI+I,MAAM,GAAGhJ,KAAK,CAAC/B,KAAnB;MACA,IAAIxB,GAAG,GAAG,IAAIqI,QAAJ,CAAanI,OAAb,CAAV;MACAF,GAAG,CAAC9D,KAAJ,CAAUqQ,MAAV,EAAkB9G,IAAlB;MACA6G,MAAM,CAAC/J,IAAP,CAAYvC,GAAZ;MACAyF,IAAI,GAAGzF,GAAP;IACD;EACF,CARD,CAQE,OAAO6D,GAAP,EAAY;IACZP,SAAS,CAACtI,CAAV,CAAY6I,GAAZ;EACD,CAVD,SAUU;IACRP,SAAS,CAAChI,CAAV;EACD;;EAED,OAAOgR,MAAP;AACD;;AAED,SAASE,aAAT,CAAuBH,GAAvB,EAA4BnM,OAA5B,EAAqC;EACnC,IAAIuM,GAAG,GAAGtQ,OAAO,CAACkQ,GAAD,CAAjB;EACA,IAAIrM,GAAG,GAAG,IAAIqI,QAAJ,CAAanI,OAAb,EAAsBhE,KAAtB,CAA4BuQ,GAAG,CAAC,CAAD,CAA/B,CAAV;;EAEA,IAAIA,GAAG,CAAC1L,MAAJ,GAAa,CAAjB,EAAoB;IAClB,IAAI2L,MAAM,GAAG,yEAAb;IACA1M,GAAG,CAACsG,MAAJ,CAAWqF,OAAX,CAAmB,IAAIlQ,iBAAJ,CAAsBgR,GAAG,CAAC,CAAD,CAAzB,EAA8BC,MAA9B,CAAnB;EACD;;EAED,OAAO1M,GAAP;AACD;;AAED,SAAS9D,KAAT,CAAemQ,GAAf,EAAoBnM,OAApB,EAA6B;EAC3B,IAAIF,GAAG,GAAGwM,aAAa,CAACH,GAAD,EAAMnM,OAAN,CAAvB;EACAF,GAAG,CAACyH,QAAJ,CAAapC,OAAb,CAAqB,UAAUsH,OAAV,EAAmB;IACtC,OAAOzO,IAAI,CAACyO,OAAD,CAAX;EACD,CAFD;EAGA,IAAI3M,GAAG,CAACsG,MAAJ,CAAWvF,MAAX,GAAoB,CAAxB,EAA2B,MAAMf,GAAG,CAACsG,MAAJ,CAAW,CAAX,CAAN;EAC3B,OAAOtG,GAAG,CAAClC,MAAJ,EAAP;AACD;;AAED,SAASkG,SAAT,CAAmBxC,KAAnB,EAA0BtB,OAA1B,EAAmC;EACjC,IAAIF,GAAG,GAAG,IAAIqI,QAAJ,CAAanI,OAAb,CAAV;EACAF,GAAG,CAAC6F,QAAJ,GAAerE,KAAf;EACA,OAAOoL,MAAM,CAAC5M,GAAD,CAAb;AACD;;AAED,IAAI6M,IAAI,GAAG;EACTxJ,UAAU,EAAEA,UADH;EAETlF,cAAc,EAAEA,cAFP;EAGTkK,QAAQ,EAAEA,QAHD;EAITnM,KAAK,EAAEA,KAJE;EAKTkQ,iBAAiB,EAAEA,iBALV;EAMTU,QAAQ,EAAE3Q,OAND;EAOTqQ,aAAa,EAAEA,aAPN;EAQTxN,aAAa,EAAEA,aARN;EASTgF,SAAS,EAAEA;AATF,CAAX;AAYA,SAAS6I,IAAT"},"metadata":{},"sourceType":"module"}