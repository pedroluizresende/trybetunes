{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _t = require(\"@babel/types\");\n\nvar _util = require(\"./util\");\n\nconst {\n  BOOLEAN_NUMBER_BINARY_OPERATORS,\n  createTypeAnnotationBasedOnTypeof,\n  numberTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations.push(...functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  return (0, _util.createUnionType)(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    return {\n      typeAnnotation: (0, _util.createUnionType)(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(binding, ifStatement, name);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_default","_t","require","_util","BOOLEAN_NUMBER_BINARY_OPERATORS","createTypeAnnotationBasedOnTypeof","numberTypeAnnotation","voidTypeAnnotation","node","isReferenced","binding","scope","getBinding","name","identifier","typeAnnotation","getTypeAnnotationBindingConstantViolations","path","types","functionConstantViolations","constantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","filter","indexOf","push","length","violation","getTypeAnnotation","createUnionType","functions","violations","slice","unshift","resolve","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","operator","right","get","left","target","isIdentifier","typeofPath","typePath","isUnaryExpression","isLiteral","typeValue","getParentConditionalPath","parentPath","isIfStatement","isConditionalExpression","key","isFunction","test","paths","i","isLogicalExpression","isBinaryExpression","type"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _t = require(\"@babel/types\");\n\nvar _util = require(\"./util\");\n\nconst {\n  BOOLEAN_NUMBER_BINARY_OPERATORS,\n  createTypeAnnotationBasedOnTypeof,\n  numberTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations.push(...functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  return (0, _util.createUnionType)(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    return {\n      typeAnnotation: (0, _util.createUnionType)(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(binding, ifStatement, name);\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}