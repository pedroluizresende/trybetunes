{"ast":null,"code":"import { j as _inherits, k as _createSuper, c as _classCallCheck, T as Type, b as _createClass, R as Range, N as Node, g as YAMLSemanticError, l as _get, m as _getPrototypeOf, Y as YAMLSyntaxError, C as Char, e as _defineProperty, P as PlainValue } from './PlainValue-b8036b75.js';\n\nvar BlankLine = /*#__PURE__*/function (_Node) {\n  _inherits(BlankLine, _Node);\n\n  var _super = _createSuper(BlankLine);\n\n  function BlankLine() {\n    _classCallCheck(this, BlankLine);\n\n    return _super.call(this, Type.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n\n  _createClass(BlankLine, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      // This is never called from anywhere, but if it were,\n      // this is the value it should return.\n      return true;\n    }\n    /**\n     * Parses a blank line from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first \\n character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      this.range = new Range(start, start + 1);\n      return start + 1;\n    }\n  }]);\n\n  return BlankLine;\n}(Node);\n\nvar CollectionItem = /*#__PURE__*/function (_Node) {\n  _inherits(CollectionItem, _Node);\n\n  var _super = _createSuper(CollectionItem);\n\n  function CollectionItem(type, props) {\n    var _this;\n\n    _classCallCheck(this, CollectionItem);\n\n    _this = _super.call(this, type, props);\n    _this.node = null;\n    return _this;\n  }\n\n  _createClass(CollectionItem, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return !!this.node && this.node.includesTrailingLines;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var atLineStart = context.atLineStart,\n          lineStart = context.lineStart;\n      if (!atLineStart && this.type === Type.SEQ_ITEM) this.error = new YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');\n      var indent = atLineStart ? start - lineStart : context.indent;\n      var offset = Node.endOfWhiteSpace(src, start + 1);\n      var ch = src[offset];\n      var inlineComment = ch === '#';\n      var comments = [];\n      var blankLine = null;\n\n      while (ch === '\\n' || ch === '#') {\n        if (ch === '#') {\n          var _end = Node.endOfLine(src, offset + 1);\n\n          comments.push(new Range(offset, _end));\n          offset = _end;\n        } else {\n          atLineStart = true;\n          lineStart = offset + 1;\n          var wsEnd = Node.endOfWhiteSpace(src, lineStart);\n\n          if (src[wsEnd] === '\\n' && comments.length === 0) {\n            blankLine = new BlankLine();\n            lineStart = blankLine.parse({\n              src: src\n            }, lineStart);\n          }\n\n          offset = Node.endOfIndent(src, lineStart);\n        }\n\n        ch = src[offset];\n      }\n\n      if (Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== Type.SEQ_ITEM)) {\n        this.node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: false,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n      } else if (ch && lineStart > start + 1) {\n        offset = lineStart - 1;\n      }\n\n      if (this.node) {\n        if (blankLine) {\n          // Only blank lines preceding non-empty nodes are captured. Note that\n          // this means that collection item range start indices do not always\n          // increase monotonically. -- eemeli/yaml#126\n          var items = context.parent.items || context.parent.contents;\n          if (items) items.push(blankLine);\n        }\n\n        if (comments.length) Array.prototype.push.apply(this.props, comments);\n        offset = this.node.range.end;\n      } else {\n        if (inlineComment) {\n          var c = comments[0];\n          this.props.push(c);\n          offset = c.end;\n        } else {\n          offset = Node.endOfLine(src, start + 1);\n        }\n      }\n\n      var end = this.node ? this.node.valueRange.end : offset;\n      this.valueRange = new Range(start, end);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(CollectionItem.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          node = this.node,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }]);\n\n  return CollectionItem;\n}(Node);\n\nvar Comment = /*#__PURE__*/function (_Node) {\n  _inherits(Comment, _Node);\n\n  var _super = _createSuper(Comment);\n\n  function Comment() {\n    _classCallCheck(this, Comment);\n\n    return _super.call(this, Type.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  _createClass(Comment, [{\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseComment(start);\n      this.range = new Range(start, offset);\n      return offset;\n    }\n  }]);\n\n  return Comment;\n}(Node);\n\nfunction grabCollectionEndComments(node) {\n  var cnode = node;\n\n  while (cnode instanceof CollectionItem) {\n    cnode = cnode.node;\n  }\n\n  if (!(cnode instanceof Collection)) return null;\n  var len = cnode.items.length;\n  var ci = -1;\n\n  for (var i = len - 1; i >= 0; --i) {\n    var n = cnode.items[i];\n\n    if (n.type === Type.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      var _n$context = n.context,\n          indent = _n$context.indent,\n          lineStart = _n$context.lineStart;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === Type.BLANK_LINE) ci = i;else break;\n  }\n\n  if (ci === -1) return null;\n  var ca = cnode.items.splice(ci, len - ci);\n  var prevEnd = ca[0].range.start;\n\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n\n  return ca;\n}\n\nvar Collection = /*#__PURE__*/function (_Node) {\n  _inherits(Collection, _Node);\n\n  var _super = _createSuper(Collection);\n\n  function Collection(firstItem) {\n    var _this;\n\n    _classCallCheck(this, Collection);\n\n    _this = _super.call(this, firstItem.type === Type.SEQ_ITEM ? Type.SEQ : Type.MAP);\n\n    for (var i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        _this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        var itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n\n    _this.items = [firstItem];\n    var ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(_this.items, ec);\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.items.length > 0;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src; // It's easier to recalculate lineStart here rather than tracking down the\n      // last context from which to read it -- eemeli/yaml#2\n\n      var lineStart = Node.startOfLine(src, start);\n      var firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n      // -- eemeli/yaml#17\n\n      firstItem.context.parent = this;\n      this.valueRange = Range.copy(firstItem.valueRange);\n      var indent = firstItem.range.start - firstItem.context.lineStart;\n      var offset = start;\n      offset = Node.normalizeOffset(src, offset);\n      var ch = src[offset];\n      var atLineStart = Node.endOfWhiteSpace(src, lineStart) === offset;\n      var prevIncludesTrailingLines = false;\n\n      while (ch) {\n        while (ch === '\\n' || ch === '#') {\n          if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n            var blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src: src\n            }, offset);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n\n            this.items.push(blankLine);\n            offset -= 1; // blankLine.parse() consumes terminal newline\n          } else if (ch === '#') {\n            if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n              return offset;\n            }\n\n            var comment = new Comment();\n            offset = comment.parse({\n              indent: indent,\n              lineStart: lineStart,\n              src: src\n            }, offset);\n            this.items.push(comment);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n          }\n\n          lineStart = offset + 1;\n          offset = Node.endOfIndent(src, lineStart);\n\n          if (Node.atBlank(src, offset)) {\n            var wsEnd = Node.endOfWhiteSpace(src, offset);\n            var next = src[wsEnd];\n\n            if (!next || next === '\\n' || next === '#') {\n              offset = wsEnd;\n            }\n          }\n\n          ch = src[offset];\n          atLineStart = true;\n        }\n\n        if (!ch) {\n          break;\n        }\n\n        if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n          if (offset < lineStart + indent) {\n            if (lineStart > start) offset = lineStart;\n            break;\n          } else if (!this.error) {\n            var msg = 'All collection items must start at the same column';\n            this.error = new YAMLSyntaxError(this, msg);\n          }\n        }\n\n        if (firstItem.type === Type.SEQ_ITEM) {\n          if (ch !== '-') {\n            if (lineStart > start) offset = lineStart;\n            break;\n          }\n        } else if (ch === '-' && !this.error) {\n          // map key may start with -, as long as it's followed by a non-whitespace char\n          var _next = src[offset + 1];\n\n          if (!_next || _next === '\\n' || _next === '\\t' || _next === ' ') {\n            var _msg = 'A collection cannot be both a mapping and a sequence';\n            this.error = new YAMLSyntaxError(this, _msg);\n          }\n        }\n\n        var node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: true,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n        if (!node) return offset; // at next document start\n\n        this.items.push(node);\n        this.valueRange.end = node.valueRange.end;\n        offset = Node.normalizeOffset(src, node.range.end);\n        ch = src[offset];\n        atLineStart = false;\n        prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n        // has advanced to check the current line's indentation level\n        // -- eemeli/yaml#10 & eemeli/yaml#38\n\n        if (ch) {\n          var ls = offset - 1;\n          var prev = src[ls];\n\n          while (prev === ' ' || prev === '\\t') {\n            prev = src[--ls];\n          }\n\n          if (prev === '\\n') {\n            lineStart = ls + 1;\n            atLineStart = true;\n          }\n        }\n\n        var ec = grabCollectionEndComments(node);\n        if (ec) Array.prototype.push.apply(this.items, ec);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(Collection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, items[0].range.start) + String(items[0]);\n\n      for (var i = 1; i < items.length; ++i) {\n        var item = items[i];\n        var _item$context = item.context,\n            atLineStart = _item$context.atLineStart,\n            indent = _item$context.indent;\n        if (atLineStart) for (var _i = 0; _i < indent; ++_i) {\n          str += ' ';\n        }\n        str += String(item);\n      }\n\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }], [{\n    key: \"nextContentHasIndent\",\n    value: function nextContentHasIndent(src, offset, indent) {\n      var lineStart = Node.endOfLine(src, offset) + 1;\n      offset = Node.endOfWhiteSpace(src, lineStart);\n      var ch = src[offset];\n      if (!ch) return false;\n      if (offset >= lineStart + indent) return true;\n      if (ch !== '#' && ch !== '\\n') return false;\n      return Collection.nextContentHasIndent(src, offset, indent);\n    }\n  }]);\n\n  return Collection;\n}(Node);\n\nvar Directive = /*#__PURE__*/function (_Node) {\n  _inherits(Directive, _Node);\n\n  var _super = _createSuper(Directive);\n\n  function Directive() {\n    var _this;\n\n    _classCallCheck(this, Directive);\n\n    _this = _super.call(this, Type.DIRECTIVE);\n    _this.name = null;\n    return _this;\n  }\n\n  _createClass(Directive, [{\n    key: \"parameters\",\n    get: function get() {\n      var raw = this.rawValue;\n      return raw ? raw.trim().split(/[ \\t]+/) : [];\n    }\n  }, {\n    key: \"parseName\",\n    value: function parseName(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') {\n        ch = src[offset += 1];\n      }\n\n      this.name = src.slice(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parseParameters\",\n    value: function parseParameters(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '#') {\n        ch = src[offset += 1];\n      }\n\n      this.valueRange = new Range(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseName(start + 1);\n      offset = this.parseParameters(offset);\n      offset = this.parseComment(offset);\n      this.range = new Range(start, offset);\n      return offset;\n    }\n  }]);\n\n  return Directive;\n}(Node);\n\nvar Document = /*#__PURE__*/function (_Node) {\n  _inherits(Document, _Node);\n\n  var _super = _createSuper(Document);\n\n  function Document() {\n    var _this;\n\n    _classCallCheck(this, Document);\n\n    _this = _super.call(this, Type.DOCUMENT);\n    _this.directives = null;\n    _this.contents = null;\n    _this.directivesEndMarker = null;\n    _this.documentEndMarker = null;\n    return _this;\n  }\n\n  _createClass(Document, [{\n    key: \"parseDirectives\",\n    value: function parseDirectives(start) {\n      var src = this.context.src;\n      this.directives = [];\n      var atLineStart = true;\n      var hasDirectives = false;\n      var offset = start;\n\n      while (!Node.atDocumentBoundary(src, offset, Char.DIRECTIVES_END)) {\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.directives.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.directives.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          case '%':\n            {\n              var directive = new Directive();\n              offset = directive.parse({\n                parent: this,\n                src: src\n              }, offset);\n              this.directives.push(directive);\n              hasDirectives = true;\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            if (hasDirectives) {\n              this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');\n            } else if (this.directives.length > 0) {\n              this.contents = this.directives;\n              this.directives = [];\n            }\n\n            return offset;\n        }\n      }\n\n      if (src[offset]) {\n        this.directivesEndMarker = new Range(offset, offset + 3);\n        return offset + 3;\n      }\n\n      if (hasDirectives) {\n        this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');\n      } else if (this.directives.length > 0) {\n        this.contents = this.directives;\n        this.directives = [];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"parseContents\",\n    value: function parseContents(start) {\n      var _this$context = this.context,\n          parseNode = _this$context.parseNode,\n          src = _this$context.src;\n      if (!this.contents) this.contents = [];\n      var lineStart = start;\n\n      while (src[lineStart - 1] === '-') {\n        lineStart -= 1;\n      }\n\n      var offset = Node.endOfWhiteSpace(src, start);\n      var atLineStart = lineStart === start;\n      this.valueRange = new Range(offset);\n\n      while (!Node.atDocumentBoundary(src, offset, Char.DOCUMENT_END)) {\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.contents.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            lineStart = offset;\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.contents.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            {\n              var iEnd = Node.endOfIndent(src, offset);\n              var context = {\n                atLineStart: atLineStart,\n                indent: -1,\n                inFlow: false,\n                inCollection: false,\n                lineStart: lineStart,\n                parent: this\n              };\n              var node = parseNode(context, iEnd);\n              if (!node) return this.valueRange.end = iEnd; // at next document start\n\n              this.contents.push(node);\n              offset = node.range.end;\n              atLineStart = false;\n              var ec = grabCollectionEndComments(node);\n              if (ec) Array.prototype.push.apply(this.contents, ec);\n            }\n        }\n\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n      }\n\n      this.valueRange.end = offset;\n\n      if (src[offset]) {\n        this.documentEndMarker = new Range(offset, offset + 3);\n        offset += 3;\n\n        if (src[offset]) {\n          offset = Node.endOfWhiteSpace(src, offset);\n\n          if (src[offset] === '#') {\n            var _comment = new Comment();\n\n            offset = _comment.parse({\n              src: src\n            }, offset);\n            this.contents.push(_comment);\n          }\n\n          switch (src[offset]) {\n            case '\\n':\n              offset += 1;\n              break;\n\n            case undefined:\n              break;\n\n            default:\n              this.error = new YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');\n          }\n        }\n      }\n\n      return offset;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      context.root = this;\n      this.context = context;\n      var src = context.src;\n      var offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n      offset = this.parseDirectives(offset);\n      offset = this.parseContents(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(Document.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.directives.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n      this.contents.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var contents = this.contents,\n          directives = this.directives,\n          value = this.value;\n      if (value != null) return value;\n      var str = directives.join('');\n\n      if (contents.length > 0) {\n        if (directives.length > 0 || contents[0].type === Type.COMMENT) str += '---\\n';\n        str += contents.join('');\n      }\n\n      if (str[str.length - 1] !== '\\n') str += '\\n';\n      return str;\n    }\n  }], [{\n    key: \"startCommentOrEndBlankLine\",\n    value: function startCommentOrEndBlankLine(src, start) {\n      var offset = Node.endOfWhiteSpace(src, start);\n      var ch = src[offset];\n      return ch === '#' || ch === '\\n' ? offset : start;\n    }\n  }]);\n\n  return Document;\n}(Node);\n\nvar Alias = /*#__PURE__*/function (_Node) {\n  _inherits(Alias, _Node);\n\n  var _super = _createSuper(Alias);\n\n  function Alias() {\n    _classCallCheck(this, Alias);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Alias, [{\n    key: \"parse\",\n    value:\n    /**\n     * Parses an *alias from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n    function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = Node.endOfIdentifier(src, start + 1);\n      this.valueRange = new Range(start + 1, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }]);\n\n  return Alias;\n}(Node);\n\nvar Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\n\nvar BlockValue = /*#__PURE__*/function (_Node) {\n  _inherits(BlockValue, _Node);\n\n  var _super = _createSuper(BlockValue);\n\n  function BlockValue(type, props) {\n    var _this;\n\n    _classCallCheck(this, BlockValue);\n\n    _this = _super.call(this, type, props);\n    _this.blockIndent = null;\n    _this.chomping = Chomp.CLIP;\n    _this.header = null;\n    return _this;\n  }\n\n  _createClass(BlockValue, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.chomping === Chomp.KEEP;\n    }\n  }, {\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (this.valueRange.isEmpty()) return '';\n      var lastNewLine = null;\n      var ch = src[end - 1];\n\n      while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n        end -= 1;\n\n        if (end <= start) {\n          if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n        }\n\n        if (ch === '\\n') lastNewLine = end;\n        ch = src[end - 1];\n      }\n\n      var keepStart = end + 1;\n\n      if (lastNewLine) {\n        if (this.chomping === Chomp.KEEP) {\n          keepStart = lastNewLine;\n          end = this.valueRange.end;\n        } else {\n          end = lastNewLine;\n        }\n      }\n\n      var bi = indent + this.blockIndent;\n      var folded = this.type === Type.BLOCK_FOLDED;\n      var atStart = true;\n      var str = '';\n      var sep = '';\n      var prevMoreIndented = false;\n\n      for (var i = start; i < end; ++i) {\n        for (var j = 0; j < bi; ++j) {\n          if (src[i] !== ' ') break;\n          i += 1;\n        }\n\n        var _ch = src[i];\n\n        if (_ch === '\\n') {\n          if (sep === '\\n') str += '\\n';else sep = '\\n';\n        } else {\n          var lineEnd = Node.endOfLine(src, i);\n          var line = src.slice(i, lineEnd);\n          i = lineEnd;\n\n          if (folded && (_ch === ' ' || _ch === '\\t') && i < keepStart) {\n            if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n            str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n            sep = lineEnd < end && src[lineEnd] || '';\n            prevMoreIndented = true;\n          } else {\n            str += sep + line;\n            sep = folded && i < keepStart ? ' ' : '\\n';\n            prevMoreIndented = false;\n          }\n\n          if (atStart && line !== '') atStart = false;\n        }\n      }\n\n      return this.chomping === Chomp.STRIP ? str : str + '\\n';\n    }\n  }, {\n    key: \"parseBlockHeader\",\n    value: function parseBlockHeader(start) {\n      var src = this.context.src;\n      var offset = start + 1;\n      var bi = '';\n\n      while (true) {\n        var ch = src[offset];\n\n        switch (ch) {\n          case '-':\n            this.chomping = Chomp.STRIP;\n            break;\n\n          case '+':\n            this.chomping = Chomp.KEEP;\n            break;\n\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            bi += ch;\n            break;\n\n          default:\n            this.blockIndent = Number(bi) || null;\n            this.header = new Range(start, offset);\n            return offset;\n        }\n\n        offset += 1;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context2 = this.context,\n          indent = _this$context2.indent,\n          src = _this$context2.src;\n      var explicit = !!this.blockIndent;\n      var offset = start;\n      var valueEnd = start;\n      var minBlockIndent = 1;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        offset += 1;\n        if (Node.atDocumentBoundary(src, offset)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n        if (end === null) break;\n        var _ch2 = src[end];\n        var lineIndent = end - (offset + indent);\n\n        if (!this.blockIndent) {\n          // no explicit block indent, none yet detected\n          if (src[end] !== '\\n') {\n            // first line with non-whitespace content\n            if (lineIndent < minBlockIndent) {\n              var msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n              this.error = new YAMLSemanticError(this, msg);\n            }\n\n            this.blockIndent = lineIndent;\n          } else if (lineIndent > minBlockIndent) {\n            // empty line with more whitespace\n            minBlockIndent = lineIndent;\n          }\n        } else if (_ch2 && _ch2 !== '\\n' && lineIndent < this.blockIndent) {\n          if (src[end] === '#') break;\n\n          if (!this.error) {\n            var _src = explicit ? 'explicit indentation indicator' : 'first line';\n\n            var _msg = \"Block scalars must not be less indented than their \".concat(_src);\n\n            this.error = new YAMLSemanticError(this, _msg);\n          }\n        }\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          offset = valueEnd = Node.endOfLine(src, end);\n        }\n      }\n\n      if (this.chomping !== Chomp.KEEP) {\n        offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n      }\n\n      this.valueRange = new Range(start + 1, offset);\n      return offset;\n    }\n    /**\n     * Parses a block value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * BS\n     * block\n     * lines\n     *\n     * BS #comment\n     * block\n     * lines\n     * ```\n     * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n     * are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this block\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = this.parseBlockHeader(start);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      offset = this.parseBlockValue(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(BlockValue.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.header ? this.header.setOrigRange(cr, offset) : offset;\n    }\n  }]);\n\n  return BlockValue;\n}(Node);\n\nvar FlowCollection = /*#__PURE__*/function (_Node) {\n  _inherits(FlowCollection, _Node);\n\n  var _super = _createSuper(FlowCollection);\n\n  function FlowCollection(type, props) {\n    var _this;\n\n    _classCallCheck(this, FlowCollection);\n\n    _this = _super.call(this, type, props);\n    _this.items = null;\n    return _this;\n  }\n\n  _createClass(FlowCollection, [{\n    key: \"prevNodeIsJsonLike\",\n    value: function prevNodeIsJsonLike() {\n      var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;\n      var node = this.items[idx - 1];\n      return !!node && (node.jsonLike || node.type === Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var indent = context.indent,\n          lineStart = context.lineStart;\n      var char = src[start]; // { or [\n\n      this.items = [{\n        char: char,\n        offset: start\n      }];\n      var offset = Node.endOfWhiteSpace(src, start + 1);\n      char = src[offset];\n\n      while (char && char !== ']' && char !== '}') {\n        switch (char) {\n          case '\\n':\n            {\n              lineStart = offset + 1;\n              var wsEnd = Node.endOfWhiteSpace(src, lineStart);\n\n              if (src[wsEnd] === '\\n') {\n                var blankLine = new BlankLine();\n                lineStart = blankLine.parse({\n                  src: src\n                }, lineStart);\n                this.items.push(blankLine);\n              }\n\n              offset = Node.endOfIndent(src, lineStart);\n\n              if (offset <= lineStart + indent) {\n                char = src[offset];\n\n                if (offset < lineStart + indent || char !== ']' && char !== '}') {\n                  var msg = 'Insufficient indentation in flow collection';\n                  this.error = new YAMLSemanticError(this, msg);\n                }\n              }\n            }\n            break;\n\n          case ',':\n            {\n              this.items.push({\n                char: char,\n                offset: offset\n              });\n              offset += 1;\n            }\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.items.push(comment);\n            }\n            break;\n\n          case '?':\n          case ':':\n            {\n              var next = src[offset + 1];\n\n              if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace\n              char === ':' && this.prevNodeIsJsonLike()) {\n                this.items.push({\n                  char: char,\n                  offset: offset\n                });\n                offset += 1;\n                break;\n              }\n            }\n          // fallthrough\n\n          default:\n            {\n              var node = parseNode({\n                atLineStart: false,\n                inCollection: false,\n                inFlow: true,\n                indent: -1,\n                lineStart: lineStart,\n                parent: this\n              }, offset);\n\n              if (!node) {\n                // at next document start\n                this.valueRange = new Range(start, offset);\n                return offset;\n              }\n\n              this.items.push(node);\n              offset = Node.normalizeOffset(src, node.range.end);\n            }\n        }\n\n        offset = Node.endOfWhiteSpace(src, offset);\n        char = src[offset];\n      }\n\n      this.valueRange = new Range(start, offset + 1);\n\n      if (char) {\n        this.items.push({\n          char: char,\n          offset: offset\n        });\n        offset = Node.endOfWhiteSpace(src, offset + 1);\n        offset = this.parseComment(offset);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(FlowCollection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        if (node instanceof Node) {\n          offset = node.setOrigRanges(cr, offset);\n        } else if (cr.length === 0) {\n          node.origOffset = node.offset;\n        } else {\n          var i = offset;\n\n          while (i < cr.length) {\n            if (cr[i] > node.offset) break;else ++i;\n          }\n\n          node.origOffset = node.offset + i;\n          offset = i;\n        }\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var nodes = items.filter(function (item) {\n        return item instanceof Node;\n      });\n      var str = '';\n      var prevEnd = range.start;\n      nodes.forEach(function (node) {\n        var prefix = src.slice(prevEnd, node.range.start);\n        prevEnd = node.range.end;\n        str += prefix + String(node);\n\n        if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n          // Comment range does not include the terminal newline, but its\n          // stringified value does. Without this fix, newlines at comment ends\n          // get duplicated.\n          prevEnd += 1;\n        }\n      });\n      str += src.slice(prevEnd, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }]);\n\n  return FlowCollection;\n}(Node);\n\nvar QuoteDouble = /*#__PURE__*/function (_Node) {\n  _inherits(QuoteDouble, _Node);\n\n  var _super = _createSuper(QuoteDouble);\n\n  function QuoteDouble() {\n    _classCallCheck(this, QuoteDouble);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(QuoteDouble, [{\n    key: \"strValue\",\n    get:\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== '\"') errors.push(new YAMLSyntaxError(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n      // escaped backslashes; also, this should be faster.\n\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = Node.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n        } else if (ch === '\\\\') {\n          i += 1;\n\n          switch (src[i]) {\n            case '0':\n              str += '\\0';\n              break;\n            // null character\n\n            case 'a':\n              str += '\\x07';\n              break;\n            // bell character\n\n            case 'b':\n              str += '\\b';\n              break;\n            // backspace\n\n            case 'e':\n              str += '\\x1b';\n              break;\n            // escape character\n\n            case 'f':\n              str += '\\f';\n              break;\n            // form feed\n\n            case 'n':\n              str += '\\n';\n              break;\n            // line feed\n\n            case 'r':\n              str += '\\r';\n              break;\n            // carriage return\n\n            case 't':\n              str += '\\t';\n              break;\n            // horizontal tab\n\n            case 'v':\n              str += '\\v';\n              break;\n            // vertical tab\n\n            case 'N':\n              str += \"\\x85\";\n              break;\n            // Unicode next line\n\n            case '_':\n              str += \"\\xA0\";\n              break;\n            // Unicode non-breaking space\n\n            case 'L':\n              str += \"\\u2028\";\n              break;\n            // Unicode line separator\n\n            case 'P':\n              str += \"\\u2029\";\n              break;\n            // Unicode paragraph separator\n\n            case ' ':\n              str += ' ';\n              break;\n\n            case '\"':\n              str += '\"';\n              break;\n\n            case '/':\n              str += '/';\n              break;\n\n            case '\\\\':\n              str += '\\\\';\n              break;\n\n            case '\\t':\n              str += '\\t';\n              break;\n\n            case 'x':\n              str += this.parseCharCode(i + 1, 2, errors);\n              i += 2;\n              break;\n\n            case 'u':\n              str += this.parseCharCode(i + 1, 4, errors);\n              i += 4;\n              break;\n\n            case 'U':\n              str += this.parseCharCode(i + 1, 8, errors);\n              i += 8;\n              break;\n\n            case '\\n':\n              // skip escaped newlines, but still trim the following line\n              while (src[i + 1] === ' ' || src[i + 1] === '\\t') {\n                i += 1;\n              }\n\n              break;\n\n            default:\n              errors.push(new YAMLSyntaxError(this, \"Invalid escape sequence \".concat(src.substr(i - 1, 2))));\n              str += '\\\\' + src[i];\n          }\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n  }, {\n    key: \"parseCharCode\",\n    value: function parseCharCode(offset, length, errors) {\n      var src = this.context.src;\n      var cc = src.substr(offset, length);\n      var ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n      var code = ok ? parseInt(cc, 16) : NaN;\n\n      if (isNaN(code)) {\n        errors.push(new YAMLSyntaxError(this, \"Invalid escape sequence \".concat(src.substr(offset - 2, length + 2))));\n        return src.substr(offset - 2, length + 2);\n      }\n\n      return String.fromCodePoint(code);\n    }\n    /**\n     * Parses a \"double quoted\" value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteDouble.endOfQuote(src, start + 1);\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\"') {\n        offset += ch === '\\\\' ? 2 : 1;\n        ch = src[offset];\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteDouble;\n}(Node);\n\nvar QuoteSingle = /*#__PURE__*/function (_Node) {\n  _inherits(QuoteSingle, _Node);\n\n  var _super = _createSuper(QuoteSingle);\n\n  function QuoteSingle() {\n    _classCallCheck(this, QuoteSingle);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(QuoteSingle, [{\n    key: \"strValue\",\n    get:\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== \"'\") errors.push(new YAMLSyntaxError(this, \"Missing closing 'quote\"));\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = Node.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n        } else if (ch === \"'\") {\n          str += ch;\n          i += 1;\n          if (src[i] !== \"'\") errors.push(new YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n    /**\n     * Parses a 'single quoted' value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteSingle.endOfQuote(src, start + 1);\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch) {\n        if (ch === \"'\") {\n          if (src[offset + 1] !== \"'\") break;\n          ch = src[offset += 2];\n        } else {\n          ch = src[offset += 1];\n        }\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteSingle;\n}(Node);\n\nfunction createNewNode(type, props) {\n  switch (type) {\n    case Type.ALIAS:\n      return new Alias(type, props);\n\n    case Type.BLOCK_FOLDED:\n    case Type.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n\n    case Type.FLOW_MAP:\n    case Type.FLOW_SEQ:\n      return new FlowCollection(type, props);\n\n    case Type.MAP_KEY:\n    case Type.MAP_VALUE:\n    case Type.SEQ_ITEM:\n      return new CollectionItem(type, props);\n\n    case Type.COMMENT:\n    case Type.PLAIN:\n      return new PlainValue(type, props);\n\n    case Type.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n\n    case Type.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\n\nvar ParseContext = /*#__PURE__*/function () {\n  function ParseContext() {\n    var _this = this;\n\n    var orig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        atLineStart = _ref.atLineStart,\n        inCollection = _ref.inCollection,\n        inFlow = _ref.inFlow,\n        indent = _ref.indent,\n        lineStart = _ref.lineStart,\n        parent = _ref.parent;\n\n    _classCallCheck(this, ParseContext);\n\n    _defineProperty(this, \"parseNode\", function (overlay, start) {\n      if (Node.atDocumentBoundary(_this.src, start)) return null;\n      var context = new ParseContext(_this, overlay);\n\n      var _context$parseProps = context.parseProps(start),\n          props = _context$parseProps.props,\n          type = _context$parseProps.type,\n          valueStart = _context$parseProps.valueStart;\n\n      var node = createNewNode(type, props);\n      var offset = node.parse(context, valueStart);\n      node.range = new Range(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(\"Node#parse consumed no characters\");\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === Type.DOCUMENT) {\n          node.error = new YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n\n        var collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new Range(start, offset);\n        return collection;\n      }\n\n      return node;\n    });\n\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n\n  _createClass(ParseContext, [{\n    key: \"nodeStartsCollection\",\n    value: function nodeStartsCollection(node) {\n      var inCollection = this.inCollection,\n          inFlow = this.inFlow,\n          src = this.src;\n      if (inCollection || inFlow) return false;\n      if (node instanceof CollectionItem) return true; // check for implicit key\n\n      var offset = node.range.end;\n      if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n      offset = Node.endOfWhiteSpace(src, offset);\n      return src[offset] === ':';\n    } // Anchor and tag are before type, which determines the node implementation\n    // class; hence this intermediate step.\n\n  }, {\n    key: \"parseProps\",\n    value: function parseProps(offset) {\n      var inFlow = this.inFlow,\n          parent = this.parent,\n          src = this.src;\n      var props = [];\n      var lineHasProps = false;\n      offset = this.atLineStart ? Node.endOfIndent(src, offset) : Node.endOfWhiteSpace(src, offset);\n      var ch = src[offset];\n\n      while (ch === Char.ANCHOR || ch === Char.COMMENT || ch === Char.TAG || ch === '\\n') {\n        if (ch === '\\n') {\n          var inEnd = offset;\n          var lineStart = void 0;\n\n          do {\n            lineStart = inEnd + 1;\n            inEnd = Node.endOfIndent(src, lineStart);\n          } while (src[inEnd] === '\\n');\n\n          var indentDiff = inEnd - (lineStart + this.indent);\n          var noIndicatorAsIndent = parent.type === Type.SEQ_ITEM && parent.context.atLineStart;\n          if (src[inEnd] !== '#' && !Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n          this.atLineStart = true;\n          this.lineStart = lineStart;\n          lineHasProps = false;\n          offset = inEnd;\n        } else if (ch === Char.COMMENT) {\n          var end = Node.endOfLine(src, offset + 1);\n          props.push(new Range(offset, end));\n          offset = end;\n        } else {\n          var _end = Node.endOfIdentifier(src, offset + 1);\n\n          if (ch === Char.TAG && src[_end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, _end + 13))) {\n            // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n            // than an empty but 'foo.bar' private-tagged node in a flow collection\n            // followed without whitespace by a plain string starting with a year\n            // or date divided by something.\n            _end = Node.endOfIdentifier(src, _end + 5);\n          }\n\n          props.push(new Range(offset, _end));\n          lineHasProps = true;\n          offset = Node.endOfWhiteSpace(src, _end);\n        }\n\n        ch = src[offset];\n      } // '- &a : b' has an anchor on an empty node\n\n\n      if (lineHasProps && ch === ':' && Node.atBlank(src, offset + 1, true)) offset -= 1;\n      var type = ParseContext.parseType(src, offset, inFlow);\n      return {\n        props: props,\n        type: type,\n        valueStart: offset\n      };\n    }\n    /**\n     * Parses a node from the source\n     * @param {ParseContext} overlay\n     * @param {number} start - Index of first non-whitespace character for the node\n     * @returns {?Node} - null if at a document boundary\n     */\n\n  }], [{\n    key: \"parseType\",\n    value: function parseType(src, offset, inFlow) {\n      switch (src[offset]) {\n        case '*':\n          return Type.ALIAS;\n\n        case '>':\n          return Type.BLOCK_FOLDED;\n\n        case '|':\n          return Type.BLOCK_LITERAL;\n\n        case '{':\n          return Type.FLOW_MAP;\n\n        case '[':\n          return Type.FLOW_SEQ;\n\n        case '?':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_KEY : Type.PLAIN;\n\n        case ':':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_VALUE : Type.PLAIN;\n\n        case '-':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.SEQ_ITEM : Type.PLAIN;\n\n        case '\"':\n          return Type.QUOTE_DOUBLE;\n\n        case \"'\":\n          return Type.QUOTE_SINGLE;\n\n        default:\n          return Type.PLAIN;\n      }\n    }\n  }]);\n\n  return ParseContext;\n}(); // Published as 'yaml/parse-cst'\n\n\nfunction parse(src) {\n  var cr = [];\n\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, function (match, offset) {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n\n  var documents = [];\n  var offset = 0;\n\n  do {\n    var doc = new Document();\n    var context = new ParseContext({\n      src: src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n\n  documents.setOrigRanges = function () {\n    if (cr.length === 0) return false;\n\n    for (var i = 1; i < cr.length; ++i) {\n      cr[i] -= i;\n    }\n\n    var crOffset = 0;\n\n    for (var _i = 0; _i < documents.length; ++_i) {\n      crOffset = documents[_i].setOrigRanges(cr, crOffset);\n    }\n\n    cr.splice(0, cr.length);\n    return true;\n  };\n\n  documents.toString = function () {\n    return documents.join('...\\n');\n  };\n\n  return documents;\n}\n\nexport { parse };","map":{"version":3,"names":["j","_inherits","k","_createSuper","c","_classCallCheck","T","Type","b","_createClass","R","Range","N","Node","g","YAMLSemanticError","l","_get","m","_getPrototypeOf","Y","YAMLSyntaxError","C","Char","e","_defineProperty","P","PlainValue","BlankLine","_Node","_super","call","BLANK_LINE","key","get","value","parse","context","start","range","CollectionItem","type","props","_this","node","includesTrailingLines","parseNode","src","atLineStart","lineStart","SEQ_ITEM","error","indent","offset","endOfWhiteSpace","ch","inlineComment","comments","blankLine","_end","endOfLine","push","wsEnd","length","endOfIndent","nextNodeIsIndented","inCollection","parent","items","contents","Array","prototype","apply","end","valueRange","setOrigRanges","cr","toString","str","slice","String","addStringTerminator","Comment","COMMENT","parseComment","grabCollectionEndComments","cnode","Collection","len","ci","i","n","_n$context","ca","splice","prevEnd","firstItem","SEQ","MAP","itemRange","ec","startOfLine","copy","normalizeOffset","prevIncludesTrailingLines","nextContentHasIndent","comment","atBlank","next","msg","_next","_msg","ls","prev","forEach","item","_item$context","_i","Directive","DIRECTIVE","name","raw","rawValue","trim","split","parseName","parseParameters","Document","DOCUMENT","directives","directivesEndMarker","documentEndMarker","parseDirectives","hasDirectives","atDocumentBoundary","DIRECTIVES_END","startCommentOrEndBlankLine","directive","parseContents","_this$context","DOCUMENT_END","iEnd","inFlow","_comment","undefined","root","charCodeAt","setOrigRange","join","Alias","arguments","endOfIdentifier","Chomp","CLIP","KEEP","STRIP","BlockValue","blockIndent","chomping","header","_this$valueRange","isEmpty","lastNewLine","keepStart","bi","folded","BLOCK_FOLDED","atStart","sep","prevMoreIndented","_ch","lineEnd","line","parseBlockHeader","Number","parseBlockValue","_this$context2","explicit","valueEnd","minBlockIndent","endOfBlockIndent","_ch2","lineIndent","_src","concat","FlowCollection","prevNodeIsJsonLike","idx","jsonLike","char","origOffset","nodes","filter","prefix","QuoteDouble","errors","_Node$foldNewline","foldNewline","fold","parseCharCode","substr","wsStart","cc","ok","test","code","parseInt","NaN","isNaN","fromCodePoint","endOfQuote","QuoteSingle","createNewNode","ALIAS","BLOCK_LITERAL","FLOW_MAP","FLOW_SEQ","MAP_KEY","MAP_VALUE","PLAIN","QUOTE_DOUBLE","QUOTE_SINGLE","ParseContext","orig","_ref","overlay","_context$parseProps","parseProps","valueStart","Error","parseEnd","source","nodeStartsCollection","collection","lineHasProps","ANCHOR","TAG","inEnd","indentDiff","noIndicatorAsIndent","parseType","indexOf","replace","match","documents","doc","crOffset"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/yaml/browser/dist/parse-cst.js"],"sourcesContent":["import { j as _inherits, k as _createSuper, c as _classCallCheck, T as Type, b as _createClass, R as Range, N as Node, g as YAMLSemanticError, l as _get, m as _getPrototypeOf, Y as YAMLSyntaxError, C as Char, e as _defineProperty, P as PlainValue } from './PlainValue-b8036b75.js';\n\nvar BlankLine = /*#__PURE__*/function (_Node) {\n  _inherits(BlankLine, _Node);\n\n  var _super = _createSuper(BlankLine);\n\n  function BlankLine() {\n    _classCallCheck(this, BlankLine);\n\n    return _super.call(this, Type.BLANK_LINE);\n  }\n  /* istanbul ignore next */\n\n\n  _createClass(BlankLine, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      // This is never called from anywhere, but if it were,\n      // this is the value it should return.\n      return true;\n    }\n    /**\n     * Parses a blank line from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first \\n character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      this.range = new Range(start, start + 1);\n      return start + 1;\n    }\n  }]);\n\n  return BlankLine;\n}(Node);\n\nvar CollectionItem = /*#__PURE__*/function (_Node) {\n  _inherits(CollectionItem, _Node);\n\n  var _super = _createSuper(CollectionItem);\n\n  function CollectionItem(type, props) {\n    var _this;\n\n    _classCallCheck(this, CollectionItem);\n\n    _this = _super.call(this, type, props);\n    _this.node = null;\n    return _this;\n  }\n\n  _createClass(CollectionItem, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return !!this.node && this.node.includesTrailingLines;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var atLineStart = context.atLineStart,\n          lineStart = context.lineStart;\n      if (!atLineStart && this.type === Type.SEQ_ITEM) this.error = new YAMLSemanticError(this, 'Sequence items must not have preceding content on the same line');\n      var indent = atLineStart ? start - lineStart : context.indent;\n      var offset = Node.endOfWhiteSpace(src, start + 1);\n      var ch = src[offset];\n      var inlineComment = ch === '#';\n      var comments = [];\n      var blankLine = null;\n\n      while (ch === '\\n' || ch === '#') {\n        if (ch === '#') {\n          var _end = Node.endOfLine(src, offset + 1);\n\n          comments.push(new Range(offset, _end));\n          offset = _end;\n        } else {\n          atLineStart = true;\n          lineStart = offset + 1;\n          var wsEnd = Node.endOfWhiteSpace(src, lineStart);\n\n          if (src[wsEnd] === '\\n' && comments.length === 0) {\n            blankLine = new BlankLine();\n            lineStart = blankLine.parse({\n              src: src\n            }, lineStart);\n          }\n\n          offset = Node.endOfIndent(src, lineStart);\n        }\n\n        ch = src[offset];\n      }\n\n      if (Node.nextNodeIsIndented(ch, offset - (lineStart + indent), this.type !== Type.SEQ_ITEM)) {\n        this.node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: false,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n      } else if (ch && lineStart > start + 1) {\n        offset = lineStart - 1;\n      }\n\n      if (this.node) {\n        if (blankLine) {\n          // Only blank lines preceding non-empty nodes are captured. Note that\n          // this means that collection item range start indices do not always\n          // increase monotonically. -- eemeli/yaml#126\n          var items = context.parent.items || context.parent.contents;\n          if (items) items.push(blankLine);\n        }\n\n        if (comments.length) Array.prototype.push.apply(this.props, comments);\n        offset = this.node.range.end;\n      } else {\n        if (inlineComment) {\n          var c = comments[0];\n          this.props.push(c);\n          offset = c.end;\n        } else {\n          offset = Node.endOfLine(src, start + 1);\n        }\n      }\n\n      var end = this.node ? this.node.valueRange.end : offset;\n      this.valueRange = new Range(start, end);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(CollectionItem.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.node ? this.node.setOrigRanges(cr, offset) : offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          node = this.node,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = node ? src.slice(range.start, node.range.start) + String(node) : src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }]);\n\n  return CollectionItem;\n}(Node);\n\nvar Comment = /*#__PURE__*/function (_Node) {\n  _inherits(Comment, _Node);\n\n  var _super = _createSuper(Comment);\n\n  function Comment() {\n    _classCallCheck(this, Comment);\n\n    return _super.call(this, Type.COMMENT);\n  }\n  /**\n   * Parses a comment line from the source\n   *\n   * @param {ParseContext} context\n   * @param {number} start - Index of first character\n   * @returns {number} - Index of the character after this scalar\n   */\n\n\n  _createClass(Comment, [{\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseComment(start);\n      this.range = new Range(start, offset);\n      return offset;\n    }\n  }]);\n\n  return Comment;\n}(Node);\n\nfunction grabCollectionEndComments(node) {\n  var cnode = node;\n\n  while (cnode instanceof CollectionItem) {\n    cnode = cnode.node;\n  }\n\n  if (!(cnode instanceof Collection)) return null;\n  var len = cnode.items.length;\n  var ci = -1;\n\n  for (var i = len - 1; i >= 0; --i) {\n    var n = cnode.items[i];\n\n    if (n.type === Type.COMMENT) {\n      // Keep sufficiently indented comments with preceding node\n      var _n$context = n.context,\n          indent = _n$context.indent,\n          lineStart = _n$context.lineStart;\n      if (indent > 0 && n.range.start >= lineStart + indent) break;\n      ci = i;\n    } else if (n.type === Type.BLANK_LINE) ci = i;else break;\n  }\n\n  if (ci === -1) return null;\n  var ca = cnode.items.splice(ci, len - ci);\n  var prevEnd = ca[0].range.start;\n\n  while (true) {\n    cnode.range.end = prevEnd;\n    if (cnode.valueRange && cnode.valueRange.end > prevEnd) cnode.valueRange.end = prevEnd;\n    if (cnode === node) break;\n    cnode = cnode.context.parent;\n  }\n\n  return ca;\n}\nvar Collection = /*#__PURE__*/function (_Node) {\n  _inherits(Collection, _Node);\n\n  var _super = _createSuper(Collection);\n\n  function Collection(firstItem) {\n    var _this;\n\n    _classCallCheck(this, Collection);\n\n    _this = _super.call(this, firstItem.type === Type.SEQ_ITEM ? Type.SEQ : Type.MAP);\n\n    for (var i = firstItem.props.length - 1; i >= 0; --i) {\n      if (firstItem.props[i].start < firstItem.context.lineStart) {\n        // props on previous line are assumed by the collection\n        _this.props = firstItem.props.slice(0, i + 1);\n        firstItem.props = firstItem.props.slice(i + 1);\n        var itemRange = firstItem.props[0] || firstItem.valueRange;\n        firstItem.range.start = itemRange.start;\n        break;\n      }\n    }\n\n    _this.items = [firstItem];\n    var ec = grabCollectionEndComments(firstItem);\n    if (ec) Array.prototype.push.apply(_this.items, ec);\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.items.length > 0;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src; // It's easier to recalculate lineStart here rather than tracking down the\n      // last context from which to read it -- eemeli/yaml#2\n\n      var lineStart = Node.startOfLine(src, start);\n      var firstItem = this.items[0]; // First-item context needs to be correct for later comment handling\n      // -- eemeli/yaml#17\n\n      firstItem.context.parent = this;\n      this.valueRange = Range.copy(firstItem.valueRange);\n      var indent = firstItem.range.start - firstItem.context.lineStart;\n      var offset = start;\n      offset = Node.normalizeOffset(src, offset);\n      var ch = src[offset];\n      var atLineStart = Node.endOfWhiteSpace(src, lineStart) === offset;\n      var prevIncludesTrailingLines = false;\n\n      while (ch) {\n        while (ch === '\\n' || ch === '#') {\n          if (atLineStart && ch === '\\n' && !prevIncludesTrailingLines) {\n            var blankLine = new BlankLine();\n            offset = blankLine.parse({\n              src: src\n            }, offset);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n\n            this.items.push(blankLine);\n            offset -= 1; // blankLine.parse() consumes terminal newline\n          } else if (ch === '#') {\n            if (offset < lineStart + indent && !Collection.nextContentHasIndent(src, offset, indent)) {\n              return offset;\n            }\n\n            var comment = new Comment();\n            offset = comment.parse({\n              indent: indent,\n              lineStart: lineStart,\n              src: src\n            }, offset);\n            this.items.push(comment);\n            this.valueRange.end = offset;\n\n            if (offset >= src.length) {\n              ch = null;\n              break;\n            }\n          }\n\n          lineStart = offset + 1;\n          offset = Node.endOfIndent(src, lineStart);\n\n          if (Node.atBlank(src, offset)) {\n            var wsEnd = Node.endOfWhiteSpace(src, offset);\n            var next = src[wsEnd];\n\n            if (!next || next === '\\n' || next === '#') {\n              offset = wsEnd;\n            }\n          }\n\n          ch = src[offset];\n          atLineStart = true;\n        }\n\n        if (!ch) {\n          break;\n        }\n\n        if (offset !== lineStart + indent && (atLineStart || ch !== ':')) {\n          if (offset < lineStart + indent) {\n            if (lineStart > start) offset = lineStart;\n            break;\n          } else if (!this.error) {\n            var msg = 'All collection items must start at the same column';\n            this.error = new YAMLSyntaxError(this, msg);\n          }\n        }\n\n        if (firstItem.type === Type.SEQ_ITEM) {\n          if (ch !== '-') {\n            if (lineStart > start) offset = lineStart;\n            break;\n          }\n        } else if (ch === '-' && !this.error) {\n          // map key may start with -, as long as it's followed by a non-whitespace char\n          var _next = src[offset + 1];\n\n          if (!_next || _next === '\\n' || _next === '\\t' || _next === ' ') {\n            var _msg = 'A collection cannot be both a mapping and a sequence';\n            this.error = new YAMLSyntaxError(this, _msg);\n          }\n        }\n\n        var node = parseNode({\n          atLineStart: atLineStart,\n          inCollection: true,\n          indent: indent,\n          lineStart: lineStart,\n          parent: this\n        }, offset);\n        if (!node) return offset; // at next document start\n\n        this.items.push(node);\n        this.valueRange.end = node.valueRange.end;\n        offset = Node.normalizeOffset(src, node.range.end);\n        ch = src[offset];\n        atLineStart = false;\n        prevIncludesTrailingLines = node.includesTrailingLines; // Need to reset lineStart and atLineStart here if preceding node's range\n        // has advanced to check the current line's indentation level\n        // -- eemeli/yaml#10 & eemeli/yaml#38\n\n        if (ch) {\n          var ls = offset - 1;\n          var prev = src[ls];\n\n          while (prev === ' ' || prev === '\\t') {\n            prev = src[--ls];\n          }\n\n          if (prev === '\\n') {\n            lineStart = ls + 1;\n            atLineStart = true;\n          }\n        }\n\n        var ec = grabCollectionEndComments(node);\n        if (ec) Array.prototype.push.apply(this.items, ec);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(Collection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, items[0].range.start) + String(items[0]);\n\n      for (var i = 1; i < items.length; ++i) {\n        var item = items[i];\n        var _item$context = item.context,\n            atLineStart = _item$context.atLineStart,\n            indent = _item$context.indent;\n        if (atLineStart) for (var _i = 0; _i < indent; ++_i) {\n          str += ' ';\n        }\n        str += String(item);\n      }\n\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }], [{\n    key: \"nextContentHasIndent\",\n    value: function nextContentHasIndent(src, offset, indent) {\n      var lineStart = Node.endOfLine(src, offset) + 1;\n      offset = Node.endOfWhiteSpace(src, lineStart);\n      var ch = src[offset];\n      if (!ch) return false;\n      if (offset >= lineStart + indent) return true;\n      if (ch !== '#' && ch !== '\\n') return false;\n      return Collection.nextContentHasIndent(src, offset, indent);\n    }\n  }]);\n\n  return Collection;\n}(Node);\n\nvar Directive = /*#__PURE__*/function (_Node) {\n  _inherits(Directive, _Node);\n\n  var _super = _createSuper(Directive);\n\n  function Directive() {\n    var _this;\n\n    _classCallCheck(this, Directive);\n\n    _this = _super.call(this, Type.DIRECTIVE);\n    _this.name = null;\n    return _this;\n  }\n\n  _createClass(Directive, [{\n    key: \"parameters\",\n    get: function get() {\n      var raw = this.rawValue;\n      return raw ? raw.trim().split(/[ \\t]+/) : [];\n    }\n  }, {\n    key: \"parseName\",\n    value: function parseName(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '\\t' && ch !== ' ') {\n        ch = src[offset += 1];\n      }\n\n      this.name = src.slice(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parseParameters\",\n    value: function parseParameters(start) {\n      var src = this.context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n' && ch !== '#') {\n        ch = src[offset += 1];\n      }\n\n      this.valueRange = new Range(start, offset);\n      return offset;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var offset = this.parseName(start + 1);\n      offset = this.parseParameters(offset);\n      offset = this.parseComment(offset);\n      this.range = new Range(start, offset);\n      return offset;\n    }\n  }]);\n\n  return Directive;\n}(Node);\n\nvar Document = /*#__PURE__*/function (_Node) {\n  _inherits(Document, _Node);\n\n  var _super = _createSuper(Document);\n\n  function Document() {\n    var _this;\n\n    _classCallCheck(this, Document);\n\n    _this = _super.call(this, Type.DOCUMENT);\n    _this.directives = null;\n    _this.contents = null;\n    _this.directivesEndMarker = null;\n    _this.documentEndMarker = null;\n    return _this;\n  }\n\n  _createClass(Document, [{\n    key: \"parseDirectives\",\n    value: function parseDirectives(start) {\n      var src = this.context.src;\n      this.directives = [];\n      var atLineStart = true;\n      var hasDirectives = false;\n      var offset = start;\n\n      while (!Node.atDocumentBoundary(src, offset, Char.DIRECTIVES_END)) {\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.directives.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.directives.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          case '%':\n            {\n              var directive = new Directive();\n              offset = directive.parse({\n                parent: this,\n                src: src\n              }, offset);\n              this.directives.push(directive);\n              hasDirectives = true;\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            if (hasDirectives) {\n              this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');\n            } else if (this.directives.length > 0) {\n              this.contents = this.directives;\n              this.directives = [];\n            }\n\n            return offset;\n        }\n      }\n\n      if (src[offset]) {\n        this.directivesEndMarker = new Range(offset, offset + 3);\n        return offset + 3;\n      }\n\n      if (hasDirectives) {\n        this.error = new YAMLSemanticError(this, 'Missing directives-end indicator line');\n      } else if (this.directives.length > 0) {\n        this.contents = this.directives;\n        this.directives = [];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"parseContents\",\n    value: function parseContents(start) {\n      var _this$context = this.context,\n          parseNode = _this$context.parseNode,\n          src = _this$context.src;\n      if (!this.contents) this.contents = [];\n      var lineStart = start;\n\n      while (src[lineStart - 1] === '-') {\n        lineStart -= 1;\n      }\n\n      var offset = Node.endOfWhiteSpace(src, start);\n      var atLineStart = lineStart === start;\n      this.valueRange = new Range(offset);\n\n      while (!Node.atDocumentBoundary(src, offset, Char.DOCUMENT_END)) {\n        switch (src[offset]) {\n          case '\\n':\n            if (atLineStart) {\n              var blankLine = new BlankLine();\n              offset = blankLine.parse({\n                src: src\n              }, offset);\n\n              if (offset < src.length) {\n                this.contents.push(blankLine);\n              }\n            } else {\n              offset += 1;\n              atLineStart = true;\n            }\n\n            lineStart = offset;\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.contents.push(comment);\n              atLineStart = false;\n            }\n            break;\n\n          default:\n            {\n              var iEnd = Node.endOfIndent(src, offset);\n              var context = {\n                atLineStart: atLineStart,\n                indent: -1,\n                inFlow: false,\n                inCollection: false,\n                lineStart: lineStart,\n                parent: this\n              };\n              var node = parseNode(context, iEnd);\n              if (!node) return this.valueRange.end = iEnd; // at next document start\n\n              this.contents.push(node);\n              offset = node.range.end;\n              atLineStart = false;\n              var ec = grabCollectionEndComments(node);\n              if (ec) Array.prototype.push.apply(this.contents, ec);\n            }\n        }\n\n        offset = Document.startCommentOrEndBlankLine(src, offset);\n      }\n\n      this.valueRange.end = offset;\n\n      if (src[offset]) {\n        this.documentEndMarker = new Range(offset, offset + 3);\n        offset += 3;\n\n        if (src[offset]) {\n          offset = Node.endOfWhiteSpace(src, offset);\n\n          if (src[offset] === '#') {\n            var _comment = new Comment();\n\n            offset = _comment.parse({\n              src: src\n            }, offset);\n            this.contents.push(_comment);\n          }\n\n          switch (src[offset]) {\n            case '\\n':\n              offset += 1;\n              break;\n\n            case undefined:\n              break;\n\n            default:\n              this.error = new YAMLSyntaxError(this, 'Document end marker line cannot have a non-comment suffix');\n          }\n        }\n      }\n\n      return offset;\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      context.root = this;\n      this.context = context;\n      var src = context.src;\n      var offset = src.charCodeAt(start) === 0xfeff ? start + 1 : start; // skip BOM\n\n      offset = this.parseDirectives(offset);\n      offset = this.parseContents(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(Document.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.directives.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.directivesEndMarker) offset = this.directivesEndMarker.setOrigRange(cr, offset);\n      this.contents.forEach(function (node) {\n        offset = node.setOrigRanges(cr, offset);\n      });\n      if (this.documentEndMarker) offset = this.documentEndMarker.setOrigRange(cr, offset);\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var contents = this.contents,\n          directives = this.directives,\n          value = this.value;\n      if (value != null) return value;\n      var str = directives.join('');\n\n      if (contents.length > 0) {\n        if (directives.length > 0 || contents[0].type === Type.COMMENT) str += '---\\n';\n        str += contents.join('');\n      }\n\n      if (str[str.length - 1] !== '\\n') str += '\\n';\n      return str;\n    }\n  }], [{\n    key: \"startCommentOrEndBlankLine\",\n    value: function startCommentOrEndBlankLine(src, start) {\n      var offset = Node.endOfWhiteSpace(src, start);\n      var ch = src[offset];\n      return ch === '#' || ch === '\\n' ? offset : start;\n    }\n  }]);\n\n  return Document;\n}(Node);\n\nvar Alias = /*#__PURE__*/function (_Node) {\n  _inherits(Alias, _Node);\n\n  var _super = _createSuper(Alias);\n\n  function Alias() {\n    _classCallCheck(this, Alias);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Alias, [{\n    key: \"parse\",\n    value:\n    /**\n     * Parses an *alias from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n    function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = Node.endOfIdentifier(src, start + 1);\n      this.valueRange = new Range(start + 1, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }]);\n\n  return Alias;\n}(Node);\n\nvar Chomp = {\n  CLIP: 'CLIP',\n  KEEP: 'KEEP',\n  STRIP: 'STRIP'\n};\nvar BlockValue = /*#__PURE__*/function (_Node) {\n  _inherits(BlockValue, _Node);\n\n  var _super = _createSuper(BlockValue);\n\n  function BlockValue(type, props) {\n    var _this;\n\n    _classCallCheck(this, BlockValue);\n\n    _this = _super.call(this, type, props);\n    _this.blockIndent = null;\n    _this.chomping = Chomp.CLIP;\n    _this.header = null;\n    return _this;\n  }\n\n  _createClass(BlockValue, [{\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return this.chomping === Chomp.KEEP;\n    }\n  }, {\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (this.valueRange.isEmpty()) return '';\n      var lastNewLine = null;\n      var ch = src[end - 1];\n\n      while (ch === '\\n' || ch === '\\t' || ch === ' ') {\n        end -= 1;\n\n        if (end <= start) {\n          if (this.chomping === Chomp.KEEP) break;else return ''; // probably never happens\n        }\n\n        if (ch === '\\n') lastNewLine = end;\n        ch = src[end - 1];\n      }\n\n      var keepStart = end + 1;\n\n      if (lastNewLine) {\n        if (this.chomping === Chomp.KEEP) {\n          keepStart = lastNewLine;\n          end = this.valueRange.end;\n        } else {\n          end = lastNewLine;\n        }\n      }\n\n      var bi = indent + this.blockIndent;\n      var folded = this.type === Type.BLOCK_FOLDED;\n      var atStart = true;\n      var str = '';\n      var sep = '';\n      var prevMoreIndented = false;\n\n      for (var i = start; i < end; ++i) {\n        for (var j = 0; j < bi; ++j) {\n          if (src[i] !== ' ') break;\n          i += 1;\n        }\n\n        var _ch = src[i];\n\n        if (_ch === '\\n') {\n          if (sep === '\\n') str += '\\n';else sep = '\\n';\n        } else {\n          var lineEnd = Node.endOfLine(src, i);\n          var line = src.slice(i, lineEnd);\n          i = lineEnd;\n\n          if (folded && (_ch === ' ' || _ch === '\\t') && i < keepStart) {\n            if (sep === ' ') sep = '\\n';else if (!prevMoreIndented && !atStart && sep === '\\n') sep = '\\n\\n';\n            str += sep + line; //+ ((lineEnd < end && src[lineEnd]) || '')\n\n            sep = lineEnd < end && src[lineEnd] || '';\n            prevMoreIndented = true;\n          } else {\n            str += sep + line;\n            sep = folded && i < keepStart ? ' ' : '\\n';\n            prevMoreIndented = false;\n          }\n\n          if (atStart && line !== '') atStart = false;\n        }\n      }\n\n      return this.chomping === Chomp.STRIP ? str : str + '\\n';\n    }\n  }, {\n    key: \"parseBlockHeader\",\n    value: function parseBlockHeader(start) {\n      var src = this.context.src;\n      var offset = start + 1;\n      var bi = '';\n\n      while (true) {\n        var ch = src[offset];\n\n        switch (ch) {\n          case '-':\n            this.chomping = Chomp.STRIP;\n            break;\n\n          case '+':\n            this.chomping = Chomp.KEEP;\n            break;\n\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n            bi += ch;\n            break;\n\n          default:\n            this.blockIndent = Number(bi) || null;\n            this.header = new Range(start, offset);\n            return offset;\n        }\n\n        offset += 1;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context2 = this.context,\n          indent = _this$context2.indent,\n          src = _this$context2.src;\n      var explicit = !!this.blockIndent;\n      var offset = start;\n      var valueEnd = start;\n      var minBlockIndent = 1;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        offset += 1;\n        if (Node.atDocumentBoundary(src, offset)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset); // should not include tab?\n\n        if (end === null) break;\n        var _ch2 = src[end];\n        var lineIndent = end - (offset + indent);\n\n        if (!this.blockIndent) {\n          // no explicit block indent, none yet detected\n          if (src[end] !== '\\n') {\n            // first line with non-whitespace content\n            if (lineIndent < minBlockIndent) {\n              var msg = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';\n              this.error = new YAMLSemanticError(this, msg);\n            }\n\n            this.blockIndent = lineIndent;\n          } else if (lineIndent > minBlockIndent) {\n            // empty line with more whitespace\n            minBlockIndent = lineIndent;\n          }\n        } else if (_ch2 && _ch2 !== '\\n' && lineIndent < this.blockIndent) {\n          if (src[end] === '#') break;\n\n          if (!this.error) {\n            var _src = explicit ? 'explicit indentation indicator' : 'first line';\n\n            var _msg = \"Block scalars must not be less indented than their \".concat(_src);\n\n            this.error = new YAMLSemanticError(this, _msg);\n          }\n        }\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          offset = valueEnd = Node.endOfLine(src, end);\n        }\n      }\n\n      if (this.chomping !== Chomp.KEEP) {\n        offset = src[valueEnd] ? valueEnd + 1 : valueEnd;\n      }\n\n      this.valueRange = new Range(start + 1, offset);\n      return offset;\n    }\n    /**\n     * Parses a block value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * BS\n     * block\n     * lines\n     *\n     * BS #comment\n     * block\n     * lines\n     * ```\n     * where the block style BS matches the regexp `[|>][-+1-9]*` and block lines\n     * are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this block\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = this.parseBlockHeader(start);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      offset = this.parseBlockValue(offset);\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(BlockValue.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      return this.header ? this.header.setOrigRange(cr, offset) : offset;\n    }\n  }]);\n\n  return BlockValue;\n}(Node);\n\nvar FlowCollection = /*#__PURE__*/function (_Node) {\n  _inherits(FlowCollection, _Node);\n\n  var _super = _createSuper(FlowCollection);\n\n  function FlowCollection(type, props) {\n    var _this;\n\n    _classCallCheck(this, FlowCollection);\n\n    _this = _super.call(this, type, props);\n    _this.items = null;\n    return _this;\n  }\n\n  _createClass(FlowCollection, [{\n    key: \"prevNodeIsJsonLike\",\n    value: function prevNodeIsJsonLike() {\n      var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;\n      var node = this.items[idx - 1];\n      return !!node && (node.jsonLike || node.type === Type.COMMENT && this.prevNodeIsJsonLike(idx - 1));\n    }\n    /**\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var parseNode = context.parseNode,\n          src = context.src;\n      var indent = context.indent,\n          lineStart = context.lineStart;\n      var char = src[start]; // { or [\n\n      this.items = [{\n        char: char,\n        offset: start\n      }];\n      var offset = Node.endOfWhiteSpace(src, start + 1);\n      char = src[offset];\n\n      while (char && char !== ']' && char !== '}') {\n        switch (char) {\n          case '\\n':\n            {\n              lineStart = offset + 1;\n              var wsEnd = Node.endOfWhiteSpace(src, lineStart);\n\n              if (src[wsEnd] === '\\n') {\n                var blankLine = new BlankLine();\n                lineStart = blankLine.parse({\n                  src: src\n                }, lineStart);\n                this.items.push(blankLine);\n              }\n\n              offset = Node.endOfIndent(src, lineStart);\n\n              if (offset <= lineStart + indent) {\n                char = src[offset];\n\n                if (offset < lineStart + indent || char !== ']' && char !== '}') {\n                  var msg = 'Insufficient indentation in flow collection';\n                  this.error = new YAMLSemanticError(this, msg);\n                }\n              }\n            }\n            break;\n\n          case ',':\n            {\n              this.items.push({\n                char: char,\n                offset: offset\n              });\n              offset += 1;\n            }\n            break;\n\n          case '#':\n            {\n              var comment = new Comment();\n              offset = comment.parse({\n                src: src\n              }, offset);\n              this.items.push(comment);\n            }\n            break;\n\n          case '?':\n          case ':':\n            {\n              var next = src[offset + 1];\n\n              if (next === '\\n' || next === '\\t' || next === ' ' || next === ',' || // in-flow : after JSON-like key does not need to be followed by whitespace\n              char === ':' && this.prevNodeIsJsonLike()) {\n                this.items.push({\n                  char: char,\n                  offset: offset\n                });\n                offset += 1;\n                break;\n              }\n            }\n          // fallthrough\n\n          default:\n            {\n              var node = parseNode({\n                atLineStart: false,\n                inCollection: false,\n                inFlow: true,\n                indent: -1,\n                lineStart: lineStart,\n                parent: this\n              }, offset);\n\n              if (!node) {\n                // at next document start\n                this.valueRange = new Range(start, offset);\n                return offset;\n              }\n\n              this.items.push(node);\n              offset = Node.normalizeOffset(src, node.range.end);\n            }\n        }\n\n        offset = Node.endOfWhiteSpace(src, offset);\n        char = src[offset];\n      }\n\n      this.valueRange = new Range(start, offset + 1);\n\n      if (char) {\n        this.items.push({\n          char: char,\n          offset: offset\n        });\n        offset = Node.endOfWhiteSpace(src, offset + 1);\n        offset = this.parseComment(offset);\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      offset = _get(_getPrototypeOf(FlowCollection.prototype), \"setOrigRanges\", this).call(this, cr, offset);\n      this.items.forEach(function (node) {\n        if (node instanceof Node) {\n          offset = node.setOrigRanges(cr, offset);\n        } else if (cr.length === 0) {\n          node.origOffset = node.offset;\n        } else {\n          var i = offset;\n\n          while (i < cr.length) {\n            if (cr[i] > node.offset) break;else ++i;\n          }\n\n          node.origOffset = node.offset + i;\n          offset = i;\n        }\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          items = this.items,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var nodes = items.filter(function (item) {\n        return item instanceof Node;\n      });\n      var str = '';\n      var prevEnd = range.start;\n      nodes.forEach(function (node) {\n        var prefix = src.slice(prevEnd, node.range.start);\n        prevEnd = node.range.end;\n        str += prefix + String(node);\n\n        if (str[str.length - 1] === '\\n' && src[prevEnd - 1] !== '\\n' && src[prevEnd] === '\\n') {\n          // Comment range does not include the terminal newline, but its\n          // stringified value does. Without this fix, newlines at comment ends\n          // get duplicated.\n          prevEnd += 1;\n        }\n      });\n      str += src.slice(prevEnd, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }]);\n\n  return FlowCollection;\n}(Node);\n\nvar QuoteDouble = /*#__PURE__*/function (_Node) {\n  _inherits(QuoteDouble, _Node);\n\n  var _super = _createSuper(QuoteDouble);\n\n  function QuoteDouble() {\n    _classCallCheck(this, QuoteDouble);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(QuoteDouble, [{\n    key: \"strValue\",\n    get:\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== '\"') errors.push(new YAMLSyntaxError(this, 'Missing closing \"quote')); // Using String#replace is too painful with escaped newlines preceded by\n      // escaped backslashes; also, this should be faster.\n\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = Node.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line double-quoted string needs to be sufficiently indented'));\n        } else if (ch === '\\\\') {\n          i += 1;\n\n          switch (src[i]) {\n            case '0':\n              str += '\\0';\n              break;\n            // null character\n\n            case 'a':\n              str += '\\x07';\n              break;\n            // bell character\n\n            case 'b':\n              str += '\\b';\n              break;\n            // backspace\n\n            case 'e':\n              str += '\\x1b';\n              break;\n            // escape character\n\n            case 'f':\n              str += '\\f';\n              break;\n            // form feed\n\n            case 'n':\n              str += '\\n';\n              break;\n            // line feed\n\n            case 'r':\n              str += '\\r';\n              break;\n            // carriage return\n\n            case 't':\n              str += '\\t';\n              break;\n            // horizontal tab\n\n            case 'v':\n              str += '\\v';\n              break;\n            // vertical tab\n\n            case 'N':\n              str += \"\\x85\";\n              break;\n            // Unicode next line\n\n            case '_':\n              str += \"\\xA0\";\n              break;\n            // Unicode non-breaking space\n\n            case 'L':\n              str += \"\\u2028\";\n              break;\n            // Unicode line separator\n\n            case 'P':\n              str += \"\\u2029\";\n              break;\n            // Unicode paragraph separator\n\n            case ' ':\n              str += ' ';\n              break;\n\n            case '\"':\n              str += '\"';\n              break;\n\n            case '/':\n              str += '/';\n              break;\n\n            case '\\\\':\n              str += '\\\\';\n              break;\n\n            case '\\t':\n              str += '\\t';\n              break;\n\n            case 'x':\n              str += this.parseCharCode(i + 1, 2, errors);\n              i += 2;\n              break;\n\n            case 'u':\n              str += this.parseCharCode(i + 1, 4, errors);\n              i += 4;\n              break;\n\n            case 'U':\n              str += this.parseCharCode(i + 1, 8, errors);\n              i += 8;\n              break;\n\n            case '\\n':\n              // skip escaped newlines, but still trim the following line\n              while (src[i + 1] === ' ' || src[i + 1] === '\\t') {\n                i += 1;\n              }\n\n              break;\n\n            default:\n              errors.push(new YAMLSyntaxError(this, \"Invalid escape sequence \".concat(src.substr(i - 1, 2))));\n              str += '\\\\' + src[i];\n          }\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n  }, {\n    key: \"parseCharCode\",\n    value: function parseCharCode(offset, length, errors) {\n      var src = this.context.src;\n      var cc = src.substr(offset, length);\n      var ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);\n      var code = ok ? parseInt(cc, 16) : NaN;\n\n      if (isNaN(code)) {\n        errors.push(new YAMLSyntaxError(this, \"Invalid escape sequence \".concat(src.substr(offset - 2, length + 2))));\n        return src.substr(offset - 2, length + 2);\n      }\n\n      return String.fromCodePoint(code);\n    }\n    /**\n     * Parses a \"double quoted\" value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteDouble.endOfQuote(src, start + 1);\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\"') {\n        offset += ch === '\\\\' ? 2 : 1;\n        ch = src[offset];\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteDouble;\n}(Node);\n\nvar QuoteSingle = /*#__PURE__*/function (_Node) {\n  _inherits(QuoteSingle, _Node);\n\n  var _super = _createSuper(QuoteSingle);\n\n  function QuoteSingle() {\n    _classCallCheck(this, QuoteSingle);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(QuoteSingle, [{\n    key: \"strValue\",\n    get:\n    /**\n     * @returns {string | { str: string, errors: YAMLSyntaxError[] }}\n     */\n    function get() {\n      if (!this.valueRange || !this.context) return null;\n      var errors = [];\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          src = _this$context.src;\n      if (src[end - 1] !== \"'\") errors.push(new YAMLSyntaxError(this, \"Missing closing 'quote\"));\n      var str = '';\n\n      for (var i = start + 1; i < end - 1; ++i) {\n        var ch = src[i];\n\n        if (ch === '\\n') {\n          if (Node.atDocumentBoundary(src, i + 1)) errors.push(new YAMLSemanticError(this, 'Document boundary indicators are not allowed within string values'));\n\n          var _Node$foldNewline = Node.foldNewline(src, i, indent),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset,\n              error = _Node$foldNewline.error;\n\n          str += fold;\n          i = offset;\n          if (error) errors.push(new YAMLSemanticError(this, 'Multi-line single-quoted string needs to be sufficiently indented'));\n        } else if (ch === \"'\") {\n          str += ch;\n          i += 1;\n          if (src[i] !== \"'\") errors.push(new YAMLSyntaxError(this, 'Unescaped single quote? This should not happen.'));\n        } else if (ch === ' ' || ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (next === ' ' || next === '\\t') {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : ch;\n        } else {\n          str += ch;\n        }\n      }\n\n      return errors.length > 0 ? {\n        errors: errors,\n        str: str\n      } : str;\n    }\n    /**\n     * Parses a 'single quoted' value from the source\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var src = context.src;\n      var offset = QuoteSingle.endOfQuote(src, start + 1);\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n      return offset;\n    }\n  }], [{\n    key: \"endOfQuote\",\n    value: function endOfQuote(src, offset) {\n      var ch = src[offset];\n\n      while (ch) {\n        if (ch === \"'\") {\n          if (src[offset + 1] !== \"'\") break;\n          ch = src[offset += 2];\n        } else {\n          ch = src[offset += 1];\n        }\n      }\n\n      return offset + 1;\n    }\n  }]);\n\n  return QuoteSingle;\n}(Node);\n\nfunction createNewNode(type, props) {\n  switch (type) {\n    case Type.ALIAS:\n      return new Alias(type, props);\n\n    case Type.BLOCK_FOLDED:\n    case Type.BLOCK_LITERAL:\n      return new BlockValue(type, props);\n\n    case Type.FLOW_MAP:\n    case Type.FLOW_SEQ:\n      return new FlowCollection(type, props);\n\n    case Type.MAP_KEY:\n    case Type.MAP_VALUE:\n    case Type.SEQ_ITEM:\n      return new CollectionItem(type, props);\n\n    case Type.COMMENT:\n    case Type.PLAIN:\n      return new PlainValue(type, props);\n\n    case Type.QUOTE_DOUBLE:\n      return new QuoteDouble(type, props);\n\n    case Type.QUOTE_SINGLE:\n      return new QuoteSingle(type, props);\n\n    /* istanbul ignore next */\n\n    default:\n      return null;\n    // should never happen\n  }\n}\n/**\n * @param {boolean} atLineStart - Node starts at beginning of line\n * @param {boolean} inFlow - true if currently in a flow context\n * @param {boolean} inCollection - true if currently in a collection context\n * @param {number} indent - Current level of indentation\n * @param {number} lineStart - Start of the current line\n * @param {Node} parent - The parent of the node\n * @param {string} src - Source of the YAML document\n */\n\n\nvar ParseContext = /*#__PURE__*/function () {\n  function ParseContext() {\n    var _this = this;\n\n    var orig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        atLineStart = _ref.atLineStart,\n        inCollection = _ref.inCollection,\n        inFlow = _ref.inFlow,\n        indent = _ref.indent,\n        lineStart = _ref.lineStart,\n        parent = _ref.parent;\n\n    _classCallCheck(this, ParseContext);\n\n    _defineProperty(this, \"parseNode\", function (overlay, start) {\n      if (Node.atDocumentBoundary(_this.src, start)) return null;\n      var context = new ParseContext(_this, overlay);\n\n      var _context$parseProps = context.parseProps(start),\n          props = _context$parseProps.props,\n          type = _context$parseProps.type,\n          valueStart = _context$parseProps.valueStart;\n\n      var node = createNewNode(type, props);\n      var offset = node.parse(context, valueStart);\n      node.range = new Range(start, offset);\n      /* istanbul ignore if */\n\n      if (offset <= start) {\n        // This should never happen, but if it does, let's make sure to at least\n        // step one character forward to avoid a busy loop.\n        node.error = new Error(\"Node#parse consumed no characters\");\n        node.error.parseEnd = offset;\n        node.error.source = node;\n        node.range.end = start + 1;\n      }\n\n      if (context.nodeStartsCollection(node)) {\n        if (!node.error && !context.atLineStart && context.parent.type === Type.DOCUMENT) {\n          node.error = new YAMLSyntaxError(node, 'Block collection must not have preceding content here (e.g. directives-end indicator)');\n        }\n\n        var collection = new Collection(node);\n        offset = collection.parse(new ParseContext(context), offset);\n        collection.range = new Range(start, offset);\n        return collection;\n      }\n\n      return node;\n    });\n\n    this.atLineStart = atLineStart != null ? atLineStart : orig.atLineStart || false;\n    this.inCollection = inCollection != null ? inCollection : orig.inCollection || false;\n    this.inFlow = inFlow != null ? inFlow : orig.inFlow || false;\n    this.indent = indent != null ? indent : orig.indent;\n    this.lineStart = lineStart != null ? lineStart : orig.lineStart;\n    this.parent = parent != null ? parent : orig.parent || {};\n    this.root = orig.root;\n    this.src = orig.src;\n  }\n\n  _createClass(ParseContext, [{\n    key: \"nodeStartsCollection\",\n    value: function nodeStartsCollection(node) {\n      var inCollection = this.inCollection,\n          inFlow = this.inFlow,\n          src = this.src;\n      if (inCollection || inFlow) return false;\n      if (node instanceof CollectionItem) return true; // check for implicit key\n\n      var offset = node.range.end;\n      if (src[offset] === '\\n' || src[offset - 1] === '\\n') return false;\n      offset = Node.endOfWhiteSpace(src, offset);\n      return src[offset] === ':';\n    } // Anchor and tag are before type, which determines the node implementation\n    // class; hence this intermediate step.\n\n  }, {\n    key: \"parseProps\",\n    value: function parseProps(offset) {\n      var inFlow = this.inFlow,\n          parent = this.parent,\n          src = this.src;\n      var props = [];\n      var lineHasProps = false;\n      offset = this.atLineStart ? Node.endOfIndent(src, offset) : Node.endOfWhiteSpace(src, offset);\n      var ch = src[offset];\n\n      while (ch === Char.ANCHOR || ch === Char.COMMENT || ch === Char.TAG || ch === '\\n') {\n        if (ch === '\\n') {\n          var inEnd = offset;\n          var lineStart = void 0;\n\n          do {\n            lineStart = inEnd + 1;\n            inEnd = Node.endOfIndent(src, lineStart);\n          } while (src[inEnd] === '\\n');\n\n          var indentDiff = inEnd - (lineStart + this.indent);\n          var noIndicatorAsIndent = parent.type === Type.SEQ_ITEM && parent.context.atLineStart;\n          if (src[inEnd] !== '#' && !Node.nextNodeIsIndented(src[inEnd], indentDiff, !noIndicatorAsIndent)) break;\n          this.atLineStart = true;\n          this.lineStart = lineStart;\n          lineHasProps = false;\n          offset = inEnd;\n        } else if (ch === Char.COMMENT) {\n          var end = Node.endOfLine(src, offset + 1);\n          props.push(new Range(offset, end));\n          offset = end;\n        } else {\n          var _end = Node.endOfIdentifier(src, offset + 1);\n\n          if (ch === Char.TAG && src[_end] === ',' && /^[a-zA-Z0-9-]+\\.[a-zA-Z0-9-]+,\\d\\d\\d\\d(-\\d\\d){0,2}\\/\\S/.test(src.slice(offset + 1, _end + 13))) {\n            // Let's presume we're dealing with a YAML 1.0 domain tag here, rather\n            // than an empty but 'foo.bar' private-tagged node in a flow collection\n            // followed without whitespace by a plain string starting with a year\n            // or date divided by something.\n            _end = Node.endOfIdentifier(src, _end + 5);\n          }\n\n          props.push(new Range(offset, _end));\n          lineHasProps = true;\n          offset = Node.endOfWhiteSpace(src, _end);\n        }\n\n        ch = src[offset];\n      } // '- &a : b' has an anchor on an empty node\n\n\n      if (lineHasProps && ch === ':' && Node.atBlank(src, offset + 1, true)) offset -= 1;\n      var type = ParseContext.parseType(src, offset, inFlow);\n      return {\n        props: props,\n        type: type,\n        valueStart: offset\n      };\n    }\n    /**\n     * Parses a node from the source\n     * @param {ParseContext} overlay\n     * @param {number} start - Index of first non-whitespace character for the node\n     * @returns {?Node} - null if at a document boundary\n     */\n\n  }], [{\n    key: \"parseType\",\n    value: function parseType(src, offset, inFlow) {\n      switch (src[offset]) {\n        case '*':\n          return Type.ALIAS;\n\n        case '>':\n          return Type.BLOCK_FOLDED;\n\n        case '|':\n          return Type.BLOCK_LITERAL;\n\n        case '{':\n          return Type.FLOW_MAP;\n\n        case '[':\n          return Type.FLOW_SEQ;\n\n        case '?':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_KEY : Type.PLAIN;\n\n        case ':':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.MAP_VALUE : Type.PLAIN;\n\n        case '-':\n          return !inFlow && Node.atBlank(src, offset + 1, true) ? Type.SEQ_ITEM : Type.PLAIN;\n\n        case '\"':\n          return Type.QUOTE_DOUBLE;\n\n        case \"'\":\n          return Type.QUOTE_SINGLE;\n\n        default:\n          return Type.PLAIN;\n      }\n    }\n  }]);\n\n  return ParseContext;\n}();\n\n// Published as 'yaml/parse-cst'\nfunction parse(src) {\n  var cr = [];\n\n  if (src.indexOf('\\r') !== -1) {\n    src = src.replace(/\\r\\n?/g, function (match, offset) {\n      if (match.length > 1) cr.push(offset);\n      return '\\n';\n    });\n  }\n\n  var documents = [];\n  var offset = 0;\n\n  do {\n    var doc = new Document();\n    var context = new ParseContext({\n      src: src\n    });\n    offset = doc.parse(context, offset);\n    documents.push(doc);\n  } while (offset < src.length);\n\n  documents.setOrigRanges = function () {\n    if (cr.length === 0) return false;\n\n    for (var i = 1; i < cr.length; ++i) {\n      cr[i] -= i;\n    }\n\n    var crOffset = 0;\n\n    for (var _i = 0; _i < documents.length; ++_i) {\n      crOffset = documents[_i].setOrigRanges(cr, crOffset);\n    }\n\n    cr.splice(0, cr.length);\n    return true;\n  };\n\n  documents.toString = function () {\n    return documents.join('...\\n');\n  };\n\n  return documents;\n}\n\nexport { parse };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}