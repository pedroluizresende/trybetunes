{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.ensureBlock = ensureBlock;\nexports.toComputedKey = toComputedKey;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\n\nvar _t = require(\"@babel/types\");\n\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nvar _visitors = require(\"../visitors\");\n\nconst {\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  conditionalExpression,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  jsxIdentifier,\n  logicalExpression,\n  LOGICAL_OPERATORS,\n  memberExpression,\n  metaProperty,\n  numericLiteral,\n  objectExpression,\n  restElement,\n  returnStatement,\n  sequenceExpression,\n  spreadElement,\n  stringLiteral,\n  super: _super,\n  thisExpression,\n  toExpression,\n  unaryExpression\n} = _t;\n\nfunction toComputedKey() {\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!this.node.computed) {\n    if (isIdentifier(key)) key = stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction setType(path, type) {\n  path.node.type = type;\n}\n\nfunction arrowFunctionToExpression() {\n  let {\n    allowInsertArrow = true,\n    specCompliant = false,\n    noNewArrows = !specCompliant\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const {\n    thisBinding,\n    fnPath: fn\n  } = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);\n  fn.ensureBlock();\n  setType(fn, \"FunctionExpression\");\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      fn.parentPath.scope.push({\n        id: checkBinding,\n        init: objectExpression([])\n      });\n    }\n\n    fn.get(\"body\").unshiftContainer(\"body\", expressionStatement(callExpression(this.hub.addHelper(\"newArrowCheck\"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));\n    fn.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this, true) || fn.node, identifier(\"bind\")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));\n    return fn.get(\"callee.object\");\n  }\n\n  return fn;\n}\n\nconst getSuperCallsVisitor = (0, _visitors.merge)([{\n  CallExpression(child, _ref) {\n    let {\n      allSuperCalls\n    } = _ref;\n    if (!child.get(\"callee\").isSuper()) return;\n    allSuperCalls.push(child);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction hoistFunctionEnvironment(fnPath) {\n  let noNewArrows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  let allowInsertArrow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let arrowParent;\n  let thisEnvFn = fnPath.findParent(p => {\n    if (p.isArrowFunctionExpression()) {\n      var _arrowParent;\n\n      (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;\n      return false;\n    }\n\n    return p.isFunction() || p.isProgram() || p.isClassProperty({\n      static: false\n    }) || p.isClassPrivateProperty({\n      static: false\n    });\n  });\n  const inConstructor = thisEnvFn.isClassMethod({\n    kind: \"constructor\"\n  });\n\n  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {\n    if (arrowParent) {\n      thisEnvFn = arrowParent;\n    } else if (allowInsertArrow) {\n      fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));\n      thisEnvFn = fnPath.get(\"callee\");\n      fnPath = thisEnvFn.get(\"body\");\n    } else {\n      throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n    }\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse(getSuperCallsVisitor, {\n      allSuperCalls\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => {\n      const args = () => identifier(\"arguments\");\n\n      if (thisEnvFn.scope.path.isProgram()) {\n        return conditionalExpression(binaryExpression(\"===\", unaryExpression(\"typeof\", args()), stringLiteral(\"undefined\")), thisEnvFn.scope.buildUndefinedNode(), args());\n      } else {\n        return args();\n      }\n    });\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => metaProperty(identifier(\"new\"), identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const superParentPath = superProp.parentPath;\n      const isAssignment = superParentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superParentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superParentPath.node.right;\n        args.push(value);\n      }\n\n      const call = callExpression(identifier(superBinding), args);\n\n      if (isCall) {\n        superParentPath.unshiftContainer(\"arguments\", thisExpression());\n        superProp.replaceWith(memberExpression(call, identifier(\"call\")));\n        thisPaths.push(superParentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superParentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return {\n    thisBinding,\n    fnPath\n  };\n}\n\nfunction isLogicalOp(op) {\n  return LOGICAL_OPERATORS.includes(op);\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    const isLogicalAssignment = isLogicalOp(op);\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      const object = superProp.node.object;\n      const property = superProp.node.property;\n      assignmentPath.get(\"left\").replaceWith(memberExpression(object, assignmentExpression(\"=\", tmp, property), true));\n      assignmentPath.get(\"right\").replaceWith(rightExpression(isLogicalAssignment ? \"=\" : op, memberExpression(object, identifier(tmp.name), true), value));\n    } else {\n      const object = superProp.node.object;\n      const property = superProp.node.property;\n      assignmentPath.get(\"left\").replaceWith(memberExpression(object, property));\n      assignmentPath.get(\"right\").replaceWith(rightExpression(isLogicalAssignment ? \"=\" : op, memberExpression(object, identifier(property.name)), value));\n    }\n\n    if (isLogicalAssignment) {\n      assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));\n    } else {\n      assignmentPath.node.operator = \"=\";\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [assignmentExpression(\"=\", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression(\"=\", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n\n  function rightExpression(op, left, right) {\n    if (op === \"=\") {\n      return assignmentExpression(\"=\", left, right);\n    } else {\n      return binaryExpression(op, left, right);\n    }\n  }\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nconst assignSuperThisVisitor = (0, _visitors.merge)([{\n  CallExpression(child, _ref2) {\n    let {\n      supers,\n      thisBinding\n    } = _ref2;\n    if (!child.get(\"callee\").isSuper()) return;\n    if (supers.has(child.node)) return;\n    supers.add(child.node);\n    child.replaceWithMultiple([child.node, assignmentExpression(\"=\", identifier(thisBinding), identifier(\"this\"))]);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();\n    thisEnvFn.traverse(assignSuperThisVisitor, {\n      supers: new WeakSet(),\n      thisBinding\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = memberExpression(_super(), identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = memberExpression(_super(), identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = assignmentExpression(\"=\", fnBody, identifier(valueIdent.name));\n    }\n\n    return arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nconst getScopeInformationVisitor = (0, _visitors.merge)([{\n  ThisExpression(child, _ref3) {\n    let {\n      thisPaths\n    } = _ref3;\n    thisPaths.push(child);\n  },\n\n  JSXIdentifier(child, _ref4) {\n    let {\n      thisPaths\n    } = _ref4;\n    if (child.node.name !== \"this\") return;\n\n    if (!child.parentPath.isJSXMemberExpression({\n      object: child.node\n    }) && !child.parentPath.isJSXOpeningElement({\n      name: child.node\n    })) {\n      return;\n    }\n\n    thisPaths.push(child);\n  },\n\n  CallExpression(child, _ref5) {\n    let {\n      superCalls\n    } = _ref5;\n    if (child.get(\"callee\").isSuper()) superCalls.push(child);\n  },\n\n  MemberExpression(child, _ref6) {\n    let {\n      superProps\n    } = _ref6;\n    if (child.get(\"object\").isSuper()) superProps.push(child);\n  },\n\n  Identifier(child, _ref7) {\n    let {\n      argumentsPaths\n    } = _ref7;\n    if (!child.isReferencedIdentifier({\n      name: \"arguments\"\n    })) return;\n    let curr = child.scope;\n\n    do {\n      if (curr.hasOwnBinding(\"arguments\")) {\n        curr.rename(\"arguments\");\n        return;\n      }\n\n      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n        break;\n      }\n    } while (curr = curr.parent);\n\n    argumentsPaths.push(child);\n  },\n\n  MetaProperty(child, _ref8) {\n    let {\n      newTargetPaths\n    } = _ref8;\n    if (!child.get(\"meta\").isIdentifier({\n      name: \"new\"\n    })) return;\n    if (!child.get(\"property\").isIdentifier({\n      name: \"target\"\n    })) return;\n    newTargetPaths.push(child);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse(getScopeInformationVisitor, {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","arrowFunctionToExpression","arrowFunctionToShadowed","ensureBlock","toComputedKey","unwrapFunctionEnvironment","_t","require","_helperEnvironmentVisitor","_helperFunctionName","_visitors","arrowFunctionExpression","assignmentExpression","binaryExpression","blockStatement","callExpression","conditionalExpression","expressionStatement","identifier","isIdentifier","jsxIdentifier","logicalExpression","LOGICAL_OPERATORS","memberExpression","metaProperty","numericLiteral","objectExpression","restElement","returnStatement","sequenceExpression","spreadElement","stringLiteral","super","_super","thisExpression","toExpression","unaryExpression","key","isMemberExpression","node","property","isProperty","isMethod","ReferenceError","computed","name","body","get","bodyNode","Array","isArray","Error","isBlockStatement","statements","stringPath","listKey","isStatement","push","isFunction","parentPath","setup","isArrowFunctionExpression","isFunctionExpression","isFunctionDeclaration","buildCodeFrameError","hoistFunctionEnvironment","setType","path","type","allowInsertArrow","specCompliant","noNewArrows","thisBinding","fnPath","fn","checkBinding","scope","generateUidIdentifier","id","init","unshiftContainer","hub","addHelper","replaceWith","default","getSuperCallsVisitor","merge","CallExpression","child","allSuperCalls","isSuper","arrowParent","thisEnvFn","findParent","p","_arrowParent","isProgram","isClassProperty","static","isClassPrivateProperty","inConstructor","isClassMethod","kind","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","getScopeInformation","length","traverse","superBinding","getSuperBinding","forEach","superCall","callee","loc","argumentsBinding","getBinding","args","buildUndefinedNode","argumentsChild","argsRef","newTargetBinding","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","concat","standardizeSuperProperty","superParentPath","isAssignment","isAssignmentExpression","left","isCall","isCallExpression","getSuperPropBinding","right","call","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","isLogicalOp","op","includes","operator","assignmentPath","slice","isLogicalAssignment","tmp","generateDeclaredUidIdentifier","object","rightExpression","isUpdateExpression","updateExpr","computedKey","parts","prefix","superClass","assignSuperThisVisitor","supers","has","add","replaceWithMultiple","WeakSet","argsBinding","propName","argsList","fnBody","method","unshift","valueIdent","cacheKey","data","getData","setData","getScopeInformationVisitor","ThisExpression","JSXIdentifier","isJSXMemberExpression","isJSXOpeningElement","MemberExpression","Identifier","isReferencedIdentifier","curr","hasOwnBinding","rename","parent","MetaProperty"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/@babel/traverse/lib/path/conversion.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.ensureBlock = ensureBlock;\nexports.toComputedKey = toComputedKey;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\n\nvar _t = require(\"@babel/types\");\n\nvar _helperEnvironmentVisitor = require(\"@babel/helper-environment-visitor\");\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nvar _visitors = require(\"../visitors\");\n\nconst {\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  conditionalExpression,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  jsxIdentifier,\n  logicalExpression,\n  LOGICAL_OPERATORS,\n  memberExpression,\n  metaProperty,\n  numericLiteral,\n  objectExpression,\n  restElement,\n  returnStatement,\n  sequenceExpression,\n  spreadElement,\n  stringLiteral,\n  super: _super,\n  thisExpression,\n  toExpression,\n  unaryExpression\n} = _t;\n\nfunction toComputedKey() {\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!this.node.computed) {\n    if (isIdentifier(key)) key = stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction setType(path, type) {\n  path.node.type = type;\n}\n\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  specCompliant = false,\n  noNewArrows = !specCompliant\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const {\n    thisBinding,\n    fnPath: fn\n  } = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);\n  fn.ensureBlock();\n  setType(fn, \"FunctionExpression\");\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      fn.parentPath.scope.push({\n        id: checkBinding,\n        init: objectExpression([])\n      });\n    }\n\n    fn.get(\"body\").unshiftContainer(\"body\", expressionStatement(callExpression(this.hub.addHelper(\"newArrowCheck\"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));\n    fn.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this, true) || fn.node, identifier(\"bind\")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));\n    return fn.get(\"callee.object\");\n  }\n\n  return fn;\n}\n\nconst getSuperCallsVisitor = (0, _visitors.merge)([{\n  CallExpression(child, {\n    allSuperCalls\n  }) {\n    if (!child.get(\"callee\").isSuper()) return;\n    allSuperCalls.push(child);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true) {\n  let arrowParent;\n  let thisEnvFn = fnPath.findParent(p => {\n    if (p.isArrowFunctionExpression()) {\n      var _arrowParent;\n\n      (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;\n      return false;\n    }\n\n    return p.isFunction() || p.isProgram() || p.isClassProperty({\n      static: false\n    }) || p.isClassPrivateProperty({\n      static: false\n    });\n  });\n  const inConstructor = thisEnvFn.isClassMethod({\n    kind: \"constructor\"\n  });\n\n  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {\n    if (arrowParent) {\n      thisEnvFn = arrowParent;\n    } else if (allowInsertArrow) {\n      fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));\n      thisEnvFn = fnPath.get(\"callee\");\n      fnPath = thisEnvFn.get(\"body\");\n    } else {\n      throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n    }\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse(getSuperCallsVisitor, {\n      allSuperCalls\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => {\n      const args = () => identifier(\"arguments\");\n\n      if (thisEnvFn.scope.path.isProgram()) {\n        return conditionalExpression(binaryExpression(\"===\", unaryExpression(\"typeof\", args()), stringLiteral(\"undefined\")), thisEnvFn.scope.buildUndefinedNode(), args());\n      } else {\n        return args();\n      }\n    });\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => metaProperty(identifier(\"new\"), identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const superParentPath = superProp.parentPath;\n      const isAssignment = superParentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superParentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superParentPath.node.right;\n        args.push(value);\n      }\n\n      const call = callExpression(identifier(superBinding), args);\n\n      if (isCall) {\n        superParentPath.unshiftContainer(\"arguments\", thisExpression());\n        superProp.replaceWith(memberExpression(call, identifier(\"call\")));\n        thisPaths.push(superParentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superParentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return {\n    thisBinding,\n    fnPath\n  };\n}\n\nfunction isLogicalOp(op) {\n  return LOGICAL_OPERATORS.includes(op);\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    const isLogicalAssignment = isLogicalOp(op);\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      const object = superProp.node.object;\n      const property = superProp.node.property;\n      assignmentPath.get(\"left\").replaceWith(memberExpression(object, assignmentExpression(\"=\", tmp, property), true));\n      assignmentPath.get(\"right\").replaceWith(rightExpression(isLogicalAssignment ? \"=\" : op, memberExpression(object, identifier(tmp.name), true), value));\n    } else {\n      const object = superProp.node.object;\n      const property = superProp.node.property;\n      assignmentPath.get(\"left\").replaceWith(memberExpression(object, property));\n      assignmentPath.get(\"right\").replaceWith(rightExpression(isLogicalAssignment ? \"=\" : op, memberExpression(object, identifier(property.name)), value));\n    }\n\n    if (isLogicalAssignment) {\n      assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));\n    } else {\n      assignmentPath.node.operator = \"=\";\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [assignmentExpression(\"=\", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression(\"=\", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n\n  function rightExpression(op, left, right) {\n    if (op === \"=\") {\n      return assignmentExpression(\"=\", left, right);\n    } else {\n      return binaryExpression(op, left, right);\n    }\n  }\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nconst assignSuperThisVisitor = (0, _visitors.merge)([{\n  CallExpression(child, {\n    supers,\n    thisBinding\n  }) {\n    if (!child.get(\"callee\").isSuper()) return;\n    if (supers.has(child.node)) return;\n    supers.add(child.node);\n    child.replaceWithMultiple([child.node, assignmentExpression(\"=\", identifier(thisBinding), identifier(\"this\"))]);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();\n    thisEnvFn.traverse(assignSuperThisVisitor, {\n      supers: new WeakSet(),\n      thisBinding\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = memberExpression(_super(), identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = memberExpression(_super(), identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = assignmentExpression(\"=\", fnBody, identifier(valueIdent.name));\n    }\n\n    return arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nconst getScopeInformationVisitor = (0, _visitors.merge)([{\n  ThisExpression(child, {\n    thisPaths\n  }) {\n    thisPaths.push(child);\n  },\n\n  JSXIdentifier(child, {\n    thisPaths\n  }) {\n    if (child.node.name !== \"this\") return;\n\n    if (!child.parentPath.isJSXMemberExpression({\n      object: child.node\n    }) && !child.parentPath.isJSXOpeningElement({\n      name: child.node\n    })) {\n      return;\n    }\n\n    thisPaths.push(child);\n  },\n\n  CallExpression(child, {\n    superCalls\n  }) {\n    if (child.get(\"callee\").isSuper()) superCalls.push(child);\n  },\n\n  MemberExpression(child, {\n    superProps\n  }) {\n    if (child.get(\"object\").isSuper()) superProps.push(child);\n  },\n\n  Identifier(child, {\n    argumentsPaths\n  }) {\n    if (!child.isReferencedIdentifier({\n      name: \"arguments\"\n    })) return;\n    let curr = child.scope;\n\n    do {\n      if (curr.hasOwnBinding(\"arguments\")) {\n        curr.rename(\"arguments\");\n        return;\n      }\n\n      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n        break;\n      }\n    } while (curr = curr.parent);\n\n    argumentsPaths.push(child);\n  },\n\n  MetaProperty(child, {\n    newTargetPaths\n  }) {\n    if (!child.get(\"meta\").isIdentifier({\n      name: \"new\"\n    })) return;\n    if (!child.get(\"property\").isIdentifier({\n      name: \"target\"\n    })) return;\n    newTargetPaths.push(child);\n  }\n\n}, _helperEnvironmentVisitor.default]);\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse(getScopeInformationVisitor, {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}