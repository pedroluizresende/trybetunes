{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluate = evaluate;\nexports.evaluateTruthy = evaluateTruthy;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction isValidCallee(val) {\n  return VALID_CALLEES.includes(val);\n}\n\nfunction isInvalidMethod(val) {\n  return INVALID_METHODS.includes(val);\n}\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding != null && binding.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && isValidCallee(callee.node.name)) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && isValidCallee(object.node.name) && !isInvalidMethod(property.node.name)) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state) {\n  let raw = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","evaluate","evaluateTruthy","VALID_CALLEES","INVALID_METHODS","isValidCallee","val","includes","isInvalidMethod","res","confident","deopt","path","state","deoptPath","evaluateCached","node","seen","has","existing","get","resolved","item","set","_evaluate","isSequenceExpression","exprs","length","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","isTemplateLiteral","evaluateQuasis","quasis","isTaggedTemplateExpression","isMemberExpression","object","name","property","isIdentifier","scope","getBinding","quasi","isConditionalExpression","testResult","isExpressionWrapper","parentPath","isCallExpression","callee","isLiteral","type","isReferencedIdentifier","binding","constantViolations","start","end","hasValue","undefined","Infinity","NaN","resolve","isUnaryExpression","prefix","operator","argument","isFunction","isClass","arg","isArrayExpression","arr","elems","elem","elemValue","push","isObjectExpression","obj","props","prop","isObjectMethod","isSpreadElement","keyPath","key","computed","valuePath","isLogicalExpression","wasConfident","left","leftConfident","right","rightConfident","isBinaryExpression","Math","pow","context","func","global","args","map","apply","raw","str","i","cooked","expr","String","Map"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/@babel/traverse/lib/path/evaluation.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluate = evaluate;\nexports.evaluateTruthy = evaluateTruthy;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction isValidCallee(val) {\n  return VALID_CALLEES.includes(val);\n}\n\nfunction isInvalidMethod(val) {\n  return INVALID_METHODS.includes(val);\n}\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding != null && binding.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && isValidCallee(callee.node.name)) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && isValidCallee(object.node.name) && !isInvalidMethod(property.node.name)) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}