{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayExpression = ArrayExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.BooleanLiteral = BooleanLiteral;\nexports.CallExpression = CallExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\nexports.LogicalExpression = LogicalExpression;\nexports.NewExpression = NewExpression;\nexports.NullLiteral = NullLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.RegExpLiteral = RegExpLiteral;\nexports.RestElement = RestElement;\nexports.SequenceExpression = SequenceExpression;\nexports.StringLiteral = StringLiteral;\nexports.TSAsExpression = TSAsExpression;\nexports.TSNonNullExpression = TSNonNullExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.TypeCastExpression = TypeCastExpression;\nexports.UnaryExpression = UnaryExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.VariableDeclarator = VariableDeclarator;\n\nvar _t = require(\"@babel/types\");\n\nvar _infererReference = require(\"./inferer-reference\");\n\nvar _util = require(\"./util\");\n\nconst {\n  BOOLEAN_BINARY_OPERATORS,\n  BOOLEAN_UNARY_OPERATORS,\n  NUMBER_BINARY_OPERATORS,\n  NUMBER_UNARY_OPERATORS,\n  STRING_UNARY_OPERATORS,\n  anyTypeAnnotation,\n  arrayTypeAnnotation,\n  booleanTypeAnnotation,\n  buildMatchMemberExpression,\n  genericTypeAnnotation,\n  identifier,\n  nullLiteralTypeAnnotation,\n  numberTypeAnnotation,\n  stringTypeAnnotation,\n  tupleTypeAnnotation,\n  unionTypeAnnotation,\n  voidTypeAnnotation,\n  isIdentifier\n} = _t;\n\nfunction VariableDeclarator() {\n  if (!this.get(\"id\").isIdentifier()) return;\n  return this.get(\"init\").getTypeAnnotation();\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction TSAsExpression(node) {\n  return node.typeAnnotation;\n}\n\nTSAsExpression.validParent = true;\n\nfunction TSNonNullExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction NewExpression(node) {\n  if (node.callee.type === \"Identifier\") {\n    return genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return voidTypeAnnotation();\n  } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return stringTypeAnnotation();\n  } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return stringTypeAnnotation();\n    }\n\n    return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n  return (0, _util.createUnionType)(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n  return (0, _util.createUnionType)(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return genericTypeAnnotation(identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return genericTypeAnnotation(identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return genericTypeAnnotation(identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return genericTypeAnnotation(identifier(\"Function\"));\n}\n\nconst isArrayFrom = buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return arrayTypeAnnotation(stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier(callee, {\n    name: \"Array\"\n  })) {\n    return arrayTypeAnnotation(anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    const {\n      node\n    } = callee;\n\n    if (node.async) {\n      if (node.generator) {\n        return genericTypeAnnotation(identifier(\"AsyncIterator\"));\n      } else {\n        return genericTypeAnnotation(identifier(\"Promise\"));\n      }\n    } else {\n      if (node.generator) {\n        return genericTypeAnnotation(identifier(\"Iterator\"));\n      } else if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","ArrayExpression","AssignmentExpression","BinaryExpression","BooleanLiteral","CallExpression","ConditionalExpression","ClassDeclaration","ClassExpression","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","Func","enumerable","get","_infererReference","default","LogicalExpression","NewExpression","NullLiteral","NumericLiteral","ObjectExpression","ParenthesizedExpression","RegExpLiteral","RestElement","SequenceExpression","StringLiteral","TSAsExpression","TSNonNullExpression","TaggedTemplateExpression","TemplateLiteral","TypeCastExpression","UnaryExpression","UpdateExpression","VariableDeclarator","_t","require","_util","BOOLEAN_BINARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","NUMBER_BINARY_OPERATORS","NUMBER_UNARY_OPERATORS","STRING_UNARY_OPERATORS","anyTypeAnnotation","arrayTypeAnnotation","booleanTypeAnnotation","buildMatchMemberExpression","genericTypeAnnotation","identifier","nullLiteralTypeAnnotation","numberTypeAnnotation","stringTypeAnnotation","tupleTypeAnnotation","unionTypeAnnotation","voidTypeAnnotation","isIdentifier","getTypeAnnotation","node","typeAnnotation","validParent","callee","type","operator","indexOf","right","left","isBaseType","argumentTypes","createUnionType","pop","isArrayFrom","isObjectKeys","isObjectValues","isObjectEntries","name","resolveCall","resolve","isFunction","async","generator","returnType"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/@babel/traverse/lib/path/inference/inferers.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayExpression = ArrayExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.BooleanLiteral = BooleanLiteral;\nexports.CallExpression = CallExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\nexports.LogicalExpression = LogicalExpression;\nexports.NewExpression = NewExpression;\nexports.NullLiteral = NullLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.RegExpLiteral = RegExpLiteral;\nexports.RestElement = RestElement;\nexports.SequenceExpression = SequenceExpression;\nexports.StringLiteral = StringLiteral;\nexports.TSAsExpression = TSAsExpression;\nexports.TSNonNullExpression = TSNonNullExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.TypeCastExpression = TypeCastExpression;\nexports.UnaryExpression = UnaryExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.VariableDeclarator = VariableDeclarator;\n\nvar _t = require(\"@babel/types\");\n\nvar _infererReference = require(\"./inferer-reference\");\n\nvar _util = require(\"./util\");\n\nconst {\n  BOOLEAN_BINARY_OPERATORS,\n  BOOLEAN_UNARY_OPERATORS,\n  NUMBER_BINARY_OPERATORS,\n  NUMBER_UNARY_OPERATORS,\n  STRING_UNARY_OPERATORS,\n  anyTypeAnnotation,\n  arrayTypeAnnotation,\n  booleanTypeAnnotation,\n  buildMatchMemberExpression,\n  genericTypeAnnotation,\n  identifier,\n  nullLiteralTypeAnnotation,\n  numberTypeAnnotation,\n  stringTypeAnnotation,\n  tupleTypeAnnotation,\n  unionTypeAnnotation,\n  voidTypeAnnotation,\n  isIdentifier\n} = _t;\n\nfunction VariableDeclarator() {\n  if (!this.get(\"id\").isIdentifier()) return;\n  return this.get(\"init\").getTypeAnnotation();\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction TSAsExpression(node) {\n  return node.typeAnnotation;\n}\n\nTSAsExpression.validParent = true;\n\nfunction TSNonNullExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction NewExpression(node) {\n  if (node.callee.type === \"Identifier\") {\n    return genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return voidTypeAnnotation();\n  } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return stringTypeAnnotation();\n  } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return stringTypeAnnotation();\n    }\n\n    return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n  return (0, _util.createUnionType)(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n  return (0, _util.createUnionType)(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return genericTypeAnnotation(identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return genericTypeAnnotation(identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return genericTypeAnnotation(identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return genericTypeAnnotation(identifier(\"Function\"));\n}\n\nconst isArrayFrom = buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return arrayTypeAnnotation(stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier(callee, {\n    name: \"Array\"\n  })) {\n    return arrayTypeAnnotation(anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    const {\n      node\n    } = callee;\n\n    if (node.async) {\n      if (node.generator) {\n        return genericTypeAnnotation(identifier(\"AsyncIterator\"));\n      } else {\n        return genericTypeAnnotation(identifier(\"Promise\"));\n      }\n    } else {\n      if (node.generator) {\n        return genericTypeAnnotation(identifier(\"Iterator\"));\n      } else if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}