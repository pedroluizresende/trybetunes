{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.needsParens = needsParens;\nexports.needsWhitespace = needsWhitespace;\nexports.needsWhitespaceAfter = needsWhitespaceAfter;\nexports.needsWhitespaceBefore = needsWhitespaceBefore;\n\nvar whitespace = require(\"./whitespace\");\n\nvar parens = require(\"./parentheses\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  FLIPPED_ALIAS_KEYS,\n  isCallExpression,\n  isExpressionStatement,\n  isMemberExpression,\n  isNewExpression\n} = _t;\n\nfunction expandAliases(obj) {\n  const newObj = {};\n\n  function add(type, func) {\n    const fn = newObj[type];\n    newObj[type] = fn ? function (node, parent, stack) {\n      const result = fn(node, parent, stack);\n      return result == null ? func(node, parent, stack) : result;\n    } : func;\n  }\n\n  for (const type of Object.keys(obj)) {\n    const aliases = FLIPPED_ALIAS_KEYS[type];\n\n    if (aliases) {\n      for (const alias of aliases) {\n        add(alias, obj[type]);\n      }\n    } else {\n      add(type, obj[type]);\n    }\n  }\n\n  return newObj;\n}\n\nconst expandedParens = expandAliases(parens);\nconst expandedWhitespaceNodes = expandAliases(whitespace.nodes);\n\nfunction find(obj, node, parent, printStack) {\n  const fn = obj[node.type];\n  return fn ? fn(node, parent, printStack) : null;\n}\n\nfunction isOrHasCallExpression(node) {\n  if (isCallExpression(node)) {\n    return true;\n  }\n\n  return isMemberExpression(node) && isOrHasCallExpression(node.object);\n}\n\nfunction needsWhitespace(node, parent, type) {\n  if (!node) return false;\n\n  if (isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  const flag = find(expandedWhitespaceNodes, node, parent);\n\n  if (typeof flag === \"number\") {\n    return (flag & type) !== 0;\n  }\n\n  return false;\n}\n\nfunction needsWhitespaceBefore(node, parent) {\n  return needsWhitespace(node, parent, 1);\n}\n\nfunction needsWhitespaceAfter(node, parent) {\n  return needsWhitespace(node, parent, 2);\n}\n\nfunction needsParens(node, parent, printStack) {\n  if (!parent) return false;\n\n  if (isNewExpression(parent) && parent.callee === node) {\n    if (isOrHasCallExpression(node)) return true;\n  }\n\n  return find(expandedParens, node, parent, printStack);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","needsParens","needsWhitespace","needsWhitespaceAfter","needsWhitespaceBefore","whitespace","require","parens","_t","FLIPPED_ALIAS_KEYS","isCallExpression","isExpressionStatement","isMemberExpression","isNewExpression","expandAliases","obj","newObj","add","type","func","fn","node","parent","stack","result","keys","aliases","alias","expandedParens","expandedWhitespaceNodes","nodes","find","printStack","isOrHasCallExpression","object","expression","flag","callee"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/@babel/generator/lib/node/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.needsParens = needsParens;\nexports.needsWhitespace = needsWhitespace;\nexports.needsWhitespaceAfter = needsWhitespaceAfter;\nexports.needsWhitespaceBefore = needsWhitespaceBefore;\n\nvar whitespace = require(\"./whitespace\");\n\nvar parens = require(\"./parentheses\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  FLIPPED_ALIAS_KEYS,\n  isCallExpression,\n  isExpressionStatement,\n  isMemberExpression,\n  isNewExpression\n} = _t;\n\nfunction expandAliases(obj) {\n  const newObj = {};\n\n  function add(type, func) {\n    const fn = newObj[type];\n    newObj[type] = fn ? function (node, parent, stack) {\n      const result = fn(node, parent, stack);\n      return result == null ? func(node, parent, stack) : result;\n    } : func;\n  }\n\n  for (const type of Object.keys(obj)) {\n    const aliases = FLIPPED_ALIAS_KEYS[type];\n\n    if (aliases) {\n      for (const alias of aliases) {\n        add(alias, obj[type]);\n      }\n    } else {\n      add(type, obj[type]);\n    }\n  }\n\n  return newObj;\n}\n\nconst expandedParens = expandAliases(parens);\nconst expandedWhitespaceNodes = expandAliases(whitespace.nodes);\n\nfunction find(obj, node, parent, printStack) {\n  const fn = obj[node.type];\n  return fn ? fn(node, parent, printStack) : null;\n}\n\nfunction isOrHasCallExpression(node) {\n  if (isCallExpression(node)) {\n    return true;\n  }\n\n  return isMemberExpression(node) && isOrHasCallExpression(node.object);\n}\n\nfunction needsWhitespace(node, parent, type) {\n  if (!node) return false;\n\n  if (isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  const flag = find(expandedWhitespaceNodes, node, parent);\n\n  if (typeof flag === \"number\") {\n    return (flag & type) !== 0;\n  }\n\n  return false;\n}\n\nfunction needsWhitespaceBefore(node, parent) {\n  return needsWhitespace(node, parent, 1);\n}\n\nfunction needsWhitespaceAfter(node, parent) {\n  return needsWhitespace(node, parent, 2);\n}\n\nfunction needsParens(node, parent, printStack) {\n  if (!parent) return false;\n\n  if (isNewExpression(parent) && parent.callee === node) {\n    if (isOrHasCallExpression(node)) return true;\n  }\n\n  return find(expandedParens, node, parent, printStack);\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}