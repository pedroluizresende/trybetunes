{"ast":null,"code":"'use strict';\n/**\n * Compares a string to a second value that, if it fits a certain convention,\n * is converted to a regular expression before the comparison.\n * If it doesn't fit the convention, then two strings are compared.\n *\n * Any strings starting and ending with `/` are interpreted\n * as regular expressions.\n *\n * @param {string | Array<string>} input\n * @param {string | RegExp | Array<string | RegExp>} comparison\n *\n * @returns {false | {match: string, pattern: (string | RegExp), substring: string}}\n */\n\nmodule.exports = function matchesStringOrRegExp(input, comparison) {\n  if (!Array.isArray(input)) {\n    return testAgainstStringOrRegExpOrArray(input, comparison);\n  }\n\n  for (const inputItem of input) {\n    const testResult = testAgainstStringOrRegExpOrArray(inputItem, comparison);\n\n    if (testResult) {\n      return testResult;\n    }\n  }\n\n  return false;\n};\n/**\n * @param {string} value\n * @param {string | RegExp | Array<string | RegExp>} comparison\n */\n\n\nfunction testAgainstStringOrRegExpOrArray(value, comparison) {\n  if (!Array.isArray(comparison)) {\n    return testAgainstStringOrRegExp(value, comparison);\n  }\n\n  for (const comparisonItem of comparison) {\n    const testResult = testAgainstStringOrRegExp(value, comparisonItem);\n\n    if (testResult) {\n      return testResult;\n    }\n  }\n\n  return false;\n}\n/**\n * @param {string} value\n * @param {string | RegExp} comparison\n */\n\n\nfunction testAgainstStringOrRegExp(value, comparison) {\n  // If it's a RegExp, test directly\n  if (comparison instanceof RegExp) {\n    const match = value.match(comparison);\n    return match ? {\n      match: value,\n      pattern: comparison,\n      substring: match[0] || ''\n    } : false;\n  } // Check if it's RegExp in a string\n\n\n  const firstComparisonChar = comparison[0];\n  const lastComparisonChar = comparison[comparison.length - 1];\n  const secondToLastComparisonChar = comparison[comparison.length - 2];\n  const comparisonIsRegex = firstComparisonChar === '/' && (lastComparisonChar === '/' || secondToLastComparisonChar === '/' && lastComparisonChar === 'i');\n  const hasCaseInsensitiveFlag = comparisonIsRegex && lastComparisonChar === 'i'; // If so, create a new RegExp from it\n\n  if (comparisonIsRegex) {\n    const valueMatch = hasCaseInsensitiveFlag ? value.match(new RegExp(comparison.slice(1, -2), 'i')) : value.match(new RegExp(comparison.slice(1, -1)));\n    return valueMatch ? {\n      match: value,\n      pattern: comparison,\n      substring: valueMatch[0] || ''\n    } : false;\n  } // Otherwise, it's a string. Do a strict comparison\n\n\n  return value === comparison ? {\n    match: value,\n    pattern: comparison,\n    substring: value\n  } : false;\n}","map":{"version":3,"names":["module","exports","matchesStringOrRegExp","input","comparison","Array","isArray","testAgainstStringOrRegExpOrArray","inputItem","testResult","value","testAgainstStringOrRegExp","comparisonItem","RegExp","match","pattern","substring","firstComparisonChar","lastComparisonChar","length","secondToLastComparisonChar","comparisonIsRegex","hasCaseInsensitiveFlag","valueMatch","slice"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/stylelint/lib/utils/matchesStringOrRegExp.js"],"sourcesContent":["'use strict';\n\n/**\n * Compares a string to a second value that, if it fits a certain convention,\n * is converted to a regular expression before the comparison.\n * If it doesn't fit the convention, then two strings are compared.\n *\n * Any strings starting and ending with `/` are interpreted\n * as regular expressions.\n *\n * @param {string | Array<string>} input\n * @param {string | RegExp | Array<string | RegExp>} comparison\n *\n * @returns {false | {match: string, pattern: (string | RegExp), substring: string}}\n */\nmodule.exports = function matchesStringOrRegExp(input, comparison) {\n\tif (!Array.isArray(input)) {\n\t\treturn testAgainstStringOrRegExpOrArray(input, comparison);\n\t}\n\n\tfor (const inputItem of input) {\n\t\tconst testResult = testAgainstStringOrRegExpOrArray(inputItem, comparison);\n\n\t\tif (testResult) {\n\t\t\treturn testResult;\n\t\t}\n\t}\n\n\treturn false;\n};\n\n/**\n * @param {string} value\n * @param {string | RegExp | Array<string | RegExp>} comparison\n */\nfunction testAgainstStringOrRegExpOrArray(value, comparison) {\n\tif (!Array.isArray(comparison)) {\n\t\treturn testAgainstStringOrRegExp(value, comparison);\n\t}\n\n\tfor (const comparisonItem of comparison) {\n\t\tconst testResult = testAgainstStringOrRegExp(value, comparisonItem);\n\n\t\tif (testResult) {\n\t\t\treturn testResult;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * @param {string} value\n * @param {string | RegExp} comparison\n */\nfunction testAgainstStringOrRegExp(value, comparison) {\n\t// If it's a RegExp, test directly\n\tif (comparison instanceof RegExp) {\n\t\tconst match = value.match(comparison);\n\n\t\treturn match ? { match: value, pattern: comparison, substring: match[0] || '' } : false;\n\t}\n\n\t// Check if it's RegExp in a string\n\tconst firstComparisonChar = comparison[0];\n\tconst lastComparisonChar = comparison[comparison.length - 1];\n\tconst secondToLastComparisonChar = comparison[comparison.length - 2];\n\n\tconst comparisonIsRegex =\n\t\tfirstComparisonChar === '/' &&\n\t\t(lastComparisonChar === '/' ||\n\t\t\t(secondToLastComparisonChar === '/' && lastComparisonChar === 'i'));\n\n\tconst hasCaseInsensitiveFlag = comparisonIsRegex && lastComparisonChar === 'i';\n\n\t// If so, create a new RegExp from it\n\tif (comparisonIsRegex) {\n\t\tconst valueMatch = hasCaseInsensitiveFlag\n\t\t\t? value.match(new RegExp(comparison.slice(1, -2), 'i'))\n\t\t\t: value.match(new RegExp(comparison.slice(1, -1)));\n\n\t\treturn valueMatch\n\t\t\t? { match: value, pattern: comparison, substring: valueMatch[0] || '' }\n\t\t\t: false;\n\t}\n\n\t// Otherwise, it's a string. Do a strict comparison\n\treturn value === comparison ? { match: value, pattern: comparison, substring: value } : false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}