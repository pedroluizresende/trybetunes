{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction SourcePos() {\n  return {\n    identifierName: undefined,\n    line: undefined,\n    column: undefined,\n    filename: undefined\n  };\n}\n\nclass Buffer {\n  constructor(map) {\n    this._map = null;\n    this._buf = \"\";\n    this._str = \"\";\n    this._appendCount = 0;\n    this._last = 0;\n    this._queue = [];\n    this._queueCursor = 0;\n    this._position = {\n      line: 1,\n      column: 0\n    };\n    this._sourcePosition = SourcePos();\n    this._disallowedPop = {\n      identifierName: undefined,\n      line: undefined,\n      column: undefined,\n      filename: undefined,\n      objectReusable: true\n    };\n    this._map = map;\n\n    this._allocQueue();\n  }\n\n  _allocQueue() {\n    const queue = this._queue;\n\n    for (let i = 0; i < 16; i++) {\n      queue.push({\n        char: 0,\n        repeat: 1,\n        line: undefined,\n        column: undefined,\n        identifierName: undefined,\n        filename: \"\"\n      });\n    }\n  }\n\n  _pushQueue(char, repeat, line, column, identifierName, filename) {\n    const cursor = this._queueCursor;\n\n    if (cursor === this._queue.length) {\n      this._allocQueue();\n    }\n\n    const item = this._queue[cursor];\n    item.char = char;\n    item.repeat = repeat;\n    item.line = line;\n    item.column = column;\n    item.identifierName = identifierName;\n    item.filename = filename;\n    this._queueCursor++;\n  }\n\n  _popQueue() {\n    if (this._queueCursor === 0) {\n      throw new Error(\"Cannot pop from empty queue\");\n    }\n\n    return this._queue[--this._queueCursor];\n  }\n\n  get() {\n    this._flush();\n\n    const map = this._map;\n    const result = {\n      code: (this._buf + this._str).trimRight(),\n      decodedMap: map == null ? void 0 : map.getDecoded(),\n\n      get map() {\n        const resultMap = map ? map.get() : null;\n        result.map = resultMap;\n        return resultMap;\n      },\n\n      set map(value) {\n        Object.defineProperty(result, \"map\", {\n          value,\n          writable: true\n        });\n      },\n\n      get rawMappings() {\n        const mappings = map == null ? void 0 : map.getRawMappings();\n        result.rawMappings = mappings;\n        return mappings;\n      },\n\n      set rawMappings(value) {\n        Object.defineProperty(result, \"rawMappings\", {\n          value,\n          writable: true\n        });\n      }\n\n    };\n    return result;\n  }\n\n  append(str, maybeNewline) {\n    this._flush();\n\n    this._append(str, this._sourcePosition, maybeNewline);\n  }\n\n  appendChar(char) {\n    this._flush();\n\n    this._appendChar(char, 1, this._sourcePosition);\n  }\n\n  queue(char) {\n    if (char === 10) {\n      while (this._queueCursor !== 0) {\n        const char = this._queue[this._queueCursor - 1].char;\n\n        if (char !== 32 && char !== 9) {\n          break;\n        }\n\n        this._queueCursor--;\n      }\n    }\n\n    const sourcePosition = this._sourcePosition;\n\n    this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.identifierName, sourcePosition.filename);\n  }\n\n  queueIndentation(char, repeat) {\n    this._pushQueue(char, repeat, undefined, undefined, undefined, undefined);\n  }\n\n  _flush() {\n    const queueCursor = this._queueCursor;\n    const queue = this._queue;\n\n    for (let i = 0; i < queueCursor; i++) {\n      const item = queue[i];\n\n      this._appendChar(item.char, item.repeat, item);\n    }\n\n    this._queueCursor = 0;\n  }\n\n  _appendChar(char, repeat, sourcePos) {\n    this._last = char;\n    this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);\n\n    if (char !== 10) {\n      this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.filename);\n\n      this._position.column += repeat;\n    } else {\n      this._position.line++;\n      this._position.column = 0;\n    }\n  }\n\n  _append(str, sourcePos, maybeNewline) {\n    const len = str.length;\n    this._last = str.charCodeAt(len - 1);\n\n    if (++this._appendCount > 4096) {\n      +this._str;\n      this._buf += this._str;\n      this._str = str;\n      this._appendCount = 0;\n    } else {\n      this._str += str;\n    }\n\n    if (!maybeNewline && !this._map) {\n      this._position.column += len;\n      return;\n    }\n\n    const {\n      column,\n      identifierName,\n      filename\n    } = sourcePos;\n    let line = sourcePos.line;\n    let i = str.indexOf(\"\\n\");\n    let last = 0;\n\n    if (i !== 0) {\n      this._mark(line, column, identifierName, filename);\n    }\n\n    while (i !== -1) {\n      this._position.line++;\n      this._position.column = 0;\n      last = i + 1;\n\n      if (last < str.length) {\n        this._mark(++line, 0, identifierName, filename);\n      }\n\n      i = str.indexOf(\"\\n\", last);\n    }\n\n    this._position.column += str.length - last;\n  }\n\n  _mark(line, column, identifierName, filename) {\n    var _this$_map;\n\n    (_this$_map = this._map) == null ? void 0 : _this$_map.mark(this._position, line, column, identifierName, filename);\n  }\n\n  removeTrailingNewline() {\n    const queueCursor = this._queueCursor;\n\n    if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {\n      this._queueCursor--;\n    }\n  }\n\n  removeLastSemicolon() {\n    const queueCursor = this._queueCursor;\n\n    if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {\n      this._queueCursor--;\n    }\n  }\n\n  getLastChar() {\n    const queueCursor = this._queueCursor;\n    return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;\n  }\n\n  endsWithCharAndNewline() {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n\n    if (queueCursor !== 0) {\n      const lastCp = queue[queueCursor - 1].char;\n      if (lastCp !== 10) return;\n\n      if (queueCursor > 1) {\n        return queue[queueCursor - 2].char;\n      } else {\n        return this._last;\n      }\n    }\n  }\n\n  hasContent() {\n    return this._queueCursor !== 0 || !!this._last;\n  }\n\n  exactSource(loc, cb) {\n    if (!this._map) return cb();\n    this.source(\"start\", loc);\n    cb();\n    this.source(\"end\", loc);\n\n    this._disallowPop(\"start\", loc);\n  }\n\n  source(prop, loc) {\n    if (!loc) return;\n\n    this._normalizePosition(prop, loc, this._sourcePosition);\n  }\n\n  withSource(prop, loc, cb) {\n    if (!this._map) return cb();\n    const originalLine = this._sourcePosition.line;\n    const originalColumn = this._sourcePosition.column;\n    const originalFilename = this._sourcePosition.filename;\n    const originalIdentifierName = this._sourcePosition.identifierName;\n    this.source(prop, loc);\n    cb();\n\n    if (this._disallowedPop.objectReusable || this._disallowedPop.line !== originalLine || this._disallowedPop.column !== originalColumn || this._disallowedPop.filename !== originalFilename) {\n      this._sourcePosition.line = originalLine;\n      this._sourcePosition.column = originalColumn;\n      this._sourcePosition.filename = originalFilename;\n      this._sourcePosition.identifierName = originalIdentifierName;\n      this._disallowedPop.objectReusable = true;\n    }\n  }\n\n  _disallowPop(prop, loc) {\n    if (!loc) return;\n    const disallowedPop = this._disallowedPop;\n\n    this._normalizePosition(prop, loc, disallowedPop);\n\n    disallowedPop.objectReusable = false;\n  }\n\n  _normalizePosition(prop, loc, targetObj) {\n    const pos = loc[prop];\n    targetObj.identifierName = prop === \"start\" && loc.identifierName || undefined;\n\n    if (pos) {\n      targetObj.line = pos.line;\n      targetObj.column = pos.column;\n      targetObj.filename = loc.filename;\n    } else {\n      targetObj.line = null;\n      targetObj.column = null;\n      targetObj.filename = null;\n    }\n  }\n\n  getCurrentColumn() {\n    const queue = this._queue;\n    let lastIndex = -1;\n    let len = 0;\n\n    for (let i = 0; i < this._queueCursor; i++) {\n      const item = queue[i];\n\n      if (item.char === 10) {\n        lastIndex = i;\n        len += item.repeat;\n      }\n    }\n\n    return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;\n  }\n\n  getCurrentLine() {\n    let count = 0;\n    const queue = this._queue;\n\n    for (let i = 0; i < this._queueCursor; i++) {\n      if (queue[i].char === 10) {\n        count++;\n      }\n    }\n\n    return this._position.line + count;\n  }\n\n}\n\nexports.default = Buffer;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","SourcePos","identifierName","undefined","line","column","filename","Buffer","constructor","map","_map","_buf","_str","_appendCount","_last","_queue","_queueCursor","_position","_sourcePosition","_disallowedPop","objectReusable","_allocQueue","queue","i","push","char","repeat","_pushQueue","cursor","length","item","_popQueue","Error","get","_flush","result","code","trimRight","decodedMap","getDecoded","resultMap","writable","rawMappings","mappings","getRawMappings","append","str","maybeNewline","_append","appendChar","_appendChar","sourcePosition","queueIndentation","queueCursor","sourcePos","String","fromCharCode","_mark","len","charCodeAt","indexOf","last","_this$_map","mark","removeTrailingNewline","removeLastSemicolon","getLastChar","endsWithCharAndNewline","lastCp","hasContent","exactSource","loc","cb","source","_disallowPop","prop","_normalizePosition","withSource","originalLine","originalColumn","originalFilename","originalIdentifierName","disallowedPop","targetObj","pos","getCurrentColumn","lastIndex","getCurrentLine","count"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/@babel/generator/lib/buffer.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction SourcePos() {\n  return {\n    identifierName: undefined,\n    line: undefined,\n    column: undefined,\n    filename: undefined\n  };\n}\n\nclass Buffer {\n  constructor(map) {\n    this._map = null;\n    this._buf = \"\";\n    this._str = \"\";\n    this._appendCount = 0;\n    this._last = 0;\n    this._queue = [];\n    this._queueCursor = 0;\n    this._position = {\n      line: 1,\n      column: 0\n    };\n    this._sourcePosition = SourcePos();\n    this._disallowedPop = {\n      identifierName: undefined,\n      line: undefined,\n      column: undefined,\n      filename: undefined,\n      objectReusable: true\n    };\n    this._map = map;\n\n    this._allocQueue();\n  }\n\n  _allocQueue() {\n    const queue = this._queue;\n\n    for (let i = 0; i < 16; i++) {\n      queue.push({\n        char: 0,\n        repeat: 1,\n        line: undefined,\n        column: undefined,\n        identifierName: undefined,\n        filename: \"\"\n      });\n    }\n  }\n\n  _pushQueue(char, repeat, line, column, identifierName, filename) {\n    const cursor = this._queueCursor;\n\n    if (cursor === this._queue.length) {\n      this._allocQueue();\n    }\n\n    const item = this._queue[cursor];\n    item.char = char;\n    item.repeat = repeat;\n    item.line = line;\n    item.column = column;\n    item.identifierName = identifierName;\n    item.filename = filename;\n    this._queueCursor++;\n  }\n\n  _popQueue() {\n    if (this._queueCursor === 0) {\n      throw new Error(\"Cannot pop from empty queue\");\n    }\n\n    return this._queue[--this._queueCursor];\n  }\n\n  get() {\n    this._flush();\n\n    const map = this._map;\n    const result = {\n      code: (this._buf + this._str).trimRight(),\n      decodedMap: map == null ? void 0 : map.getDecoded(),\n\n      get map() {\n        const resultMap = map ? map.get() : null;\n        result.map = resultMap;\n        return resultMap;\n      },\n\n      set map(value) {\n        Object.defineProperty(result, \"map\", {\n          value,\n          writable: true\n        });\n      },\n\n      get rawMappings() {\n        const mappings = map == null ? void 0 : map.getRawMappings();\n        result.rawMappings = mappings;\n        return mappings;\n      },\n\n      set rawMappings(value) {\n        Object.defineProperty(result, \"rawMappings\", {\n          value,\n          writable: true\n        });\n      }\n\n    };\n    return result;\n  }\n\n  append(str, maybeNewline) {\n    this._flush();\n\n    this._append(str, this._sourcePosition, maybeNewline);\n  }\n\n  appendChar(char) {\n    this._flush();\n\n    this._appendChar(char, 1, this._sourcePosition);\n  }\n\n  queue(char) {\n    if (char === 10) {\n      while (this._queueCursor !== 0) {\n        const char = this._queue[this._queueCursor - 1].char;\n\n        if (char !== 32 && char !== 9) {\n          break;\n        }\n\n        this._queueCursor--;\n      }\n    }\n\n    const sourcePosition = this._sourcePosition;\n\n    this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.identifierName, sourcePosition.filename);\n  }\n\n  queueIndentation(char, repeat) {\n    this._pushQueue(char, repeat, undefined, undefined, undefined, undefined);\n  }\n\n  _flush() {\n    const queueCursor = this._queueCursor;\n    const queue = this._queue;\n\n    for (let i = 0; i < queueCursor; i++) {\n      const item = queue[i];\n\n      this._appendChar(item.char, item.repeat, item);\n    }\n\n    this._queueCursor = 0;\n  }\n\n  _appendChar(char, repeat, sourcePos) {\n    this._last = char;\n    this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);\n\n    if (char !== 10) {\n      this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.filename);\n\n      this._position.column += repeat;\n    } else {\n      this._position.line++;\n      this._position.column = 0;\n    }\n  }\n\n  _append(str, sourcePos, maybeNewline) {\n    const len = str.length;\n    this._last = str.charCodeAt(len - 1);\n\n    if (++this._appendCount > 4096) {\n      +this._str;\n      this._buf += this._str;\n      this._str = str;\n      this._appendCount = 0;\n    } else {\n      this._str += str;\n    }\n\n    if (!maybeNewline && !this._map) {\n      this._position.column += len;\n      return;\n    }\n\n    const {\n      column,\n      identifierName,\n      filename\n    } = sourcePos;\n    let line = sourcePos.line;\n    let i = str.indexOf(\"\\n\");\n    let last = 0;\n\n    if (i !== 0) {\n      this._mark(line, column, identifierName, filename);\n    }\n\n    while (i !== -1) {\n      this._position.line++;\n      this._position.column = 0;\n      last = i + 1;\n\n      if (last < str.length) {\n        this._mark(++line, 0, identifierName, filename);\n      }\n\n      i = str.indexOf(\"\\n\", last);\n    }\n\n    this._position.column += str.length - last;\n  }\n\n  _mark(line, column, identifierName, filename) {\n    var _this$_map;\n\n    (_this$_map = this._map) == null ? void 0 : _this$_map.mark(this._position, line, column, identifierName, filename);\n  }\n\n  removeTrailingNewline() {\n    const queueCursor = this._queueCursor;\n\n    if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {\n      this._queueCursor--;\n    }\n  }\n\n  removeLastSemicolon() {\n    const queueCursor = this._queueCursor;\n\n    if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {\n      this._queueCursor--;\n    }\n  }\n\n  getLastChar() {\n    const queueCursor = this._queueCursor;\n    return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;\n  }\n\n  endsWithCharAndNewline() {\n    const queue = this._queue;\n    const queueCursor = this._queueCursor;\n\n    if (queueCursor !== 0) {\n      const lastCp = queue[queueCursor - 1].char;\n      if (lastCp !== 10) return;\n\n      if (queueCursor > 1) {\n        return queue[queueCursor - 2].char;\n      } else {\n        return this._last;\n      }\n    }\n  }\n\n  hasContent() {\n    return this._queueCursor !== 0 || !!this._last;\n  }\n\n  exactSource(loc, cb) {\n    if (!this._map) return cb();\n    this.source(\"start\", loc);\n    cb();\n    this.source(\"end\", loc);\n\n    this._disallowPop(\"start\", loc);\n  }\n\n  source(prop, loc) {\n    if (!loc) return;\n\n    this._normalizePosition(prop, loc, this._sourcePosition);\n  }\n\n  withSource(prop, loc, cb) {\n    if (!this._map) return cb();\n    const originalLine = this._sourcePosition.line;\n    const originalColumn = this._sourcePosition.column;\n    const originalFilename = this._sourcePosition.filename;\n    const originalIdentifierName = this._sourcePosition.identifierName;\n    this.source(prop, loc);\n    cb();\n\n    if (this._disallowedPop.objectReusable || this._disallowedPop.line !== originalLine || this._disallowedPop.column !== originalColumn || this._disallowedPop.filename !== originalFilename) {\n      this._sourcePosition.line = originalLine;\n      this._sourcePosition.column = originalColumn;\n      this._sourcePosition.filename = originalFilename;\n      this._sourcePosition.identifierName = originalIdentifierName;\n      this._disallowedPop.objectReusable = true;\n    }\n  }\n\n  _disallowPop(prop, loc) {\n    if (!loc) return;\n    const disallowedPop = this._disallowedPop;\n\n    this._normalizePosition(prop, loc, disallowedPop);\n\n    disallowedPop.objectReusable = false;\n  }\n\n  _normalizePosition(prop, loc, targetObj) {\n    const pos = loc[prop];\n    targetObj.identifierName = prop === \"start\" && loc.identifierName || undefined;\n\n    if (pos) {\n      targetObj.line = pos.line;\n      targetObj.column = pos.column;\n      targetObj.filename = loc.filename;\n    } else {\n      targetObj.line = null;\n      targetObj.column = null;\n      targetObj.filename = null;\n    }\n  }\n\n  getCurrentColumn() {\n    const queue = this._queue;\n    let lastIndex = -1;\n    let len = 0;\n\n    for (let i = 0; i < this._queueCursor; i++) {\n      const item = queue[i];\n\n      if (item.char === 10) {\n        lastIndex = i;\n        len += item.repeat;\n      }\n    }\n\n    return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;\n  }\n\n  getCurrentLine() {\n    let count = 0;\n    const queue = this._queue;\n\n    for (let i = 0; i < this._queueCursor; i++) {\n      if (queue[i].char === 10) {\n        count++;\n      }\n    }\n\n    return this._position.line + count;\n  }\n\n}\n\nexports.default = Buffer;"],"mappings":"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"},"metadata":{},"sourceType":"script"}