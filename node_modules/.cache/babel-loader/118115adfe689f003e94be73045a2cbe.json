{"ast":null,"code":"'use strict';\n\nconst debug = require('debug')('stylelint:standalone');\n\nconst fastGlob = require('fast-glob');\n\nconst fs = require('fs');\n\nconst globby = require('globby');\n\nconst normalizePath = require('normalize-path');\n\nconst path = require('path');\n\nconst createStylelint = require('./createStylelint');\n\nconst createStylelintResult = require('./createStylelintResult');\n\nconst FileCache = require('./utils/FileCache');\n\nconst filterFilePaths = require('./utils/filterFilePaths');\n\nconst formatters = require('./formatters');\n\nconst getFileIgnorer = require('./utils/getFileIgnorer');\n\nconst getFormatterOptionsText = require('./utils/getFormatterOptionsText');\n\nconst hash = require('./utils/hash');\n\nconst NoFilesFoundError = require('./utils/noFilesFoundError');\n\nconst AllFilesIgnoredError = require('./utils/allFilesIgnoredError');\n\nconst {\n  assert\n} = require('./utils/validateTypes');\n\nconst pkg = require('../package.json');\n\nconst prepareReturnValue = require('./prepareReturnValue');\n\nconst ALWAYS_IGNORED_GLOBS = ['**/node_modules/**'];\n\nconst writeFileAtomic = require('write-file-atomic');\n/** @typedef {import('stylelint').LinterOptions} LinterOptions */\n\n/** @typedef {import('stylelint').LinterResult} LinterResult */\n\n/** @typedef {import('stylelint').LintResult} StylelintResult */\n\n/** @typedef {import('stylelint').Formatter} Formatter */\n\n/** @typedef {import('stylelint').FormatterType} FormatterType */\n\n/**\n *\n * @param {LinterOptions} options\n * @returns {Promise<LinterResult>}\n */\n\n\nasync function standalone(_ref) {\n  let {\n    allowEmptyInput = false,\n    cache: useCache = false,\n    cacheLocation,\n    code,\n    codeFilename,\n    config,\n    configBasedir,\n    configFile,\n    customSyntax,\n    cwd = process.cwd(),\n    disableDefaultIgnores,\n    files,\n    fix,\n    formatter,\n    globbyOptions,\n    ignoreDisables,\n    ignorePath,\n    ignorePattern,\n    maxWarnings,\n    quiet,\n    reportDescriptionlessDisables,\n    reportInvalidScopeDisables,\n    reportNeedlessDisables,\n    syntax\n  } = _ref;\n\n  /** @type {FileCache} */\n  let fileCache;\n  const startTime = Date.now();\n  const isValidCode = typeof code === 'string';\n\n  if (!files && !isValidCode || files && (code || isValidCode)) {\n    return Promise.reject(new Error('You must pass stylelint a `files` glob or a `code` string, though not both'));\n  } // The ignorer will be used to filter file paths after the glob is checked,\n  // before any files are actually read\n\n  /** @type {import('ignore').Ignore} */\n\n\n  let ignorer;\n\n  try {\n    ignorer = getFileIgnorer({\n      cwd,\n      ignorePath,\n      ignorePattern\n    });\n  } catch (error) {\n    return Promise.reject(error);\n  }\n  /** @type {Formatter} */\n\n\n  let formatterFunction;\n\n  try {\n    formatterFunction = getFormatterFunction(formatter);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  const stylelint = createStylelint({\n    config,\n    configFile,\n    configBasedir,\n    cwd,\n    ignoreDisables,\n    ignorePath,\n    reportNeedlessDisables,\n    reportInvalidScopeDisables,\n    reportDescriptionlessDisables,\n    syntax,\n    customSyntax,\n    fix,\n    quiet\n  });\n\n  if (!files) {\n    const absoluteCodeFilename = codeFilename !== undefined && !path.isAbsolute(codeFilename) ? path.join(cwd, codeFilename) : codeFilename; // if file is ignored, return nothing\n\n    if (absoluteCodeFilename && !filterFilePaths(ignorer, [path.relative(cwd, absoluteCodeFilename)]).length) {\n      return prepareReturnValue([], maxWarnings, formatterFunction, cwd);\n    }\n\n    let stylelintResult;\n\n    try {\n      const postcssResult = await stylelint._lintSource({\n        code,\n        codeFilename: absoluteCodeFilename\n      });\n      stylelintResult = await stylelint._createStylelintResult(postcssResult, absoluteCodeFilename);\n    } catch (error) {\n      stylelintResult = await handleError(stylelint, error);\n    }\n\n    const postcssResult = stylelintResult._postcssResult;\n    const returnValue = prepareReturnValue([stylelintResult], maxWarnings, formatterFunction, cwd);\n\n    if (fix && postcssResult && !postcssResult.stylelint.ignored && !postcssResult.stylelint.ruleDisableFix) {\n      returnValue.output = !postcssResult.stylelint.disableWritingFix && postcssResult.opts ? // If we're fixing, the output should be the fixed code\n      postcssResult.root.toString(postcssResult.opts.syntax) : // If the writing of the fix is disabled, the input code is returned as-is\n      code;\n    }\n\n    return returnValue;\n  }\n\n  let fileList = [files].flat().map(entry => {\n    const globCWD = globbyOptions && globbyOptions.cwd || cwd;\n    const absolutePath = !path.isAbsolute(entry) ? path.join(globCWD, entry) : path.normalize(entry);\n\n    if (fs.existsSync(absolutePath)) {\n      // This path points to a file. Return an escaped path to avoid globbing\n      return fastGlob.escapePath(normalizePath(entry));\n    }\n\n    return entry;\n  });\n\n  if (!disableDefaultIgnores) {\n    fileList = fileList.concat(ALWAYS_IGNORED_GLOBS.map(glob => `!${glob}`));\n  }\n\n  if (useCache) {\n    const stylelintVersion = pkg.version;\n    const hashOfConfig = hash(`${stylelintVersion}_${JSON.stringify(config || {})}`);\n    fileCache = new FileCache(cacheLocation, cwd, hashOfConfig);\n  } else {\n    // No need to calculate hash here, we just want to delete cache file.\n    fileCache = new FileCache(cacheLocation, cwd); // Remove cache file if cache option is disabled\n\n    fileCache.destroy();\n  }\n\n  const effectiveGlobbyOptions = {\n    cwd,\n    ...(globbyOptions || {}),\n    absolute: true\n  };\n  const globCWD = effectiveGlobbyOptions.cwd;\n  let filePaths = await globby(fileList, effectiveGlobbyOptions); // Record the length of filePaths before ignore operation\n  // Prevent prompting \"No files matching the pattern 'xx' were found.\" when .stylelintignore ignore all input files\n\n  const filePathsLengthBeforeIgnore = filePaths.length; // The ignorer filter needs to check paths relative to cwd\n\n  filePaths = filterFilePaths(ignorer, filePaths.map(p => path.relative(globCWD, p)));\n  let stylelintResults;\n\n  if (filePaths.length) {\n    let absoluteFilePaths = filePaths.map(filePath => {\n      const absoluteFilepath = !path.isAbsolute(filePath) ? path.join(globCWD, filePath) : path.normalize(filePath);\n      return absoluteFilepath;\n    });\n\n    if (useCache) {\n      absoluteFilePaths = absoluteFilePaths.filter(fileCache.hasFileChanged.bind(fileCache));\n    }\n\n    const getStylelintResults = absoluteFilePaths.map(async absoluteFilepath => {\n      debug(`Processing ${absoluteFilepath}`);\n\n      try {\n        const postcssResult = await stylelint._lintSource({\n          filePath: absoluteFilepath\n        });\n\n        if (postcssResult.stylelint.stylelintError && useCache) {\n          debug(`${absoluteFilepath} contains linting errors and will not be cached.`);\n          fileCache.removeEntry(absoluteFilepath);\n        }\n        /**\n         * If we're fixing, save the file with changed code\n         */\n\n\n        if (postcssResult.root && postcssResult.opts && !postcssResult.stylelint.ignored && fix && !postcssResult.stylelint.disableWritingFix) {\n          const fixedCss = postcssResult.root.toString(postcssResult.opts.syntax);\n\n          if (postcssResult.root && postcssResult.root.source && postcssResult.root.source.input.css !== fixedCss) {\n            await writeFileAtomic(absoluteFilepath, fixedCss);\n          }\n        }\n\n        return stylelint._createStylelintResult(postcssResult, absoluteFilepath);\n      } catch (error) {\n        // On any error, we should not cache the lint result\n        fileCache.removeEntry(absoluteFilepath);\n        return handleError(stylelint, error, absoluteFilepath);\n      }\n    });\n    stylelintResults = await Promise.all(getStylelintResults);\n  } else if (allowEmptyInput) {\n    stylelintResults = await Promise.all([]);\n  } else if (filePathsLengthBeforeIgnore) {\n    // All input files ignored\n    stylelintResults = await Promise.reject(new AllFilesIgnoredError());\n  } else {\n    stylelintResults = await Promise.reject(new NoFilesFoundError(fileList));\n  }\n\n  if (useCache) {\n    fileCache.reconcile();\n  }\n\n  const result = prepareReturnValue(stylelintResults, maxWarnings, formatterFunction, cwd);\n  debug(`Linting complete in ${Date.now() - startTime}ms`);\n  return result;\n}\n/**\n * @param {FormatterType | Formatter | undefined} selected\n * @returns {Formatter}\n */\n\n\nfunction getFormatterFunction(selected) {\n  if (typeof selected === 'string') {\n    const formatterFunction = formatters[selected];\n\n    if (formatterFunction === undefined) {\n      throw new Error(`You must use a valid formatter option: ${getFormatterOptionsText()} or a function`);\n    }\n\n    return formatterFunction;\n  }\n\n  if (typeof selected === 'function') {\n    return selected;\n  }\n\n  assert(formatters.json);\n  return formatters.json;\n}\n/**\n * @param {import('stylelint').InternalApi} stylelint\n * @param {any} error\n * @param {string} [filePath]\n * @return {Promise<StylelintResult>}\n */\n\n\nfunction handleError(stylelint, error) {\n  let filePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n\n  if (error.name === 'CssSyntaxError') {\n    return createStylelintResult(stylelint, undefined, filePath, error);\n  }\n\n  throw error;\n}\n\nmodule.exports =\n/** @type {typeof import('stylelint').lint} */\nstandalone;","map":{"version":3,"names":["debug","require","fastGlob","fs","globby","normalizePath","path","createStylelint","createStylelintResult","FileCache","filterFilePaths","formatters","getFileIgnorer","getFormatterOptionsText","hash","NoFilesFoundError","AllFilesIgnoredError","assert","pkg","prepareReturnValue","ALWAYS_IGNORED_GLOBS","writeFileAtomic","standalone","allowEmptyInput","cache","useCache","cacheLocation","code","codeFilename","config","configBasedir","configFile","customSyntax","cwd","process","disableDefaultIgnores","files","fix","formatter","globbyOptions","ignoreDisables","ignorePath","ignorePattern","maxWarnings","quiet","reportDescriptionlessDisables","reportInvalidScopeDisables","reportNeedlessDisables","syntax","fileCache","startTime","Date","now","isValidCode","Promise","reject","Error","ignorer","error","formatterFunction","getFormatterFunction","stylelint","absoluteCodeFilename","undefined","isAbsolute","join","relative","length","stylelintResult","postcssResult","_lintSource","_createStylelintResult","handleError","_postcssResult","returnValue","ignored","ruleDisableFix","output","disableWritingFix","opts","root","toString","fileList","flat","map","entry","globCWD","absolutePath","normalize","existsSync","escapePath","concat","glob","stylelintVersion","version","hashOfConfig","JSON","stringify","destroy","effectiveGlobbyOptions","absolute","filePaths","filePathsLengthBeforeIgnore","p","stylelintResults","absoluteFilePaths","filePath","absoluteFilepath","filter","hasFileChanged","bind","getStylelintResults","stylelintError","removeEntry","fixedCss","source","input","css","all","reconcile","result","selected","json","name","module","exports"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/stylelint/lib/standalone.js"],"sourcesContent":["'use strict';\n\nconst debug = require('debug')('stylelint:standalone');\nconst fastGlob = require('fast-glob');\nconst fs = require('fs');\nconst globby = require('globby');\nconst normalizePath = require('normalize-path');\nconst path = require('path');\n\nconst createStylelint = require('./createStylelint');\nconst createStylelintResult = require('./createStylelintResult');\nconst FileCache = require('./utils/FileCache');\nconst filterFilePaths = require('./utils/filterFilePaths');\nconst formatters = require('./formatters');\nconst getFileIgnorer = require('./utils/getFileIgnorer');\nconst getFormatterOptionsText = require('./utils/getFormatterOptionsText');\nconst hash = require('./utils/hash');\nconst NoFilesFoundError = require('./utils/noFilesFoundError');\nconst AllFilesIgnoredError = require('./utils/allFilesIgnoredError');\nconst { assert } = require('./utils/validateTypes');\nconst pkg = require('../package.json');\nconst prepareReturnValue = require('./prepareReturnValue');\n\nconst ALWAYS_IGNORED_GLOBS = ['**/node_modules/**'];\nconst writeFileAtomic = require('write-file-atomic');\n\n/** @typedef {import('stylelint').LinterOptions} LinterOptions */\n/** @typedef {import('stylelint').LinterResult} LinterResult */\n/** @typedef {import('stylelint').LintResult} StylelintResult */\n/** @typedef {import('stylelint').Formatter} Formatter */\n/** @typedef {import('stylelint').FormatterType} FormatterType */\n\n/**\n *\n * @param {LinterOptions} options\n * @returns {Promise<LinterResult>}\n */\nasync function standalone({\n\tallowEmptyInput = false,\n\tcache: useCache = false,\n\tcacheLocation,\n\tcode,\n\tcodeFilename,\n\tconfig,\n\tconfigBasedir,\n\tconfigFile,\n\tcustomSyntax,\n\tcwd = process.cwd(),\n\tdisableDefaultIgnores,\n\tfiles,\n\tfix,\n\tformatter,\n\tglobbyOptions,\n\tignoreDisables,\n\tignorePath,\n\tignorePattern,\n\tmaxWarnings,\n\tquiet,\n\treportDescriptionlessDisables,\n\treportInvalidScopeDisables,\n\treportNeedlessDisables,\n\tsyntax,\n}) {\n\t/** @type {FileCache} */\n\tlet fileCache;\n\tconst startTime = Date.now();\n\n\tconst isValidCode = typeof code === 'string';\n\n\tif ((!files && !isValidCode) || (files && (code || isValidCode))) {\n\t\treturn Promise.reject(\n\t\t\tnew Error('You must pass stylelint a `files` glob or a `code` string, though not both'),\n\t\t);\n\t}\n\n\t// The ignorer will be used to filter file paths after the glob is checked,\n\t// before any files are actually read\n\n\t/** @type {import('ignore').Ignore} */\n\tlet ignorer;\n\n\ttry {\n\t\tignorer = getFileIgnorer({ cwd, ignorePath, ignorePattern });\n\t} catch (error) {\n\t\treturn Promise.reject(error);\n\t}\n\n\t/** @type {Formatter} */\n\tlet formatterFunction;\n\n\ttry {\n\t\tformatterFunction = getFormatterFunction(formatter);\n\t} catch (error) {\n\t\treturn Promise.reject(error);\n\t}\n\n\tconst stylelint = createStylelint({\n\t\tconfig,\n\t\tconfigFile,\n\t\tconfigBasedir,\n\t\tcwd,\n\t\tignoreDisables,\n\t\tignorePath,\n\t\treportNeedlessDisables,\n\t\treportInvalidScopeDisables,\n\t\treportDescriptionlessDisables,\n\t\tsyntax,\n\t\tcustomSyntax,\n\t\tfix,\n\t\tquiet,\n\t});\n\n\tif (!files) {\n\t\tconst absoluteCodeFilename =\n\t\t\tcodeFilename !== undefined && !path.isAbsolute(codeFilename)\n\t\t\t\t? path.join(cwd, codeFilename)\n\t\t\t\t: codeFilename;\n\n\t\t// if file is ignored, return nothing\n\t\tif (\n\t\t\tabsoluteCodeFilename &&\n\t\t\t!filterFilePaths(ignorer, [path.relative(cwd, absoluteCodeFilename)]).length\n\t\t) {\n\t\t\treturn prepareReturnValue([], maxWarnings, formatterFunction, cwd);\n\t\t}\n\n\t\tlet stylelintResult;\n\n\t\ttry {\n\t\t\tconst postcssResult = await stylelint._lintSource({\n\t\t\t\tcode,\n\t\t\t\tcodeFilename: absoluteCodeFilename,\n\t\t\t});\n\n\t\t\tstylelintResult = await stylelint._createStylelintResult(postcssResult, absoluteCodeFilename);\n\t\t} catch (error) {\n\t\t\tstylelintResult = await handleError(stylelint, error);\n\t\t}\n\n\t\tconst postcssResult = stylelintResult._postcssResult;\n\t\tconst returnValue = prepareReturnValue([stylelintResult], maxWarnings, formatterFunction, cwd);\n\n\t\tif (\n\t\t\tfix &&\n\t\t\tpostcssResult &&\n\t\t\t!postcssResult.stylelint.ignored &&\n\t\t\t!postcssResult.stylelint.ruleDisableFix\n\t\t) {\n\t\t\treturnValue.output =\n\t\t\t\t!postcssResult.stylelint.disableWritingFix && postcssResult.opts\n\t\t\t\t\t? // If we're fixing, the output should be the fixed code\n\t\t\t\t\t  postcssResult.root.toString(postcssResult.opts.syntax)\n\t\t\t\t\t: // If the writing of the fix is disabled, the input code is returned as-is\n\t\t\t\t\t  code;\n\t\t}\n\n\t\treturn returnValue;\n\t}\n\n\tlet fileList = [files].flat().map((entry) => {\n\t\tconst globCWD = (globbyOptions && globbyOptions.cwd) || cwd;\n\t\tconst absolutePath = !path.isAbsolute(entry)\n\t\t\t? path.join(globCWD, entry)\n\t\t\t: path.normalize(entry);\n\n\t\tif (fs.existsSync(absolutePath)) {\n\t\t\t// This path points to a file. Return an escaped path to avoid globbing\n\t\t\treturn fastGlob.escapePath(normalizePath(entry));\n\t\t}\n\n\t\treturn entry;\n\t});\n\n\tif (!disableDefaultIgnores) {\n\t\tfileList = fileList.concat(ALWAYS_IGNORED_GLOBS.map((glob) => `!${glob}`));\n\t}\n\n\tif (useCache) {\n\t\tconst stylelintVersion = pkg.version;\n\t\tconst hashOfConfig = hash(`${stylelintVersion}_${JSON.stringify(config || {})}`);\n\n\t\tfileCache = new FileCache(cacheLocation, cwd, hashOfConfig);\n\t} else {\n\t\t// No need to calculate hash here, we just want to delete cache file.\n\t\tfileCache = new FileCache(cacheLocation, cwd);\n\t\t// Remove cache file if cache option is disabled\n\t\tfileCache.destroy();\n\t}\n\n\tconst effectiveGlobbyOptions = {\n\t\tcwd,\n\t\t...(globbyOptions || {}),\n\t\tabsolute: true,\n\t};\n\n\tconst globCWD = effectiveGlobbyOptions.cwd;\n\n\tlet filePaths = await globby(fileList, effectiveGlobbyOptions);\n\t// Record the length of filePaths before ignore operation\n\t// Prevent prompting \"No files matching the pattern 'xx' were found.\" when .stylelintignore ignore all input files\n\tconst filePathsLengthBeforeIgnore = filePaths.length;\n\n\t// The ignorer filter needs to check paths relative to cwd\n\tfilePaths = filterFilePaths(\n\t\tignorer,\n\t\tfilePaths.map((p) => path.relative(globCWD, p)),\n\t);\n\n\tlet stylelintResults;\n\n\tif (filePaths.length) {\n\t\tlet absoluteFilePaths = filePaths.map((filePath) => {\n\t\t\tconst absoluteFilepath = !path.isAbsolute(filePath)\n\t\t\t\t? path.join(globCWD, filePath)\n\t\t\t\t: path.normalize(filePath);\n\n\t\t\treturn absoluteFilepath;\n\t\t});\n\n\t\tif (useCache) {\n\t\t\tabsoluteFilePaths = absoluteFilePaths.filter(fileCache.hasFileChanged.bind(fileCache));\n\t\t}\n\n\t\tconst getStylelintResults = absoluteFilePaths.map(async (absoluteFilepath) => {\n\t\t\tdebug(`Processing ${absoluteFilepath}`);\n\n\t\t\ttry {\n\t\t\t\tconst postcssResult = await stylelint._lintSource({\n\t\t\t\t\tfilePath: absoluteFilepath,\n\t\t\t\t});\n\n\t\t\t\tif (postcssResult.stylelint.stylelintError && useCache) {\n\t\t\t\t\tdebug(`${absoluteFilepath} contains linting errors and will not be cached.`);\n\t\t\t\t\tfileCache.removeEntry(absoluteFilepath);\n\t\t\t\t}\n\n\t\t\t\t/**\n\t\t\t\t * If we're fixing, save the file with changed code\n\t\t\t\t */\n\t\t\t\tif (\n\t\t\t\t\tpostcssResult.root &&\n\t\t\t\t\tpostcssResult.opts &&\n\t\t\t\t\t!postcssResult.stylelint.ignored &&\n\t\t\t\t\tfix &&\n\t\t\t\t\t!postcssResult.stylelint.disableWritingFix\n\t\t\t\t) {\n\t\t\t\t\tconst fixedCss = postcssResult.root.toString(postcssResult.opts.syntax);\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tpostcssResult.root &&\n\t\t\t\t\t\tpostcssResult.root.source &&\n\t\t\t\t\t\tpostcssResult.root.source.input.css !== fixedCss\n\t\t\t\t\t) {\n\t\t\t\t\t\tawait writeFileAtomic(absoluteFilepath, fixedCss);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn stylelint._createStylelintResult(postcssResult, absoluteFilepath);\n\t\t\t} catch (error) {\n\t\t\t\t// On any error, we should not cache the lint result\n\t\t\t\tfileCache.removeEntry(absoluteFilepath);\n\n\t\t\t\treturn handleError(stylelint, error, absoluteFilepath);\n\t\t\t}\n\t\t});\n\n\t\tstylelintResults = await Promise.all(getStylelintResults);\n\t} else if (allowEmptyInput) {\n\t\tstylelintResults = await Promise.all([]);\n\t} else if (filePathsLengthBeforeIgnore) {\n\t\t// All input files ignored\n\t\tstylelintResults = await Promise.reject(new AllFilesIgnoredError());\n\t} else {\n\t\tstylelintResults = await Promise.reject(new NoFilesFoundError(fileList));\n\t}\n\n\tif (useCache) {\n\t\tfileCache.reconcile();\n\t}\n\n\tconst result = prepareReturnValue(stylelintResults, maxWarnings, formatterFunction, cwd);\n\n\tdebug(`Linting complete in ${Date.now() - startTime}ms`);\n\n\treturn result;\n}\n\n/**\n * @param {FormatterType | Formatter | undefined} selected\n * @returns {Formatter}\n */\nfunction getFormatterFunction(selected) {\n\tif (typeof selected === 'string') {\n\t\tconst formatterFunction = formatters[selected];\n\n\t\tif (formatterFunction === undefined) {\n\t\t\tthrow new Error(\n\t\t\t\t`You must use a valid formatter option: ${getFormatterOptionsText()} or a function`,\n\t\t\t);\n\t\t}\n\n\t\treturn formatterFunction;\n\t}\n\n\tif (typeof selected === 'function') {\n\t\treturn selected;\n\t}\n\n\tassert(formatters.json);\n\n\treturn formatters.json;\n}\n\n/**\n * @param {import('stylelint').InternalApi} stylelint\n * @param {any} error\n * @param {string} [filePath]\n * @return {Promise<StylelintResult>}\n */\nfunction handleError(stylelint, error, filePath = undefined) {\n\tif (error.name === 'CssSyntaxError') {\n\t\treturn createStylelintResult(stylelint, undefined, filePath, error);\n\t}\n\n\tthrow error;\n}\n\nmodule.exports = /** @type {typeof import('stylelint').lint} */ (standalone);\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}