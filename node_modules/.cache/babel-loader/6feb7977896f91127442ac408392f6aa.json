{"ast":null,"code":"'use strict';\n\nconst arrayEqual = require('./arrayEqual');\n\nconst {\n  isPlainObject\n} = require('./validateTypes');\n\nconst IGNORED_OPTIONS = new Set(['severity', 'message', 'reportDisables', 'disableFix']);\n/** @typedef {import('stylelint').RuleOptions} RuleOptions */\n\n/** @typedef {import('stylelint').RuleOptionsPossible} Possible */\n\n/** @typedef {import('stylelint').RuleOptionsPossibleFunc} PossibleFunc */\n\n/**\n * Validate a rule's options.\n *\n * See existing rules for examples.\n *\n * @param {import('stylelint').PostcssResult} result - postcss result\n * @param {string} ruleName\n * @param {...RuleOptions} optionDescriptions - Each optionDescription can\n *   have the following properties:\n *   - `actual` (required): the actual passed option value or object.\n *   - `possible` (required): a schema representation of what values are\n *      valid for those options. `possible` should be an object if the\n *      options are an object, with corresponding keys; if the options are not an\n *      object, `possible` isn't, either. All `possible` value representations\n *      should be **arrays of either values or functions**. Values are === checked\n *      against `actual`. Functions are fed `actual` as an argument and their\n *      return value is interpreted: truthy = valid, falsy = invalid.\n *    - `optional` (optional): If this is `true`, `actual` can be undefined.\n * @return {boolean} Whether or not the options are valid (true = valid)\n */\n\nfunction validateOptions(result, ruleName) {\n  let noErrors = true;\n\n  for (var _len = arguments.length, optionDescriptions = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    optionDescriptions[_key - 2] = arguments[_key];\n  }\n\n  for (const optionDescription of optionDescriptions) {\n    validate(optionDescription, ruleName, complain);\n  }\n  /**\n   * @param {string} message\n   */\n\n\n  function complain(message) {\n    noErrors = false;\n    result.warn(message, {\n      stylelintType: 'invalidOption'\n    });\n    result.stylelint = result.stylelint || {\n      disabledRanges: {},\n      ruleSeverities: {},\n      customMessages: {},\n      ruleMetadata: {}\n    };\n    result.stylelint.stylelintError = true;\n  }\n\n  return noErrors;\n}\n/**\n * @param {RuleOptions} opts\n * @param {string} ruleName\n * @param {(message: string) => void} complain\n */\n\n\nfunction validate(opts, ruleName, complain) {\n  const possible = opts.possible;\n  const actual = opts.actual;\n  const optional = opts.optional;\n\n  if (actual === false && !ruleName.startsWith('report')) {\n    return complain(`Invalid option value \"false\" for rule \"${ruleName}\". Are you trying to disable this rule? If so use \"null\" instead`);\n  }\n\n  if (actual === null || arrayEqual(actual, [null])) {\n    return;\n  }\n\n  const nothingPossible = possible === undefined || Array.isArray(possible) && possible.length === 0;\n\n  if (nothingPossible && actual === true) {\n    return;\n  }\n\n  if (actual === undefined) {\n    if (nothingPossible || optional) {\n      return;\n    }\n\n    complain(`Expected option value for rule \"${ruleName}\"`);\n    return;\n  }\n\n  if (nothingPossible) {\n    if (optional) {\n      complain(`Incorrect configuration for rule \"${ruleName}\". Rule should have \"possible\" values for options validation`);\n      return;\n    }\n\n    complain(`Unexpected option value ${stringify(actual)} for rule \"${ruleName}\"`);\n    return;\n  }\n\n  if (typeof possible === 'function') {\n    if (!possible(actual)) {\n      complain(`Invalid option ${stringify(actual)} for rule \"${ruleName}\"`);\n    }\n\n    return;\n  } // If `possible` is an array instead of an object ...\n\n\n  if (Array.isArray(possible)) {\n    for (const a of [actual].flat()) {\n      if (isValid(possible, a)) {\n        continue;\n      }\n\n      complain(`Invalid option value ${stringify(a)} for rule \"${ruleName}\"`);\n    }\n\n    return;\n  } // If actual is NOT an object ...\n\n\n  if (!isPlainObject(actual) || typeof actual !== 'object' || actual == null) {\n    complain(`Invalid option value ${stringify(actual)} for rule \"${ruleName}\": should be an object`);\n    return;\n  }\n\n  for (const [optionName, optionValue] of Object.entries(actual)) {\n    if (IGNORED_OPTIONS.has(optionName)) {\n      continue;\n    }\n\n    const possibleValue = possible && possible[optionName];\n\n    if (!possibleValue) {\n      complain(`Invalid option name \"${optionName}\" for rule \"${ruleName}\"`);\n      continue;\n    }\n\n    for (const a of [optionValue].flat()) {\n      if (isValid(possibleValue, a)) {\n        continue;\n      }\n\n      complain(`Invalid value ${stringify(a)} for option \"${optionName}\" of rule \"${ruleName}\"`);\n    }\n  }\n}\n/**\n * @param {Possible | Possible[]} possible\n * @param {unknown} actual\n * @returns {boolean}\n */\n\n\nfunction isValid(possible, actual) {\n  for (const possibility of [possible].flat()) {\n    if (typeof possibility === 'function' && possibility(actual)) {\n      return true;\n    }\n\n    if (actual === possibility) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * @param {unknown} value\n * @returns {string}\n */\n\n\nfunction stringify(value) {\n  if (typeof value === 'string') {\n    return `\"${value}\"`;\n  }\n\n  return `\"${JSON.stringify(value)}\"`;\n}\n\nmodule.exports =\n/** @type {typeof import('stylelint').utils.validateOptions} */\nvalidateOptions;","map":{"version":3,"names":["arrayEqual","require","isPlainObject","IGNORED_OPTIONS","Set","validateOptions","result","ruleName","noErrors","optionDescriptions","optionDescription","validate","complain","message","warn","stylelintType","stylelint","disabledRanges","ruleSeverities","customMessages","ruleMetadata","stylelintError","opts","possible","actual","optional","startsWith","nothingPossible","undefined","Array","isArray","length","stringify","a","flat","isValid","optionName","optionValue","Object","entries","has","possibleValue","possibility","value","JSON","module","exports"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/stylelint/lib/utils/validateOptions.js"],"sourcesContent":["'use strict';\n\nconst arrayEqual = require('./arrayEqual');\nconst { isPlainObject } = require('./validateTypes');\n\nconst IGNORED_OPTIONS = new Set(['severity', 'message', 'reportDisables', 'disableFix']);\n\n/** @typedef {import('stylelint').RuleOptions} RuleOptions */\n/** @typedef {import('stylelint').RuleOptionsPossible} Possible */\n/** @typedef {import('stylelint').RuleOptionsPossibleFunc} PossibleFunc */\n\n/**\n * Validate a rule's options.\n *\n * See existing rules for examples.\n *\n * @param {import('stylelint').PostcssResult} result - postcss result\n * @param {string} ruleName\n * @param {...RuleOptions} optionDescriptions - Each optionDescription can\n *   have the following properties:\n *   - `actual` (required): the actual passed option value or object.\n *   - `possible` (required): a schema representation of what values are\n *      valid for those options. `possible` should be an object if the\n *      options are an object, with corresponding keys; if the options are not an\n *      object, `possible` isn't, either. All `possible` value representations\n *      should be **arrays of either values or functions**. Values are === checked\n *      against `actual`. Functions are fed `actual` as an argument and their\n *      return value is interpreted: truthy = valid, falsy = invalid.\n *    - `optional` (optional): If this is `true`, `actual` can be undefined.\n * @return {boolean} Whether or not the options are valid (true = valid)\n */\nfunction validateOptions(result, ruleName, ...optionDescriptions) {\n\tlet noErrors = true;\n\n\tfor (const optionDescription of optionDescriptions) {\n\t\tvalidate(optionDescription, ruleName, complain);\n\t}\n\n\t/**\n\t * @param {string} message\n\t */\n\tfunction complain(message) {\n\t\tnoErrors = false;\n\t\tresult.warn(message, {\n\t\t\tstylelintType: 'invalidOption',\n\t\t});\n\t\tresult.stylelint = result.stylelint || {\n\t\t\tdisabledRanges: {},\n\t\t\truleSeverities: {},\n\t\t\tcustomMessages: {},\n\t\t\truleMetadata: {},\n\t\t};\n\t\tresult.stylelint.stylelintError = true;\n\t}\n\n\treturn noErrors;\n}\n\n/**\n * @param {RuleOptions} opts\n * @param {string} ruleName\n * @param {(message: string) => void} complain\n */\nfunction validate(opts, ruleName, complain) {\n\tconst possible = opts.possible;\n\tconst actual = opts.actual;\n\tconst optional = opts.optional;\n\n\tif (actual === false && !ruleName.startsWith('report')) {\n\t\treturn complain(\n\t\t\t`Invalid option value \"false\" for rule \"${ruleName}\". Are you trying to disable this rule? If so use \"null\" instead`,\n\t\t);\n\t}\n\n\tif (actual === null || arrayEqual(actual, [null])) {\n\t\treturn;\n\t}\n\n\tconst nothingPossible =\n\t\tpossible === undefined || (Array.isArray(possible) && possible.length === 0);\n\n\tif (nothingPossible && actual === true) {\n\t\treturn;\n\t}\n\n\tif (actual === undefined) {\n\t\tif (nothingPossible || optional) {\n\t\t\treturn;\n\t\t}\n\n\t\tcomplain(`Expected option value for rule \"${ruleName}\"`);\n\n\t\treturn;\n\t}\n\n\tif (nothingPossible) {\n\t\tif (optional) {\n\t\t\tcomplain(\n\t\t\t\t`Incorrect configuration for rule \"${ruleName}\". Rule should have \"possible\" values for options validation`,\n\t\t\t);\n\n\t\t\treturn;\n\t\t}\n\n\t\tcomplain(`Unexpected option value ${stringify(actual)} for rule \"${ruleName}\"`);\n\n\t\treturn;\n\t}\n\n\tif (typeof possible === 'function') {\n\t\tif (!possible(actual)) {\n\t\t\tcomplain(`Invalid option ${stringify(actual)} for rule \"${ruleName}\"`);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// If `possible` is an array instead of an object ...\n\tif (Array.isArray(possible)) {\n\t\tfor (const a of [actual].flat()) {\n\t\t\tif (isValid(possible, a)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcomplain(`Invalid option value ${stringify(a)} for rule \"${ruleName}\"`);\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// If actual is NOT an object ...\n\tif (!isPlainObject(actual) || typeof actual !== 'object' || actual == null) {\n\t\tcomplain(\n\t\t\t`Invalid option value ${stringify(actual)} for rule \"${ruleName}\": should be an object`,\n\t\t);\n\n\t\treturn;\n\t}\n\n\tfor (const [optionName, optionValue] of Object.entries(actual)) {\n\t\tif (IGNORED_OPTIONS.has(optionName)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst possibleValue = possible && possible[optionName];\n\n\t\tif (!possibleValue) {\n\t\t\tcomplain(`Invalid option name \"${optionName}\" for rule \"${ruleName}\"`);\n\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (const a of [optionValue].flat()) {\n\t\t\tif (isValid(possibleValue, a)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tcomplain(`Invalid value ${stringify(a)} for option \"${optionName}\" of rule \"${ruleName}\"`);\n\t\t}\n\t}\n}\n\n/**\n * @param {Possible | Possible[]} possible\n * @param {unknown} actual\n * @returns {boolean}\n */\nfunction isValid(possible, actual) {\n\tfor (const possibility of [possible].flat()) {\n\t\tif (typeof possibility === 'function' && possibility(actual)) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (actual === possibility) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * @param {unknown} value\n * @returns {string}\n */\nfunction stringify(value) {\n\tif (typeof value === 'string') {\n\t\treturn `\"${value}\"`;\n\t}\n\n\treturn `\"${JSON.stringify(value)}\"`;\n}\n\nmodule.exports = /** @type {typeof import('stylelint').utils.validateOptions} */ (validateOptions);\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}