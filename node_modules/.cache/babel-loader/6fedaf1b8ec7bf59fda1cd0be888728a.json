{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\n\nconst path = require(\"path\");\n\nconst globParent = require(\"glob-parent\");\n\nconst micromatch = require(\"micromatch\");\n\nconst GLOBSTAR = '**';\nconst ESCAPE_SYMBOL = '\\\\';\nconst COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\nconst REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[[^[]*]/;\nconst REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\([^(]*\\|[^|]*\\)/;\nconst GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\([^(]*\\)/;\nconst BRACE_EXPANSION_SEPARATORS_RE = /,|\\.\\./;\n\nfunction isStaticPattern(pattern) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return !isDynamicPattern(pattern, options);\n}\n\nexports.isStaticPattern = isStaticPattern;\n\nfunction isDynamicPattern(pattern) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  /**\n   * A special case with an empty string is necessary for matching patterns that start with a forward slash.\n   * An empty string cannot be a dynamic pattern.\n   * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\n   */\n  if (pattern === '') {\n    return false;\n  }\n  /**\n   * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\n   * filepath directly (without read directory).\n   */\n\n\n  if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\n    return true;\n  }\n\n  if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n\n  if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\n    return true;\n  }\n\n  if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {\n    return true;\n  }\n\n  return false;\n}\n\nexports.isDynamicPattern = isDynamicPattern;\n\nfunction hasBraceExpansion(pattern) {\n  const openingBraceIndex = pattern.indexOf('{');\n\n  if (openingBraceIndex === -1) {\n    return false;\n  }\n\n  const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);\n\n  if (closingBraceIndex === -1) {\n    return false;\n  }\n\n  const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);\n  return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);\n}\n\nfunction convertToPositivePattern(pattern) {\n  return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\n}\n\nexports.convertToPositivePattern = convertToPositivePattern;\n\nfunction convertToNegativePattern(pattern) {\n  return '!' + pattern;\n}\n\nexports.convertToNegativePattern = convertToNegativePattern;\n\nfunction isNegativePattern(pattern) {\n  return pattern.startsWith('!') && pattern[1] !== '(';\n}\n\nexports.isNegativePattern = isNegativePattern;\n\nfunction isPositivePattern(pattern) {\n  return !isNegativePattern(pattern);\n}\n\nexports.isPositivePattern = isPositivePattern;\n\nfunction getNegativePatterns(patterns) {\n  return patterns.filter(isNegativePattern);\n}\n\nexports.getNegativePatterns = getNegativePatterns;\n\nfunction getPositivePatterns(patterns) {\n  return patterns.filter(isPositivePattern);\n}\n\nexports.getPositivePatterns = getPositivePatterns;\n/**\n * Returns patterns that can be applied inside the current directory.\n *\n * @example\n * // ['./*', '*', 'a/*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\n\nfunction getPatternsInsideCurrentDirectory(patterns) {\n  return patterns.filter(pattern => !isPatternRelatedToParentDirectory(pattern));\n}\n\nexports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;\n/**\n * Returns patterns to be expanded relative to (outside) the current directory.\n *\n * @example\n * // ['../*', './../*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\n\nfunction getPatternsOutsideCurrentDirectory(patterns) {\n  return patterns.filter(isPatternRelatedToParentDirectory);\n}\n\nexports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;\n\nfunction isPatternRelatedToParentDirectory(pattern) {\n  return pattern.startsWith('..') || pattern.startsWith('./..');\n}\n\nexports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;\n\nfunction getBaseDirectory(pattern) {\n  return globParent(pattern, {\n    flipBackslashes: false\n  });\n}\n\nexports.getBaseDirectory = getBaseDirectory;\n\nfunction hasGlobStar(pattern) {\n  return pattern.includes(GLOBSTAR);\n}\n\nexports.hasGlobStar = hasGlobStar;\n\nfunction endsWithSlashGlobStar(pattern) {\n  return pattern.endsWith('/' + GLOBSTAR);\n}\n\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\n\nfunction isAffectDepthOfReadingPattern(pattern) {\n  const basename = path.basename(pattern);\n  return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\n}\n\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\n\nfunction expandPatternsWithBraceExpansion(patterns) {\n  return patterns.reduce((collection, pattern) => {\n    return collection.concat(expandBraceExpansion(pattern));\n  }, []);\n}\n\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\n\nfunction expandBraceExpansion(pattern) {\n  return micromatch.braces(pattern, {\n    expand: true,\n    nodupes: true\n  });\n}\n\nexports.expandBraceExpansion = expandBraceExpansion;\n\nfunction getPatternParts(pattern, options) {\n  let {\n    parts\n  } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), {\n    parts: true\n  }));\n  /**\n   * The scan method returns an empty array in some cases.\n   * See micromatch/picomatch#58 for more details.\n   */\n\n  if (parts.length === 0) {\n    parts = [pattern];\n  }\n  /**\n   * The scan method does not return an empty part for the pattern with a forward slash.\n   * This is another part of micromatch/picomatch#58.\n   */\n\n\n  if (parts[0].startsWith('/')) {\n    parts[0] = parts[0].slice(1);\n    parts.unshift('');\n  }\n\n  return parts;\n}\n\nexports.getPatternParts = getPatternParts;\n\nfunction makeRe(pattern, options) {\n  return micromatch.makeRe(pattern, options);\n}\n\nexports.makeRe = makeRe;\n\nfunction convertPatternsToRe(patterns, options) {\n  return patterns.map(pattern => makeRe(pattern, options));\n}\n\nexports.convertPatternsToRe = convertPatternsToRe;\n\nfunction matchAny(entry, patternsRe) {\n  return patternsRe.some(patternRe => patternRe.test(entry));\n}\n\nexports.matchAny = matchAny;","map":{"version":3,"names":["Object","defineProperty","exports","value","matchAny","convertPatternsToRe","makeRe","getPatternParts","expandBraceExpansion","expandPatternsWithBraceExpansion","isAffectDepthOfReadingPattern","endsWithSlashGlobStar","hasGlobStar","getBaseDirectory","isPatternRelatedToParentDirectory","getPatternsOutsideCurrentDirectory","getPatternsInsideCurrentDirectory","getPositivePatterns","getNegativePatterns","isPositivePattern","isNegativePattern","convertToNegativePattern","convertToPositivePattern","isDynamicPattern","isStaticPattern","path","require","globParent","micromatch","GLOBSTAR","ESCAPE_SYMBOL","COMMON_GLOB_SYMBOLS_RE","REGEX_CHARACTER_CLASS_SYMBOLS_RE","REGEX_GROUP_SYMBOLS_RE","GLOB_EXTENSION_SYMBOLS_RE","BRACE_EXPANSION_SEPARATORS_RE","pattern","options","caseSensitiveMatch","includes","test","extglob","braceExpansion","hasBraceExpansion","openingBraceIndex","indexOf","closingBraceIndex","braceContent","slice","startsWith","patterns","filter","flipBackslashes","endsWith","basename","reduce","collection","concat","braces","expand","nodupes","parts","scan","assign","length","unshift","map","entry","patternsRe","some","patternRe"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/fast-glob/out/utils/pattern.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;\nconst path = require(\"path\");\nconst globParent = require(\"glob-parent\");\nconst micromatch = require(\"micromatch\");\nconst GLOBSTAR = '**';\nconst ESCAPE_SYMBOL = '\\\\';\nconst COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;\nconst REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[[^[]*]/;\nconst REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\([^(]*\\|[^|]*\\)/;\nconst GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\([^(]*\\)/;\nconst BRACE_EXPANSION_SEPARATORS_RE = /,|\\.\\./;\nfunction isStaticPattern(pattern, options = {}) {\n    return !isDynamicPattern(pattern, options);\n}\nexports.isStaticPattern = isStaticPattern;\nfunction isDynamicPattern(pattern, options = {}) {\n    /**\n     * A special case with an empty string is necessary for matching patterns that start with a forward slash.\n     * An empty string cannot be a dynamic pattern.\n     * For example, the pattern `/lib/*` will be spread into parts: '', 'lib', '*'.\n     */\n    if (pattern === '') {\n        return false;\n    }\n    /**\n     * When the `caseSensitiveMatch` option is disabled, all patterns must be marked as dynamic, because we cannot check\n     * filepath directly (without read directory).\n     */\n    if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {\n        return true;\n    }\n    if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {\n        return true;\n    }\n    if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {\n        return true;\n    }\n    if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {\n        return true;\n    }\n    return false;\n}\nexports.isDynamicPattern = isDynamicPattern;\nfunction hasBraceExpansion(pattern) {\n    const openingBraceIndex = pattern.indexOf('{');\n    if (openingBraceIndex === -1) {\n        return false;\n    }\n    const closingBraceIndex = pattern.indexOf('}', openingBraceIndex + 1);\n    if (closingBraceIndex === -1) {\n        return false;\n    }\n    const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);\n    return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);\n}\nfunction convertToPositivePattern(pattern) {\n    return isNegativePattern(pattern) ? pattern.slice(1) : pattern;\n}\nexports.convertToPositivePattern = convertToPositivePattern;\nfunction convertToNegativePattern(pattern) {\n    return '!' + pattern;\n}\nexports.convertToNegativePattern = convertToNegativePattern;\nfunction isNegativePattern(pattern) {\n    return pattern.startsWith('!') && pattern[1] !== '(';\n}\nexports.isNegativePattern = isNegativePattern;\nfunction isPositivePattern(pattern) {\n    return !isNegativePattern(pattern);\n}\nexports.isPositivePattern = isPositivePattern;\nfunction getNegativePatterns(patterns) {\n    return patterns.filter(isNegativePattern);\n}\nexports.getNegativePatterns = getNegativePatterns;\nfunction getPositivePatterns(patterns) {\n    return patterns.filter(isPositivePattern);\n}\nexports.getPositivePatterns = getPositivePatterns;\n/**\n * Returns patterns that can be applied inside the current directory.\n *\n * @example\n * // ['./*', '*', 'a/*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\nfunction getPatternsInsideCurrentDirectory(patterns) {\n    return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));\n}\nexports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;\n/**\n * Returns patterns to be expanded relative to (outside) the current directory.\n *\n * @example\n * // ['../*', './../*']\n * getPatternsInsideCurrentDirectory(['./*', '*', 'a/*', '../*', './../*'])\n */\nfunction getPatternsOutsideCurrentDirectory(patterns) {\n    return patterns.filter(isPatternRelatedToParentDirectory);\n}\nexports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;\nfunction isPatternRelatedToParentDirectory(pattern) {\n    return pattern.startsWith('..') || pattern.startsWith('./..');\n}\nexports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;\nfunction getBaseDirectory(pattern) {\n    return globParent(pattern, { flipBackslashes: false });\n}\nexports.getBaseDirectory = getBaseDirectory;\nfunction hasGlobStar(pattern) {\n    return pattern.includes(GLOBSTAR);\n}\nexports.hasGlobStar = hasGlobStar;\nfunction endsWithSlashGlobStar(pattern) {\n    return pattern.endsWith('/' + GLOBSTAR);\n}\nexports.endsWithSlashGlobStar = endsWithSlashGlobStar;\nfunction isAffectDepthOfReadingPattern(pattern) {\n    const basename = path.basename(pattern);\n    return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);\n}\nexports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;\nfunction expandPatternsWithBraceExpansion(patterns) {\n    return patterns.reduce((collection, pattern) => {\n        return collection.concat(expandBraceExpansion(pattern));\n    }, []);\n}\nexports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;\nfunction expandBraceExpansion(pattern) {\n    return micromatch.braces(pattern, {\n        expand: true,\n        nodupes: true\n    });\n}\nexports.expandBraceExpansion = expandBraceExpansion;\nfunction getPatternParts(pattern, options) {\n    let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));\n    /**\n     * The scan method returns an empty array in some cases.\n     * See micromatch/picomatch#58 for more details.\n     */\n    if (parts.length === 0) {\n        parts = [pattern];\n    }\n    /**\n     * The scan method does not return an empty part for the pattern with a forward slash.\n     * This is another part of micromatch/picomatch#58.\n     */\n    if (parts[0].startsWith('/')) {\n        parts[0] = parts[0].slice(1);\n        parts.unshift('');\n    }\n    return parts;\n}\nexports.getPatternParts = getPatternParts;\nfunction makeRe(pattern, options) {\n    return micromatch.makeRe(pattern, options);\n}\nexports.makeRe = makeRe;\nfunction convertPatternsToRe(patterns, options) {\n    return patterns.map((pattern) => makeRe(pattern, options));\n}\nexports.convertPatternsToRe = convertPatternsToRe;\nfunction matchAny(entry, patternsRe) {\n    return patternsRe.some((patternRe) => patternRe.test(entry));\n}\nexports.matchAny = matchAny;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}