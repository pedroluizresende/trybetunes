{"ast":null,"code":"'use strict';\n\nconst rules = require('./rules');\n\nconst {\n  isPlainObject\n} = require('./utils/validateTypes'); // Rule settings can take a number of forms, e.g.\n// a. \"rule-name\": null\n// b. \"rule-name\": [null, ...]\n// c. \"rule-name\": primaryOption\n// d. \"rule-name\": [primaryOption]\n// e. \"rule-name\": [primaryOption, secondaryOption]\n// Where primaryOption can be anything: primitive, Object, or Array.\n\n/**\n * This function normalizes all the possibilities into the\n * standard form: [primaryOption, secondaryOption]\n * Except in the cases with null, a & b, in which case\n * null is returned\n * @template T\n * @template {Object} O\n * @param {import('stylelint').ConfigRuleSettings<T, O>} rawSettings\n * @param {string} ruleName\n * @param {boolean} [primaryOptionArray] If primaryOptionArray is not provided, we try to get it from the rules themselves, which will not work for plugins\n * @return {[T] | [T, O] | null}\n */\n\n\nmodule.exports = function normalizeRuleSettings(rawSettings, ruleName, // If primaryOptionArray is not provided, we try to get it from the\n// rules themselves, which will not work for plugins\nprimaryOptionArray) {\n  if (rawSettings === null || rawSettings === undefined) {\n    return null;\n  }\n\n  if (!Array.isArray(rawSettings)) {\n    return [rawSettings];\n  } // Everything below is an array ...\n\n\n  if (rawSettings.length > 0 && (rawSettings[0] === null || rawSettings[0] === undefined)) {\n    return null;\n  }\n\n  if (primaryOptionArray === undefined) {\n    const rule = rules[ruleName];\n\n    if (rule && 'primaryOptionArray' in rule) {\n      primaryOptionArray = rule.primaryOptionArray;\n    }\n  }\n\n  if (!primaryOptionArray) {\n    return rawSettings;\n  } // Everything below is a rule that CAN have an array for a primary option ...\n  // (they might also have something else, e.g. rule-properties-order can\n  // have the string \"alphabetical\")\n\n\n  if (rawSettings.length === 1 && Array.isArray(rawSettings[0])) {\n    return rawSettings;\n  }\n\n  if (rawSettings.length === 2 && !isPlainObject(rawSettings[0]) && isPlainObject(rawSettings[1])) {\n    return rawSettings;\n  } // `T` must be an array type, but TSC thinks it's probably invalid to\n  // cast `[T]` to `T` so we cast through `any` first.\n\n\n  return [\n  /** @type {T} */\n\n  /** @type {any} */\n  rawSettings];\n};","map":{"version":3,"names":["rules","require","isPlainObject","module","exports","normalizeRuleSettings","rawSettings","ruleName","primaryOptionArray","undefined","Array","isArray","length","rule"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/stylelint/lib/normalizeRuleSettings.js"],"sourcesContent":["'use strict';\n\nconst rules = require('./rules');\nconst { isPlainObject } = require('./utils/validateTypes');\n\n// Rule settings can take a number of forms, e.g.\n// a. \"rule-name\": null\n// b. \"rule-name\": [null, ...]\n// c. \"rule-name\": primaryOption\n// d. \"rule-name\": [primaryOption]\n// e. \"rule-name\": [primaryOption, secondaryOption]\n// Where primaryOption can be anything: primitive, Object, or Array.\n\n/**\n * This function normalizes all the possibilities into the\n * standard form: [primaryOption, secondaryOption]\n * Except in the cases with null, a & b, in which case\n * null is returned\n * @template T\n * @template {Object} O\n * @param {import('stylelint').ConfigRuleSettings<T, O>} rawSettings\n * @param {string} ruleName\n * @param {boolean} [primaryOptionArray] If primaryOptionArray is not provided, we try to get it from the rules themselves, which will not work for plugins\n * @return {[T] | [T, O] | null}\n */\nmodule.exports = function normalizeRuleSettings(\n\trawSettings,\n\truleName,\n\t// If primaryOptionArray is not provided, we try to get it from the\n\t// rules themselves, which will not work for plugins\n\tprimaryOptionArray,\n) {\n\tif (rawSettings === null || rawSettings === undefined) {\n\t\treturn null;\n\t}\n\n\tif (!Array.isArray(rawSettings)) {\n\t\treturn [rawSettings];\n\t}\n\t// Everything below is an array ...\n\n\tif (rawSettings.length > 0 && (rawSettings[0] === null || rawSettings[0] === undefined)) {\n\t\treturn null;\n\t}\n\n\tif (primaryOptionArray === undefined) {\n\t\tconst rule = rules[ruleName];\n\n\t\tif (rule && 'primaryOptionArray' in rule) {\n\t\t\tprimaryOptionArray = rule.primaryOptionArray;\n\t\t}\n\t}\n\n\tif (!primaryOptionArray) {\n\t\treturn rawSettings;\n\t}\n\t// Everything below is a rule that CAN have an array for a primary option ...\n\t// (they might also have something else, e.g. rule-properties-order can\n\t// have the string \"alphabetical\")\n\n\tif (rawSettings.length === 1 && Array.isArray(rawSettings[0])) {\n\t\treturn rawSettings;\n\t}\n\n\tif (rawSettings.length === 2 && !isPlainObject(rawSettings[0]) && isPlainObject(rawSettings[1])) {\n\t\treturn rawSettings;\n\t}\n\n\t// `T` must be an array type, but TSC thinks it's probably invalid to\n\t// cast `[T]` to `T` so we cast through `any` first.\n\treturn [/** @type {T} */ (/** @type {any} */ (rawSettings))];\n};\n"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,SAAD,CAArB;;AACA,MAAM;EAAEC;AAAF,IAAoBD,OAAO,CAAC,uBAAD,CAAjC,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAE,MAAM,CAACC,OAAP,GAAiB,SAASC,qBAAT,CAChBC,WADgB,EAEhBC,QAFgB,EAGhB;AACA;AACAC,kBALgB,EAMf;EACD,IAAIF,WAAW,KAAK,IAAhB,IAAwBA,WAAW,KAAKG,SAA5C,EAAuD;IACtD,OAAO,IAAP;EACA;;EAED,IAAI,CAACC,KAAK,CAACC,OAAN,CAAcL,WAAd,CAAL,EAAiC;IAChC,OAAO,CAACA,WAAD,CAAP;EACA,CAPA,CAQD;;;EAEA,IAAIA,WAAW,CAACM,MAAZ,GAAqB,CAArB,KAA2BN,WAAW,CAAC,CAAD,CAAX,KAAmB,IAAnB,IAA2BA,WAAW,CAAC,CAAD,CAAX,KAAmBG,SAAzE,CAAJ,EAAyF;IACxF,OAAO,IAAP;EACA;;EAED,IAAID,kBAAkB,KAAKC,SAA3B,EAAsC;IACrC,MAAMI,IAAI,GAAGb,KAAK,CAACO,QAAD,CAAlB;;IAEA,IAAIM,IAAI,IAAI,wBAAwBA,IAApC,EAA0C;MACzCL,kBAAkB,GAAGK,IAAI,CAACL,kBAA1B;IACA;EACD;;EAED,IAAI,CAACA,kBAAL,EAAyB;IACxB,OAAOF,WAAP;EACA,CAxBA,CAyBD;EACA;EACA;;;EAEA,IAAIA,WAAW,CAACM,MAAZ,KAAuB,CAAvB,IAA4BF,KAAK,CAACC,OAAN,CAAcL,WAAW,CAAC,CAAD,CAAzB,CAAhC,EAA+D;IAC9D,OAAOA,WAAP;EACA;;EAED,IAAIA,WAAW,CAACM,MAAZ,KAAuB,CAAvB,IAA4B,CAACV,aAAa,CAACI,WAAW,CAAC,CAAD,CAAZ,CAA1C,IAA8DJ,aAAa,CAACI,WAAW,CAAC,CAAD,CAAZ,CAA/E,EAAiG;IAChG,OAAOA,WAAP;EACA,CAnCA,CAqCD;EACA;;;EACA,OAAO;EAAC;;EAAkB;EAAoBA,WAAvC,CAAP;AACA,CA9CD"},"metadata":{},"sourceType":"script"}