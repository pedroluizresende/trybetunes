{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = splitExportDeclaration;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  cloneNode,\n  exportNamedDeclaration,\n  exportSpecifier,\n  identifier,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction splitExportDeclaration(exportDeclaration) {\n  if (!exportDeclaration.isExportDeclaration() || exportDeclaration.isExportAllDeclaration()) {\n    throw new Error(\"Only default and named export declarations can be split.\");\n  }\n\n  if (exportDeclaration.isExportDefaultDeclaration()) {\n    const declaration = exportDeclaration.get(\"declaration\");\n    const standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration();\n    const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;\n    let id = declaration.node.id;\n    let needBindingRegistration = false;\n\n    if (!id) {\n      needBindingRegistration = true;\n      id = scope.generateUidIdentifier(\"default\");\n\n      if (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) {\n        declaration.node.id = cloneNode(id);\n      }\n    }\n\n    const updatedDeclaration = standaloneDeclaration ? declaration.node : variableDeclaration(\"var\", [variableDeclarator(cloneNode(id), declaration.node)]);\n    const updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier(\"default\"))]);\n    exportDeclaration.insertAfter(updatedExportDeclaration);\n    exportDeclaration.replaceWith(updatedDeclaration);\n\n    if (needBindingRegistration) {\n      scope.registerDeclaration(exportDeclaration);\n    }\n\n    return exportDeclaration;\n  } else if (exportDeclaration.get(\"specifiers\").length > 0) {\n    throw new Error(\"It doesn't make sense to split exported specifiers.\");\n  }\n\n  const declaration = exportDeclaration.get(\"declaration\");\n  const bindingIdentifiers = declaration.getOuterBindingIdentifiers();\n  const specifiers = Object.keys(bindingIdentifiers).map(name => {\n    return exportSpecifier(identifier(name), identifier(name));\n  });\n  const aliasDeclar = exportNamedDeclaration(null, specifiers);\n  exportDeclaration.insertAfter(aliasDeclar);\n  exportDeclaration.replaceWith(declaration.node);\n  return exportDeclaration;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","splitExportDeclaration","_t","require","cloneNode","exportNamedDeclaration","exportSpecifier","identifier","variableDeclaration","variableDeclarator","exportDeclaration","isExportDeclaration","isExportAllDeclaration","Error","isExportDefaultDeclaration","declaration","get","standaloneDeclaration","isFunctionDeclaration","isClassDeclaration","scope","isScope","parent","id","node","needBindingRegistration","generateUidIdentifier","isFunctionExpression","isClassExpression","updatedDeclaration","updatedExportDeclaration","insertAfter","replaceWith","registerDeclaration","length","bindingIdentifiers","getOuterBindingIdentifiers","specifiers","keys","map","name","aliasDeclar"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/@babel/helper-split-export-declaration/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = splitExportDeclaration;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  cloneNode,\n  exportNamedDeclaration,\n  exportSpecifier,\n  identifier,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction splitExportDeclaration(exportDeclaration) {\n  if (!exportDeclaration.isExportDeclaration() || exportDeclaration.isExportAllDeclaration()) {\n    throw new Error(\"Only default and named export declarations can be split.\");\n  }\n\n  if (exportDeclaration.isExportDefaultDeclaration()) {\n    const declaration = exportDeclaration.get(\"declaration\");\n    const standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration();\n    const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;\n    let id = declaration.node.id;\n    let needBindingRegistration = false;\n\n    if (!id) {\n      needBindingRegistration = true;\n      id = scope.generateUidIdentifier(\"default\");\n\n      if (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) {\n        declaration.node.id = cloneNode(id);\n      }\n    }\n\n    const updatedDeclaration = standaloneDeclaration ? declaration.node : variableDeclaration(\"var\", [variableDeclarator(cloneNode(id), declaration.node)]);\n    const updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier(\"default\"))]);\n    exportDeclaration.insertAfter(updatedExportDeclaration);\n    exportDeclaration.replaceWith(updatedDeclaration);\n\n    if (needBindingRegistration) {\n      scope.registerDeclaration(exportDeclaration);\n    }\n\n    return exportDeclaration;\n  } else if (exportDeclaration.get(\"specifiers\").length > 0) {\n    throw new Error(\"It doesn't make sense to split exported specifiers.\");\n  }\n\n  const declaration = exportDeclaration.get(\"declaration\");\n  const bindingIdentifiers = declaration.getOuterBindingIdentifiers();\n  const specifiers = Object.keys(bindingIdentifiers).map(name => {\n    return exportSpecifier(identifier(name), identifier(name));\n  });\n  const aliasDeclar = exportNamedDeclaration(null, specifiers);\n  exportDeclaration.insertAfter(aliasDeclar);\n  exportDeclaration.replaceWith(declaration.node);\n  return exportDeclaration;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}