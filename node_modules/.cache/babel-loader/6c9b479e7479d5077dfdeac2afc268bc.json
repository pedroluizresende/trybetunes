{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nvar Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nvar Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nvar defaultTagPrefix = 'tag:yaml.org,2002:';\nvar defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\n\nfunction findLineStarts(src) {\n  var ls = [0];\n  var offset = src.indexOf('\\n');\n\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n\n  return ls;\n}\n\nfunction getSrcInfo(cst) {\n  var lineStarts, src;\n\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n\n  return {\n    lineStarts: lineStarts,\n    src: src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n\n  var _getSrcInfo = getSrcInfo(cst),\n      lineStarts = _getSrcInfo.lineStarts,\n      src = _getSrcInfo.src;\n\n  if (!lineStarts || !src || offset > src.length) return null;\n\n  for (var i = 0; i < lineStarts.length; ++i) {\n    var start = lineStarts[i];\n\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n\n  var line = lineStarts.length;\n  return {\n    line: line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\n\nfunction getLine(line, cst) {\n  var _getSrcInfo2 = getSrcInfo(cst),\n      lineStarts = _getSrcInfo2.lineStarts,\n      src = _getSrcInfo2.src;\n\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  var start = lineStarts[line - 1];\n  var end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') {\n    --end;\n  }\n\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `…` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\n\nfunction getPrettyContext(_ref, cst) {\n  var start = _ref.start,\n      end = _ref.end;\n  var maxWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 80;\n  var src = getLine(start.line, cst);\n  if (!src) return null;\n  var col = start.col;\n\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '…';\n    } else {\n      var halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '…';\n      col -= src.length - maxWidth;\n      src = '…' + src.substr(1 - maxWidth);\n    }\n  }\n\n  var errLen = 1;\n  var errEnd = '';\n\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '…';\n    }\n  }\n\n  var offset = col > 1 ? ' '.repeat(col - 1) : '';\n  var err = '^'.repeat(errLen);\n  return \"\".concat(src, \"\\n\").concat(offset).concat(err).concat(errEnd);\n}\n\nvar Range = /*#__PURE__*/function () {\n  function Range(start, end) {\n    _classCallCheck(this, Range);\n\n    this.start = start;\n    this.end = end || start;\n  }\n\n  _createClass(Range, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n    }\n    /**\n     * Set `origStart` and `origEnd` to point to the original source range for\n     * this node, which may differ due to dropped CR characters.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRange\",\n    value: function setOrigRange(cr, offset) {\n      var start = this.start,\n          end = this.end;\n\n      if (cr.length === 0 || end <= cr[0]) {\n        this.origStart = start;\n        this.origEnd = end;\n        return offset;\n      }\n\n      var i = offset;\n\n      while (i < cr.length) {\n        if (cr[i] > start) break;else ++i;\n      }\n\n      this.origStart = start + i;\n      var nextOffset = i;\n\n      while (i < cr.length) {\n        // if end was at \\n, it should now be at \\r\n        if (cr[i] >= end) break;else ++i;\n      }\n\n      this.origEnd = end + i;\n      return nextOffset;\n    }\n  }], [{\n    key: \"copy\",\n    value: function copy(orig) {\n      return new Range(orig.start, orig.end);\n    }\n  }]);\n\n  return Range;\n}();\n/** Root class of all nodes */\n\n\nvar Node = /*#__PURE__*/function () {\n  function Node(type, props, context) {\n    _classCallCheck(this, Node);\n\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n\n  _createClass(Node, [{\n    key: \"getPropValue\",\n    value: function getPropValue(idx, key, skipKey) {\n      if (!this.context) return null;\n      var src = this.context.src;\n      var prop = this.props[idx];\n      return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n    }\n  }, {\n    key: \"anchor\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var anchor = this.getPropValue(i, Char.ANCHOR, true);\n        if (anchor != null) return anchor;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"comment\",\n    get: function get() {\n      var comments = [];\n\n      for (var i = 0; i < this.props.length; ++i) {\n        var comment = this.getPropValue(i, Char.COMMENT, true);\n        if (comment != null) comments.push(comment);\n      }\n\n      return comments.length > 0 ? comments.join('\\n') : null;\n    }\n  }, {\n    key: \"commentHasRequiredWhitespace\",\n    value: function commentHasRequiredWhitespace(start) {\n      var src = this.context.src;\n      if (this.header && start === this.header.end) return false;\n      if (!this.valueRange) return false;\n      var end = this.valueRange.end;\n      return start !== end || Node.atBlank(src, end - 1);\n    }\n  }, {\n    key: \"hasComment\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] === Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"hasProps\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] !== Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"jsonLike\",\n    get: function get() {\n      var jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n      return jsonLikeTypes.indexOf(this.type) !== -1;\n    }\n  }, {\n    key: \"rangeAsLinePos\",\n    get: function get() {\n      if (!this.range || !this.context) return undefined;\n      var start = getLinePos(this.range.start, this.context.root);\n      if (!start) return undefined;\n      var end = getLinePos(this.range.end, this.context.root);\n      return {\n        start: start,\n        end: end\n      };\n    }\n  }, {\n    key: \"rawValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      return this.context.src.slice(start, end);\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var tag = this.getPropValue(i, Char.TAG, false);\n\n        if (tag != null) {\n          if (tag[1] === '<') {\n            return {\n              verbatim: tag.slice(2, -1)\n            };\n          } else {\n            // eslint-disable-next-line no-unused-vars\n            var _tag$match = tag.match(/^(.*!)([^!]*)$/),\n                _tag$match2 = _slicedToArray(_tag$match, 3);\n\n            _tag$match2[0];\n            var handle = _tag$match2[1],\n                suffix = _tag$match2[2];\n            return {\n              handle: handle,\n              suffix: suffix\n            };\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"valueRangeContainsNewline\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return false;\n      var _this$valueRange2 = this.valueRange,\n          start = _this$valueRange2.start,\n          end = _this$valueRange2.end;\n      var src = this.context.src;\n\n      for (var i = start; i < end; ++i) {\n        if (src[i] === '\\n') return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"parseComment\",\n    value: function parseComment(start) {\n      var src = this.context.src;\n\n      if (src[start] === Char.COMMENT) {\n        var end = Node.endOfLine(src, start + 1);\n        var commentRange = new Range(start, end);\n        this.props.push(commentRange);\n        return end;\n      }\n\n      return start;\n    }\n    /**\n     * Populates the `origStart` and `origEnd` values of all ranges for this\n     * node. Extended by child classes to handle descendant nodes.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      if (this.range) offset = this.range.setOrigRange(cr, offset);\n      if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n      this.props.forEach(function (prop) {\n        return prop.setOrigRange(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }], [{\n    key: \"addStringTerminator\",\n    value: function addStringTerminator(src, offset, str) {\n      if (str[str.length - 1] === '\\n') return str;\n      var next = Node.endOfWhiteSpace(src, offset);\n      return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n    } // ^(---|...)\n\n  }, {\n    key: \"atDocumentBoundary\",\n    value: function atDocumentBoundary(src, offset, sep) {\n      var ch0 = src[offset];\n      if (!ch0) return true;\n      var prev = src[offset - 1];\n      if (prev && prev !== '\\n') return false;\n\n      if (sep) {\n        if (ch0 !== sep) return false;\n      } else {\n        if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n      }\n\n      var ch1 = src[offset + 1];\n      var ch2 = src[offset + 2];\n      if (ch1 !== ch0 || ch2 !== ch0) return false;\n      var ch3 = src[offset + 3];\n      return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n    }\n  }, {\n    key: \"endOfIdentifier\",\n    value: function endOfIdentifier(src, offset) {\n      var ch = src[offset];\n      var isVerbatim = ch === '<';\n      var notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n\n      while (ch && notOk.indexOf(ch) === -1) {\n        ch = src[offset += 1];\n      }\n\n      if (isVerbatim && ch === '>') offset += 1;\n      return offset;\n    }\n  }, {\n    key: \"endOfIndent\",\n    value: function endOfIndent(src, offset) {\n      var ch = src[offset];\n\n      while (ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfLine\",\n    value: function endOfLine(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfWhiteSpace\",\n    value: function endOfWhiteSpace(src, offset) {\n      var ch = src[offset];\n\n      while (ch === '\\t' || ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"startOfLine\",\n    value: function startOfLine(src, offset) {\n      var ch = src[offset - 1];\n      if (ch === '\\n') return offset;\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset -= 1];\n      }\n\n      return offset + 1;\n    }\n    /**\n     * End of indentation, or null if the line's indent level is not more\n     * than `indent`\n     *\n     * @param {string} src\n     * @param {number} indent\n     * @param {number} lineStart\n     * @returns {?number}\n     */\n\n  }, {\n    key: \"endOfBlockIndent\",\n    value: function endOfBlockIndent(src, indent, lineStart) {\n      var inEnd = Node.endOfIndent(src, lineStart);\n\n      if (inEnd > lineStart + indent) {\n        return inEnd;\n      } else {\n        var wsEnd = Node.endOfWhiteSpace(src, inEnd);\n        var ch = src[wsEnd];\n        if (!ch || ch === '\\n') return wsEnd;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"atBlank\",\n    value: function atBlank(src, offset, endAsBlank) {\n      var ch = src[offset];\n      return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n    }\n  }, {\n    key: \"nextNodeIsIndented\",\n    value: function nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n      if (!ch || indentDiff < 0) return false;\n      if (indentDiff > 0) return true;\n      return indicatorAsIndent && ch === '-';\n    } // should be at line or string end, or at next non-whitespace char\n\n  }, {\n    key: \"normalizeOffset\",\n    value: function normalizeOffset(src, offset) {\n      var ch = src[offset];\n      return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n    } // fold single newline into space, multiple newlines to N - 1 newlines\n    // presumes src[offset] === '\\n'\n\n  }, {\n    key: \"foldNewline\",\n    value: function foldNewline(src, offset, indent) {\n      var inCount = 0;\n      var error = false;\n      var fold = '';\n      var ch = src[offset + 1];\n\n      while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n        switch (ch) {\n          case '\\n':\n            inCount = 0;\n            offset += 1;\n            fold += '\\n';\n            break;\n\n          case '\\t':\n            if (inCount <= indent) error = true;\n            offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n            break;\n\n          case ' ':\n            inCount += 1;\n            offset += 1;\n            break;\n        }\n\n        ch = src[offset + 1];\n      }\n\n      if (!fold) fold = ' ';\n      if (ch && inCount <= indent) error = true;\n      return {\n        fold: fold,\n        offset: offset,\n        error: error\n      };\n    }\n  }]);\n\n  return Node;\n}();\n\nvar YAMLError = /*#__PURE__*/function (_Error) {\n  _inherits(YAMLError, _Error);\n\n  var _super = _createSuper(YAMLError);\n\n  function YAMLError(name, source, message) {\n    var _this;\n\n    _classCallCheck(this, YAMLError);\n\n    if (!message || !(source instanceof Node)) throw new Error(\"Invalid arguments for new \".concat(name));\n    _this = _super.call(this);\n    _this.name = name;\n    _this.message = message;\n    _this.source = source;\n    return _this;\n  }\n\n  _createClass(YAMLError, [{\n    key: \"makePretty\",\n    value: function makePretty() {\n      if (!this.source) return;\n      this.nodeType = this.source.type;\n      var cst = this.source.context && this.source.context.root;\n\n      if (typeof this.offset === 'number') {\n        this.range = new Range(this.offset, this.offset + 1);\n        var start = cst && getLinePos(this.offset, cst);\n\n        if (start) {\n          var end = {\n            line: start.line,\n            col: start.col + 1\n          };\n          this.linePos = {\n            start: start,\n            end: end\n          };\n        }\n\n        delete this.offset;\n      } else {\n        this.range = this.source.range;\n        this.linePos = this.source.rangeAsLinePos;\n      }\n\n      if (this.linePos) {\n        var _this$linePos$start = this.linePos.start,\n            line = _this$linePos$start.line,\n            col = _this$linePos$start.col;\n        this.message += \" at line \".concat(line, \", column \").concat(col);\n        var ctx = cst && getPrettyContext(this.linePos, cst);\n        if (ctx) this.message += \":\\n\\n\".concat(ctx, \"\\n\");\n      }\n\n      delete this.source;\n    }\n  }]);\n\n  return YAMLError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar YAMLReferenceError = /*#__PURE__*/function (_YAMLError) {\n  _inherits(YAMLReferenceError, _YAMLError);\n\n  var _super2 = _createSuper(YAMLReferenceError);\n\n  function YAMLReferenceError(source, message) {\n    _classCallCheck(this, YAMLReferenceError);\n\n    return _super2.call(this, 'YAMLReferenceError', source, message);\n  }\n\n  return YAMLReferenceError;\n}(YAMLError);\n\nvar YAMLSemanticError = /*#__PURE__*/function (_YAMLError2) {\n  _inherits(YAMLSemanticError, _YAMLError2);\n\n  var _super3 = _createSuper(YAMLSemanticError);\n\n  function YAMLSemanticError(source, message) {\n    _classCallCheck(this, YAMLSemanticError);\n\n    return _super3.call(this, 'YAMLSemanticError', source, message);\n  }\n\n  return YAMLSemanticError;\n}(YAMLError);\n\nvar YAMLSyntaxError = /*#__PURE__*/function (_YAMLError3) {\n  _inherits(YAMLSyntaxError, _YAMLError3);\n\n  var _super4 = _createSuper(YAMLSyntaxError);\n\n  function YAMLSyntaxError(source, message) {\n    _classCallCheck(this, YAMLSyntaxError);\n\n    return _super4.call(this, 'YAMLSyntaxError', source, message);\n  }\n\n  return YAMLSyntaxError;\n}(YAMLError);\n\nvar YAMLWarning = /*#__PURE__*/function (_YAMLError4) {\n  _inherits(YAMLWarning, _YAMLError4);\n\n  var _super5 = _createSuper(YAMLWarning);\n\n  function YAMLWarning(source, message) {\n    _classCallCheck(this, YAMLWarning);\n\n    return _super5.call(this, 'YAMLWarning', source, message);\n  }\n\n  return YAMLWarning;\n}(YAMLError);\n\nvar PlainValue = /*#__PURE__*/function (_Node) {\n  _inherits(PlainValue, _Node);\n\n  var _super = _createSuper(PlainValue);\n\n  function PlainValue() {\n    _classCallCheck(this, PlainValue);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PlainValue, [{\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var src = this.context.src;\n      var ch = src[end - 1];\n\n      while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) {\n        ch = src[--end - 1];\n      }\n\n      var str = '';\n\n      for (var i = start; i < end; ++i) {\n        var _ch = src[i];\n\n        if (_ch === '\\n') {\n          var _Node$foldNewline = Node.foldNewline(src, i, -1),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset;\n\n          str += fold;\n          i = offset;\n        } else if (_ch === ' ' || _ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (i < end && (next === ' ' || next === '\\t')) {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : _ch;\n        } else {\n          str += _ch;\n        }\n      }\n\n      var ch0 = src[start];\n\n      switch (ch0) {\n        case '\\t':\n          {\n            var msg = 'Plain value cannot start with a tab character';\n            var errors = [new YAMLSemanticError(this, msg)];\n            return {\n              errors: errors,\n              str: str\n            };\n          }\n\n        case '@':\n        case '`':\n          {\n            var _msg = \"Plain value cannot start with reserved character \".concat(ch0);\n\n            var _errors = [new YAMLSemanticError(this, _msg)];\n            return {\n              errors: _errors,\n              str: str\n            };\n          }\n\n        default:\n          return str;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          inFlow = _this$context.inFlow,\n          src = _this$context.src;\n      var offset = start;\n      var valueEnd = start;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        if (Node.atDocumentBoundary(src, offset + 1)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset + 1);\n        if (end === null || src[end] === '#') break;\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          valueEnd = PlainValue.endOfLine(src, end, inFlow);\n          offset = valueEnd;\n        }\n      }\n\n      if (this.valueRange.isEmpty()) this.valueRange.start = start;\n      this.valueRange.end = valueEnd;\n      return valueEnd;\n    }\n    /**\n     * Parses a plain value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * #comment\n     *\n     * first line\n     *\n     * first line #comment\n     *\n     * first line\n     * block\n     * lines\n     *\n     * #comment\n     * block\n     * lines\n     * ```\n     * where block lines are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar, may be `\\n`\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var inFlow = context.inFlow,\n          src = context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      if (ch && ch !== '#' && ch !== '\\n') {\n        offset = PlainValue.endOfLine(src, start, inFlow);\n      }\n\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n\n      if (!this.hasComment || this.valueRange.isEmpty()) {\n        offset = this.parseBlockValue(offset);\n      }\n\n      return offset;\n    }\n  }], [{\n    key: \"endOfLine\",\n    value: function endOfLine(src, start, inFlow) {\n      var ch = src[start];\n      var offset = start;\n\n      while (ch && ch !== '\\n') {\n        if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n        var next = src[offset + 1];\n        if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n        if ((ch === ' ' || ch === '\\t') && next === '#') break;\n        offset += 1;\n        ch = next;\n      }\n\n      return offset;\n    }\n  }]);\n\n  return PlainValue;\n}(Node);\n\nexport { Char as C, Node as N, PlainValue as P, Range as R, Type as T, YAMLSyntaxError as Y, _createForOfIteratorHelper as _, _typeof as a, _createClass as b, _classCallCheck as c, defaultTagPrefix as d, _defineProperty as e, YAMLWarning as f, YAMLSemanticError as g, _slicedToArray as h, YAMLError as i, _inherits as j, _createSuper as k, _get as l, _getPrototypeOf as m, defaultTags as n, YAMLReferenceError as o, _assertThisInitialized as p, _toArray as q, _possibleConstructorReturn as r };","map":{"version":3,"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","_defineProperty","value","_inherits","subClass","superClass","create","_setPrototypeOf","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","p","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","valueOf","call","e","_construct","Parent","args","Class","a","push","apply","Function","bind","arguments","_isNativeFunction","fn","toString","indexOf","_wrapNativeSuper","_cache","Map","undefined","has","get","set","Wrapper","_assertThisInitialized","self","ReferenceError","_possibleConstructorReturn","_createSuper","Derived","hasNativeReflectConstruct","_createSuperInternal","Super","result","NewTarget","_superPropBase","object","property","hasOwnProperty","_get","receiver","base","desc","getOwnPropertyDescriptor","_slicedToArray","arr","_arrayWithHoles","_iterableToArrayLimit","_unsupportedIterableToArray","_nonIterableRest","_toArray","_iterableToArray","Array","isArray","iter","from","_arr","_n","_d","_e","_i","_s","next","done","err","minLen","_arrayLikeToArray","n","slice","name","test","len","arr2","_createForOfIteratorHelper","allowArrayLike","it","F","s","f","normalCompletion","didErr","step","return","Char","ANCHOR","COMMENT","TAG","DIRECTIVES_END","DOCUMENT_END","Type","ALIAS","BLANK_LINE","BLOCK_FOLDED","BLOCK_LITERAL","DIRECTIVE","DOCUMENT","FLOW_MAP","FLOW_SEQ","MAP","MAP_KEY","MAP_VALUE","PLAIN","QUOTE_DOUBLE","QUOTE_SINGLE","SEQ","SEQ_ITEM","defaultTagPrefix","defaultTags","STR","findLineStarts","src","ls","offset","getSrcInfo","cst","lineStarts","context","getLinePos","_getSrcInfo","start","line","col","getLine","_getSrcInfo2","end","getPrettyContext","_ref","maxWidth","substr","halfWidth","Math","round","errLen","errEnd","min","repeat","concat","Range","isEmpty","setOrigRange","cr","origStart","origEnd","nextOffset","copy","orig","Node","type","error","range","valueRange","getPropValue","idx","skipKey","prop","anchor","comments","comment","join","commentHasRequiredWhitespace","header","atBlank","jsonLikeTypes","root","_this$valueRange","tag","verbatim","_tag$match","match","_tag$match2","handle","suffix","_this$valueRange2","parseComment","endOfLine","commentRange","setOrigRanges","forEach","str","addStringTerminator","endOfWhiteSpace","atDocumentBoundary","sep","ch0","prev","ch1","ch2","ch3","endOfIdentifier","ch","isVerbatim","notOk","endOfIndent","startOfLine","endOfBlockIndent","indent","lineStart","inEnd","wsEnd","endAsBlank","nextNodeIsIndented","indentDiff","indicatorAsIndent","normalizeOffset","foldNewline","inCount","fold","YAMLError","_Error","_super","source","message","_this","Error","makePretty","nodeType","linePos","rangeAsLinePos","_this$linePos$start","ctx","YAMLReferenceError","_YAMLError","_super2","YAMLSemanticError","_YAMLError2","_super3","YAMLSyntaxError","_YAMLError3","_super4","YAMLWarning","_YAMLError4","_super5","PlainValue","_Node","_ch","_Node$foldNewline","wsStart","msg","errors","_msg","_errors","parseBlockValue","_this$context","inFlow","valueEnd","parse","hasComment","C","N","P","R","T","Y","_","b","c","d","g","h","j","k","l","m","q","r"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/yaml/browser/dist/PlainValue-b8036b75.js"],"sourcesContent":["function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _toArray(arr) {\n  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function () {};\n\n      return {\n        s: F,\n        n: function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function (e) {\n          throw e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function () {\n      it = o[Symbol.iterator]();\n    },\n    n: function () {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function (e) {\n      didErr = true;\n      err = e;\n    },\n    f: function () {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nvar Char = {\n  ANCHOR: '&',\n  COMMENT: '#',\n  TAG: '!',\n  DIRECTIVES_END: '-',\n  DOCUMENT_END: '.'\n};\nvar Type = {\n  ALIAS: 'ALIAS',\n  BLANK_LINE: 'BLANK_LINE',\n  BLOCK_FOLDED: 'BLOCK_FOLDED',\n  BLOCK_LITERAL: 'BLOCK_LITERAL',\n  COMMENT: 'COMMENT',\n  DIRECTIVE: 'DIRECTIVE',\n  DOCUMENT: 'DOCUMENT',\n  FLOW_MAP: 'FLOW_MAP',\n  FLOW_SEQ: 'FLOW_SEQ',\n  MAP: 'MAP',\n  MAP_KEY: 'MAP_KEY',\n  MAP_VALUE: 'MAP_VALUE',\n  PLAIN: 'PLAIN',\n  QUOTE_DOUBLE: 'QUOTE_DOUBLE',\n  QUOTE_SINGLE: 'QUOTE_SINGLE',\n  SEQ: 'SEQ',\n  SEQ_ITEM: 'SEQ_ITEM'\n};\nvar defaultTagPrefix = 'tag:yaml.org,2002:';\nvar defaultTags = {\n  MAP: 'tag:yaml.org,2002:map',\n  SEQ: 'tag:yaml.org,2002:seq',\n  STR: 'tag:yaml.org,2002:str'\n};\n\nfunction findLineStarts(src) {\n  var ls = [0];\n  var offset = src.indexOf('\\n');\n\n  while (offset !== -1) {\n    offset += 1;\n    ls.push(offset);\n    offset = src.indexOf('\\n', offset);\n  }\n\n  return ls;\n}\n\nfunction getSrcInfo(cst) {\n  var lineStarts, src;\n\n  if (typeof cst === 'string') {\n    lineStarts = findLineStarts(cst);\n    src = cst;\n  } else {\n    if (Array.isArray(cst)) cst = cst[0];\n\n    if (cst && cst.context) {\n      if (!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src);\n      lineStarts = cst.lineStarts;\n      src = cst.context.src;\n    }\n  }\n\n  return {\n    lineStarts: lineStarts,\n    src: src\n  };\n}\n/**\n * @typedef {Object} LinePos - One-indexed position in the source\n * @property {number} line\n * @property {number} col\n */\n\n/**\n * Determine the line/col position matching a character offset.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns a one-indexed `{ line, col }` location if found, or\n * `undefined` otherwise.\n *\n * @param {number} offset\n * @param {string|Document|Document[]} cst\n * @returns {?LinePos}\n */\n\n\nfunction getLinePos(offset, cst) {\n  if (typeof offset !== 'number' || offset < 0) return null;\n\n  var _getSrcInfo = getSrcInfo(cst),\n      lineStarts = _getSrcInfo.lineStarts,\n      src = _getSrcInfo.src;\n\n  if (!lineStarts || !src || offset > src.length) return null;\n\n  for (var i = 0; i < lineStarts.length; ++i) {\n    var start = lineStarts[i];\n\n    if (offset < start) {\n      return {\n        line: i,\n        col: offset - lineStarts[i - 1] + 1\n      };\n    }\n\n    if (offset === start) return {\n      line: i + 1,\n      col: 1\n    };\n  }\n\n  var line = lineStarts.length;\n  return {\n    line: line,\n    col: offset - lineStarts[line - 1] + 1\n  };\n}\n/**\n * Get a specified line from the source.\n *\n * Accepts a source string or a CST document as the second parameter. With\n * the latter, starting indices for lines are cached in the document as\n * `lineStarts: number[]`.\n *\n * Returns the line as a string if found, or `null` otherwise.\n *\n * @param {number} line One-indexed line number\n * @param {string|Document|Document[]} cst\n * @returns {?string}\n */\n\nfunction getLine(line, cst) {\n  var _getSrcInfo2 = getSrcInfo(cst),\n      lineStarts = _getSrcInfo2.lineStarts,\n      src = _getSrcInfo2.src;\n\n  if (!lineStarts || !(line >= 1) || line > lineStarts.length) return null;\n  var start = lineStarts[line - 1];\n  var end = lineStarts[line]; // undefined for last line; that's ok for slice()\n\n  while (end && end > start && src[end - 1] === '\\n') {\n    --end;\n  }\n\n  return src.slice(start, end);\n}\n/**\n * Pretty-print the starting line from the source indicated by the range `pos`\n *\n * Trims output to `maxWidth` chars while keeping the starting column visible,\n * using `…` at either end to indicate dropped characters.\n *\n * Returns a two-line string (or `null`) with `\\n` as separator; the second line\n * will hold appropriately indented `^` marks indicating the column range.\n *\n * @param {Object} pos\n * @param {LinePos} pos.start\n * @param {LinePos} [pos.end]\n * @param {string|Document|Document[]*} cst\n * @param {number} [maxWidth=80]\n * @returns {?string}\n */\n\nfunction getPrettyContext(_ref, cst) {\n  var start = _ref.start,\n      end = _ref.end;\n  var maxWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 80;\n  var src = getLine(start.line, cst);\n  if (!src) return null;\n  var col = start.col;\n\n  if (src.length > maxWidth) {\n    if (col <= maxWidth - 10) {\n      src = src.substr(0, maxWidth - 1) + '…';\n    } else {\n      var halfWidth = Math.round(maxWidth / 2);\n      if (src.length > col + halfWidth) src = src.substr(0, col + halfWidth - 1) + '…';\n      col -= src.length - maxWidth;\n      src = '…' + src.substr(1 - maxWidth);\n    }\n  }\n\n  var errLen = 1;\n  var errEnd = '';\n\n  if (end) {\n    if (end.line === start.line && col + (end.col - start.col) <= maxWidth + 1) {\n      errLen = end.col - start.col;\n    } else {\n      errLen = Math.min(src.length + 1, maxWidth) - col;\n      errEnd = '…';\n    }\n  }\n\n  var offset = col > 1 ? ' '.repeat(col - 1) : '';\n  var err = '^'.repeat(errLen);\n  return \"\".concat(src, \"\\n\").concat(offset).concat(err).concat(errEnd);\n}\n\nvar Range = /*#__PURE__*/function () {\n  function Range(start, end) {\n    _classCallCheck(this, Range);\n\n    this.start = start;\n    this.end = end || start;\n  }\n\n  _createClass(Range, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return typeof this.start !== 'number' || !this.end || this.end <= this.start;\n    }\n    /**\n     * Set `origStart` and `origEnd` to point to the original source range for\n     * this node, which may differ due to dropped CR characters.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRange\",\n    value: function setOrigRange(cr, offset) {\n      var start = this.start,\n          end = this.end;\n\n      if (cr.length === 0 || end <= cr[0]) {\n        this.origStart = start;\n        this.origEnd = end;\n        return offset;\n      }\n\n      var i = offset;\n\n      while (i < cr.length) {\n        if (cr[i] > start) break;else ++i;\n      }\n\n      this.origStart = start + i;\n      var nextOffset = i;\n\n      while (i < cr.length) {\n        // if end was at \\n, it should now be at \\r\n        if (cr[i] >= end) break;else ++i;\n      }\n\n      this.origEnd = end + i;\n      return nextOffset;\n    }\n  }], [{\n    key: \"copy\",\n    value: function copy(orig) {\n      return new Range(orig.start, orig.end);\n    }\n  }]);\n\n  return Range;\n}();\n\n/** Root class of all nodes */\n\nvar Node = /*#__PURE__*/function () {\n  function Node(type, props, context) {\n    _classCallCheck(this, Node);\n\n    Object.defineProperty(this, 'context', {\n      value: context || null,\n      writable: true\n    });\n    this.error = null;\n    this.range = null;\n    this.valueRange = null;\n    this.props = props || [];\n    this.type = type;\n    this.value = null;\n  }\n\n  _createClass(Node, [{\n    key: \"getPropValue\",\n    value: function getPropValue(idx, key, skipKey) {\n      if (!this.context) return null;\n      var src = this.context.src;\n      var prop = this.props[idx];\n      return prop && src[prop.start] === key ? src.slice(prop.start + (skipKey ? 1 : 0), prop.end) : null;\n    }\n  }, {\n    key: \"anchor\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var anchor = this.getPropValue(i, Char.ANCHOR, true);\n        if (anchor != null) return anchor;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"comment\",\n    get: function get() {\n      var comments = [];\n\n      for (var i = 0; i < this.props.length; ++i) {\n        var comment = this.getPropValue(i, Char.COMMENT, true);\n        if (comment != null) comments.push(comment);\n      }\n\n      return comments.length > 0 ? comments.join('\\n') : null;\n    }\n  }, {\n    key: \"commentHasRequiredWhitespace\",\n    value: function commentHasRequiredWhitespace(start) {\n      var src = this.context.src;\n      if (this.header && start === this.header.end) return false;\n      if (!this.valueRange) return false;\n      var end = this.valueRange.end;\n      return start !== end || Node.atBlank(src, end - 1);\n    }\n  }, {\n    key: \"hasComment\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] === Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"hasProps\",\n    get: function get() {\n      if (this.context) {\n        var src = this.context.src;\n\n        for (var i = 0; i < this.props.length; ++i) {\n          if (src[this.props[i].start] !== Char.COMMENT) return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"includesTrailingLines\",\n    get: function get() {\n      return false;\n    }\n  }, {\n    key: \"jsonLike\",\n    get: function get() {\n      var jsonLikeTypes = [Type.FLOW_MAP, Type.FLOW_SEQ, Type.QUOTE_DOUBLE, Type.QUOTE_SINGLE];\n      return jsonLikeTypes.indexOf(this.type) !== -1;\n    }\n  }, {\n    key: \"rangeAsLinePos\",\n    get: function get() {\n      if (!this.range || !this.context) return undefined;\n      var start = getLinePos(this.range.start, this.context.root);\n      if (!start) return undefined;\n      var end = getLinePos(this.range.end, this.context.root);\n      return {\n        start: start,\n        end: end\n      };\n    }\n  }, {\n    key: \"rawValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      return this.context.src.slice(start, end);\n    }\n  }, {\n    key: \"tag\",\n    get: function get() {\n      for (var i = 0; i < this.props.length; ++i) {\n        var tag = this.getPropValue(i, Char.TAG, false);\n\n        if (tag != null) {\n          if (tag[1] === '<') {\n            return {\n              verbatim: tag.slice(2, -1)\n            };\n          } else {\n            // eslint-disable-next-line no-unused-vars\n            var _tag$match = tag.match(/^(.*!)([^!]*)$/),\n                _tag$match2 = _slicedToArray(_tag$match, 3);\n                _tag$match2[0];\n                var handle = _tag$match2[1],\n                suffix = _tag$match2[2];\n\n            return {\n              handle: handle,\n              suffix: suffix\n            };\n          }\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"valueRangeContainsNewline\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return false;\n      var _this$valueRange2 = this.valueRange,\n          start = _this$valueRange2.start,\n          end = _this$valueRange2.end;\n      var src = this.context.src;\n\n      for (var i = start; i < end; ++i) {\n        if (src[i] === '\\n') return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"parseComment\",\n    value: function parseComment(start) {\n      var src = this.context.src;\n\n      if (src[start] === Char.COMMENT) {\n        var end = Node.endOfLine(src, start + 1);\n        var commentRange = new Range(start, end);\n        this.props.push(commentRange);\n        return end;\n      }\n\n      return start;\n    }\n    /**\n     * Populates the `origStart` and `origEnd` values of all ranges for this\n     * node. Extended by child classes to handle descendant nodes.\n     *\n     * @param {number[]} cr - Positions of dropped CR characters\n     * @param {number} offset - Starting index of `cr` from the last call\n     * @returns {number} - The next offset, matching the one found for `origStart`\n     */\n\n  }, {\n    key: \"setOrigRanges\",\n    value: function setOrigRanges(cr, offset) {\n      if (this.range) offset = this.range.setOrigRange(cr, offset);\n      if (this.valueRange) this.valueRange.setOrigRange(cr, offset);\n      this.props.forEach(function (prop) {\n        return prop.setOrigRange(cr, offset);\n      });\n      return offset;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var src = this.context.src,\n          range = this.range,\n          value = this.value;\n      if (value != null) return value;\n      var str = src.slice(range.start, range.end);\n      return Node.addStringTerminator(src, range.end, str);\n    }\n  }], [{\n    key: \"addStringTerminator\",\n    value: function addStringTerminator(src, offset, str) {\n      if (str[str.length - 1] === '\\n') return str;\n      var next = Node.endOfWhiteSpace(src, offset);\n      return next >= src.length || src[next] === '\\n' ? str + '\\n' : str;\n    } // ^(---|...)\n\n  }, {\n    key: \"atDocumentBoundary\",\n    value: function atDocumentBoundary(src, offset, sep) {\n      var ch0 = src[offset];\n      if (!ch0) return true;\n      var prev = src[offset - 1];\n      if (prev && prev !== '\\n') return false;\n\n      if (sep) {\n        if (ch0 !== sep) return false;\n      } else {\n        if (ch0 !== Char.DIRECTIVES_END && ch0 !== Char.DOCUMENT_END) return false;\n      }\n\n      var ch1 = src[offset + 1];\n      var ch2 = src[offset + 2];\n      if (ch1 !== ch0 || ch2 !== ch0) return false;\n      var ch3 = src[offset + 3];\n      return !ch3 || ch3 === '\\n' || ch3 === '\\t' || ch3 === ' ';\n    }\n  }, {\n    key: \"endOfIdentifier\",\n    value: function endOfIdentifier(src, offset) {\n      var ch = src[offset];\n      var isVerbatim = ch === '<';\n      var notOk = isVerbatim ? ['\\n', '\\t', ' ', '>'] : ['\\n', '\\t', ' ', '[', ']', '{', '}', ','];\n\n      while (ch && notOk.indexOf(ch) === -1) {\n        ch = src[offset += 1];\n      }\n\n      if (isVerbatim && ch === '>') offset += 1;\n      return offset;\n    }\n  }, {\n    key: \"endOfIndent\",\n    value: function endOfIndent(src, offset) {\n      var ch = src[offset];\n\n      while (ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfLine\",\n    value: function endOfLine(src, offset) {\n      var ch = src[offset];\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"endOfWhiteSpace\",\n    value: function endOfWhiteSpace(src, offset) {\n      var ch = src[offset];\n\n      while (ch === '\\t' || ch === ' ') {\n        ch = src[offset += 1];\n      }\n\n      return offset;\n    }\n  }, {\n    key: \"startOfLine\",\n    value: function startOfLine(src, offset) {\n      var ch = src[offset - 1];\n      if (ch === '\\n') return offset;\n\n      while (ch && ch !== '\\n') {\n        ch = src[offset -= 1];\n      }\n\n      return offset + 1;\n    }\n    /**\n     * End of indentation, or null if the line's indent level is not more\n     * than `indent`\n     *\n     * @param {string} src\n     * @param {number} indent\n     * @param {number} lineStart\n     * @returns {?number}\n     */\n\n  }, {\n    key: \"endOfBlockIndent\",\n    value: function endOfBlockIndent(src, indent, lineStart) {\n      var inEnd = Node.endOfIndent(src, lineStart);\n\n      if (inEnd > lineStart + indent) {\n        return inEnd;\n      } else {\n        var wsEnd = Node.endOfWhiteSpace(src, inEnd);\n        var ch = src[wsEnd];\n        if (!ch || ch === '\\n') return wsEnd;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"atBlank\",\n    value: function atBlank(src, offset, endAsBlank) {\n      var ch = src[offset];\n      return ch === '\\n' || ch === '\\t' || ch === ' ' || endAsBlank && !ch;\n    }\n  }, {\n    key: \"nextNodeIsIndented\",\n    value: function nextNodeIsIndented(ch, indentDiff, indicatorAsIndent) {\n      if (!ch || indentDiff < 0) return false;\n      if (indentDiff > 0) return true;\n      return indicatorAsIndent && ch === '-';\n    } // should be at line or string end, or at next non-whitespace char\n\n  }, {\n    key: \"normalizeOffset\",\n    value: function normalizeOffset(src, offset) {\n      var ch = src[offset];\n      return !ch ? offset : ch !== '\\n' && src[offset - 1] === '\\n' ? offset - 1 : Node.endOfWhiteSpace(src, offset);\n    } // fold single newline into space, multiple newlines to N - 1 newlines\n    // presumes src[offset] === '\\n'\n\n  }, {\n    key: \"foldNewline\",\n    value: function foldNewline(src, offset, indent) {\n      var inCount = 0;\n      var error = false;\n      var fold = '';\n      var ch = src[offset + 1];\n\n      while (ch === ' ' || ch === '\\t' || ch === '\\n') {\n        switch (ch) {\n          case '\\n':\n            inCount = 0;\n            offset += 1;\n            fold += '\\n';\n            break;\n\n          case '\\t':\n            if (inCount <= indent) error = true;\n            offset = Node.endOfWhiteSpace(src, offset + 2) - 1;\n            break;\n\n          case ' ':\n            inCount += 1;\n            offset += 1;\n            break;\n        }\n\n        ch = src[offset + 1];\n      }\n\n      if (!fold) fold = ' ';\n      if (ch && inCount <= indent) error = true;\n      return {\n        fold: fold,\n        offset: offset,\n        error: error\n      };\n    }\n  }]);\n\n  return Node;\n}();\n\nvar YAMLError = /*#__PURE__*/function (_Error) {\n  _inherits(YAMLError, _Error);\n\n  var _super = _createSuper(YAMLError);\n\n  function YAMLError(name, source, message) {\n    var _this;\n\n    _classCallCheck(this, YAMLError);\n\n    if (!message || !(source instanceof Node)) throw new Error(\"Invalid arguments for new \".concat(name));\n    _this = _super.call(this);\n    _this.name = name;\n    _this.message = message;\n    _this.source = source;\n    return _this;\n  }\n\n  _createClass(YAMLError, [{\n    key: \"makePretty\",\n    value: function makePretty() {\n      if (!this.source) return;\n      this.nodeType = this.source.type;\n      var cst = this.source.context && this.source.context.root;\n\n      if (typeof this.offset === 'number') {\n        this.range = new Range(this.offset, this.offset + 1);\n        var start = cst && getLinePos(this.offset, cst);\n\n        if (start) {\n          var end = {\n            line: start.line,\n            col: start.col + 1\n          };\n          this.linePos = {\n            start: start,\n            end: end\n          };\n        }\n\n        delete this.offset;\n      } else {\n        this.range = this.source.range;\n        this.linePos = this.source.rangeAsLinePos;\n      }\n\n      if (this.linePos) {\n        var _this$linePos$start = this.linePos.start,\n            line = _this$linePos$start.line,\n            col = _this$linePos$start.col;\n        this.message += \" at line \".concat(line, \", column \").concat(col);\n        var ctx = cst && getPrettyContext(this.linePos, cst);\n        if (ctx) this.message += \":\\n\\n\".concat(ctx, \"\\n\");\n      }\n\n      delete this.source;\n    }\n  }]);\n\n  return YAMLError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\nvar YAMLReferenceError = /*#__PURE__*/function (_YAMLError) {\n  _inherits(YAMLReferenceError, _YAMLError);\n\n  var _super2 = _createSuper(YAMLReferenceError);\n\n  function YAMLReferenceError(source, message) {\n    _classCallCheck(this, YAMLReferenceError);\n\n    return _super2.call(this, 'YAMLReferenceError', source, message);\n  }\n\n  return YAMLReferenceError;\n}(YAMLError);\nvar YAMLSemanticError = /*#__PURE__*/function (_YAMLError2) {\n  _inherits(YAMLSemanticError, _YAMLError2);\n\n  var _super3 = _createSuper(YAMLSemanticError);\n\n  function YAMLSemanticError(source, message) {\n    _classCallCheck(this, YAMLSemanticError);\n\n    return _super3.call(this, 'YAMLSemanticError', source, message);\n  }\n\n  return YAMLSemanticError;\n}(YAMLError);\nvar YAMLSyntaxError = /*#__PURE__*/function (_YAMLError3) {\n  _inherits(YAMLSyntaxError, _YAMLError3);\n\n  var _super4 = _createSuper(YAMLSyntaxError);\n\n  function YAMLSyntaxError(source, message) {\n    _classCallCheck(this, YAMLSyntaxError);\n\n    return _super4.call(this, 'YAMLSyntaxError', source, message);\n  }\n\n  return YAMLSyntaxError;\n}(YAMLError);\nvar YAMLWarning = /*#__PURE__*/function (_YAMLError4) {\n  _inherits(YAMLWarning, _YAMLError4);\n\n  var _super5 = _createSuper(YAMLWarning);\n\n  function YAMLWarning(source, message) {\n    _classCallCheck(this, YAMLWarning);\n\n    return _super5.call(this, 'YAMLWarning', source, message);\n  }\n\n  return YAMLWarning;\n}(YAMLError);\n\nvar PlainValue = /*#__PURE__*/function (_Node) {\n  _inherits(PlainValue, _Node);\n\n  var _super = _createSuper(PlainValue);\n\n  function PlainValue() {\n    _classCallCheck(this, PlainValue);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PlainValue, [{\n    key: \"strValue\",\n    get: function get() {\n      if (!this.valueRange || !this.context) return null;\n      var _this$valueRange = this.valueRange,\n          start = _this$valueRange.start,\n          end = _this$valueRange.end;\n      var src = this.context.src;\n      var ch = src[end - 1];\n\n      while (start < end && (ch === '\\n' || ch === '\\t' || ch === ' ')) {\n        ch = src[--end - 1];\n      }\n\n      var str = '';\n\n      for (var i = start; i < end; ++i) {\n        var _ch = src[i];\n\n        if (_ch === '\\n') {\n          var _Node$foldNewline = Node.foldNewline(src, i, -1),\n              fold = _Node$foldNewline.fold,\n              offset = _Node$foldNewline.offset;\n\n          str += fold;\n          i = offset;\n        } else if (_ch === ' ' || _ch === '\\t') {\n          // trim trailing whitespace\n          var wsStart = i;\n          var next = src[i + 1];\n\n          while (i < end && (next === ' ' || next === '\\t')) {\n            i += 1;\n            next = src[i + 1];\n          }\n\n          if (next !== '\\n') str += i > wsStart ? src.slice(wsStart, i + 1) : _ch;\n        } else {\n          str += _ch;\n        }\n      }\n\n      var ch0 = src[start];\n\n      switch (ch0) {\n        case '\\t':\n          {\n            var msg = 'Plain value cannot start with a tab character';\n            var errors = [new YAMLSemanticError(this, msg)];\n            return {\n              errors: errors,\n              str: str\n            };\n          }\n\n        case '@':\n        case '`':\n          {\n            var _msg = \"Plain value cannot start with reserved character \".concat(ch0);\n\n            var _errors = [new YAMLSemanticError(this, _msg)];\n            return {\n              errors: _errors,\n              str: str\n            };\n          }\n\n        default:\n          return str;\n      }\n    }\n  }, {\n    key: \"parseBlockValue\",\n    value: function parseBlockValue(start) {\n      var _this$context = this.context,\n          indent = _this$context.indent,\n          inFlow = _this$context.inFlow,\n          src = _this$context.src;\n      var offset = start;\n      var valueEnd = start;\n\n      for (var ch = src[offset]; ch === '\\n'; ch = src[offset]) {\n        if (Node.atDocumentBoundary(src, offset + 1)) break;\n        var end = Node.endOfBlockIndent(src, indent, offset + 1);\n        if (end === null || src[end] === '#') break;\n\n        if (src[end] === '\\n') {\n          offset = end;\n        } else {\n          valueEnd = PlainValue.endOfLine(src, end, inFlow);\n          offset = valueEnd;\n        }\n      }\n\n      if (this.valueRange.isEmpty()) this.valueRange.start = start;\n      this.valueRange.end = valueEnd;\n      return valueEnd;\n    }\n    /**\n     * Parses a plain value from the source\n     *\n     * Accepted forms are:\n     * ```\n     * #comment\n     *\n     * first line\n     *\n     * first line #comment\n     *\n     * first line\n     * block\n     * lines\n     *\n     * #comment\n     * block\n     * lines\n     * ```\n     * where block lines are empty or have an indent level greater than `indent`.\n     *\n     * @param {ParseContext} context\n     * @param {number} start - Index of first character\n     * @returns {number} - Index of the character after this scalar, may be `\\n`\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(context, start) {\n      this.context = context;\n      var inFlow = context.inFlow,\n          src = context.src;\n      var offset = start;\n      var ch = src[offset];\n\n      if (ch && ch !== '#' && ch !== '\\n') {\n        offset = PlainValue.endOfLine(src, start, inFlow);\n      }\n\n      this.valueRange = new Range(start, offset);\n      offset = Node.endOfWhiteSpace(src, offset);\n      offset = this.parseComment(offset);\n\n      if (!this.hasComment || this.valueRange.isEmpty()) {\n        offset = this.parseBlockValue(offset);\n      }\n\n      return offset;\n    }\n  }], [{\n    key: \"endOfLine\",\n    value: function endOfLine(src, start, inFlow) {\n      var ch = src[start];\n      var offset = start;\n\n      while (ch && ch !== '\\n') {\n        if (inFlow && (ch === '[' || ch === ']' || ch === '{' || ch === '}' || ch === ',')) break;\n        var next = src[offset + 1];\n        if (ch === ':' && (!next || next === '\\n' || next === '\\t' || next === ' ' || inFlow && next === ',')) break;\n        if ((ch === ' ' || ch === '\\t') && next === '#') break;\n        offset += 1;\n        ch = next;\n      }\n\n      return offset;\n    }\n  }]);\n\n  return PlainValue;\n}(Node);\n\nexport { Char as C, Node as N, PlainValue as P, Range as R, Type as T, YAMLSyntaxError as Y, _createForOfIteratorHelper as _, _typeof as a, _createClass as b, _classCallCheck as c, defaultTagPrefix as d, _defineProperty as e, YAMLWarning as f, YAMLSemanticError as g, _slicedToArray as h, YAMLError as i, _inherits as j, _createSuper as k, _get as l, _getPrototypeOf as m, defaultTags as n, YAMLReferenceError as o, _assertThisInitialized as p, _toArray as q, _possibleConstructorReturn as r };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}