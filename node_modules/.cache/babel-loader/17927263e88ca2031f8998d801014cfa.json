{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.Binary = Binary;\nexports.BinaryExpression = BinaryExpression;\nexports.ClassExpression = ClassExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.DoExpression = DoExpression;\nexports.FunctionExpression = FunctionExpression;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.Identifier = Identifier;\nexports.LogicalExpression = LogicalExpression;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.ObjectExpression = ObjectExpression;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.TSAsExpression = TSAsExpression;\nexports.TSInferType = TSInferType;\nexports.TSInstantiationExpression = TSInstantiationExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.UnaryLike = UnaryLike;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isArrayTypeAnnotation,\n  isArrowFunctionExpression,\n  isAssignmentExpression,\n  isAwaitExpression,\n  isBinary,\n  isBinaryExpression,\n  isUpdateExpression,\n  isCallExpression,\n  isClass,\n  isClassExpression,\n  isConditional,\n  isConditionalExpression,\n  isExportDeclaration,\n  isExportDefaultDeclaration,\n  isExpressionStatement,\n  isFor,\n  isForInStatement,\n  isForOfStatement,\n  isForStatement,\n  isFunctionExpression,\n  isIfStatement,\n  isIndexedAccessType,\n  isIntersectionTypeAnnotation,\n  isLogicalExpression,\n  isMemberExpression,\n  isNewExpression,\n  isNullableTypeAnnotation,\n  isObjectPattern,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isReturnStatement,\n  isSequenceExpression,\n  isSwitchStatement,\n  isTSArrayType,\n  isTSAsExpression,\n  isTSInstantiationExpression,\n  isTSIntersectionType,\n  isTSNonNullExpression,\n  isTSOptionalType,\n  isTSRestType,\n  isTSTypeAssertion,\n  isTSUnionType,\n  isTaggedTemplateExpression,\n  isThrowStatement,\n  isTypeAnnotation,\n  isUnaryLike,\n  isUnionTypeAnnotation,\n  isVariableDeclarator,\n  isWhileStatement,\n  isYieldExpression\n} = _t;\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"|>\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\n\nconst isClassExtendsClause = (node, parent) => isClass(parent, {\n  superClass: node\n});\n\nconst hasPostfixPart = (node, parent) => (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);\n\nfunction NullableTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent);\n}\n\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  if (printStack.length < 3) return;\n  return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\n\nfunction UpdateExpression(node, parent) {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, 1 | 2);\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return !node.async && isFirstInContext(printStack, 1);\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);\n}\n\nfunction OptionalIndexedAccessType(node, parent) {\n  return isIndexedAccessType(parent, {\n    objectType: node\n  });\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction TSUnionType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);\n}\n\nfunction TSInferType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent);\n}\n\nfunction TSInstantiationExpression(node, parent) {\n  return (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent) || isTSInstantiationExpression(parent)) && !!parent.typeParameters;\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (isVariableDeclarator(parent) || isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, 1 | 4);\n}\n\nfunction UnaryLike(node, parent) {\n  return hasPostfixPart(node, parent) || isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, 1 | 4);\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {\n    test: node\n  }) || isAwaitExpression(parent) || isTSTypeAssertion(parent) || isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction OptionalMemberExpression(node, parent) {\n  return isCallExpression(parent, {\n    callee: node\n  }) || isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction AssignmentExpression(node, parent) {\n  if (isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\n\nfunction LogicalExpression(node, parent) {\n  switch (node.operator) {\n    case \"||\":\n      if (!isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n\n    case \"&&\":\n      return isLogicalExpression(parent, {\n        operator: \"??\"\n      });\n\n    case \"??\":\n      return isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\n\nfunction Identifier(node, parent, printStack) {\n  var _node$extra;\n\n  if ((_node$extra = node.extra) != null && _node$extra.parenthesized && isAssignmentExpression(parent, {\n    left: node\n  }) && (isFunctionExpression(parent.right) || isClassExpression(parent.right)) && parent.right.id == null) {\n    return true;\n  }\n\n  if (node.name === \"let\") {\n    const isFollowedByBracket = isMemberExpression(parent, {\n      object: node,\n      computed: true\n    }) || isOptionalMemberExpression(parent, {\n      object: node,\n      computed: true,\n      optional: false\n    });\n    return isFirstInContext(printStack, isFollowedByBracket ? 1 | 8 | 16 | 32 : 32);\n  }\n\n  return node.name === \"async\" && isForOfStatement(parent) && node === parent.left;\n}\n\nfunction isFirstInContext(printStack, checkParam) {\n  const expressionStatement = checkParam & 1;\n  const arrowBody = checkParam & 2;\n  const exportDefault = checkParam & 4;\n  const forHead = checkParam & 8;\n  const forInHead = checkParam & 16;\n  const forOfHead = checkParam & 32;\n  let i = printStack.length - 1;\n  if (i <= 0) return;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n\n  while (i >= 0) {\n    if (expressionStatement && isExpressionStatement(parent, {\n      expression: node\n    }) || exportDefault && isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || arrowBody && isArrowFunctionExpression(parent, {\n      body: node\n    }) || forHead && isForStatement(parent, {\n      init: node\n    }) || forInHead && isForInStatement(parent, {\n      left: node\n    }) || forOfHead && isForOfStatement(parent, {\n      left: node\n    })) {\n      return true;\n    }\n\n    if (i > 0 && (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isUpdateExpression(parent) && !parent.prefix || isConditional(parent, {\n      test: node\n    }) || isBinary(parent, {\n      left: node\n    }) || isAssignmentExpression(parent, {\n      left: node\n    }))) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","ArrowFunctionExpression","AssignmentExpression","Binary","BinaryExpression","ClassExpression","ConditionalExpression","DoExpression","FunctionExpression","FunctionTypeAnnotation","Identifier","LogicalExpression","NullableTypeAnnotation","ObjectExpression","OptionalIndexedAccessType","OptionalCallExpression","OptionalMemberExpression","SequenceExpression","TSAsExpression","TSInferType","TSInstantiationExpression","TSTypeAssertion","TSIntersectionType","TSUnionType","UnaryLike","IntersectionTypeAnnotation","UnionTypeAnnotation","UpdateExpression","AwaitExpression","YieldExpression","_t","require","isArrayTypeAnnotation","isArrowFunctionExpression","isAssignmentExpression","isAwaitExpression","isBinary","isBinaryExpression","isUpdateExpression","isCallExpression","isClass","isClassExpression","isConditional","isConditionalExpression","isExportDeclaration","isExportDefaultDeclaration","isExpressionStatement","isFor","isForInStatement","isForOfStatement","isForStatement","isFunctionExpression","isIfStatement","isIndexedAccessType","isIntersectionTypeAnnotation","isLogicalExpression","isMemberExpression","isNewExpression","isNullableTypeAnnotation","isObjectPattern","isOptionalCallExpression","isOptionalMemberExpression","isReturnStatement","isSequenceExpression","isSwitchStatement","isTSArrayType","isTSAsExpression","isTSInstantiationExpression","isTSIntersectionType","isTSNonNullExpression","isTSOptionalType","isTSRestType","isTSTypeAssertion","isTSUnionType","isTaggedTemplateExpression","isThrowStatement","isTypeAnnotation","isUnaryLike","isUnionTypeAnnotation","isVariableDeclarator","isWhileStatement","isYieldExpression","PRECEDENCE","in","instanceof","isClassExtendsClause","node","parent","superClass","hasPostfixPart","object","callee","tag","printStack","length","isFirstInContext","async","operator","left","parentOp","parentPos","nodeOp","nodePos","right","objectType","typeParameters","test","discriminant","expression","_node$extra","extra","parenthesized","id","name","isFollowedByBracket","computed","optional","checkParam","expressionStatement","arrowBody","exportDefault","forHead","forInHead","forOfHead","i","declaration","body","init","expressions","prefix"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/@babel/generator/lib/node/parentheses.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.Binary = Binary;\nexports.BinaryExpression = BinaryExpression;\nexports.ClassExpression = ClassExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.DoExpression = DoExpression;\nexports.FunctionExpression = FunctionExpression;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.Identifier = Identifier;\nexports.LogicalExpression = LogicalExpression;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.ObjectExpression = ObjectExpression;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.TSAsExpression = TSAsExpression;\nexports.TSInferType = TSInferType;\nexports.TSInstantiationExpression = TSInstantiationExpression;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.UnaryLike = UnaryLike;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isArrayTypeAnnotation,\n  isArrowFunctionExpression,\n  isAssignmentExpression,\n  isAwaitExpression,\n  isBinary,\n  isBinaryExpression,\n  isUpdateExpression,\n  isCallExpression,\n  isClass,\n  isClassExpression,\n  isConditional,\n  isConditionalExpression,\n  isExportDeclaration,\n  isExportDefaultDeclaration,\n  isExpressionStatement,\n  isFor,\n  isForInStatement,\n  isForOfStatement,\n  isForStatement,\n  isFunctionExpression,\n  isIfStatement,\n  isIndexedAccessType,\n  isIntersectionTypeAnnotation,\n  isLogicalExpression,\n  isMemberExpression,\n  isNewExpression,\n  isNullableTypeAnnotation,\n  isObjectPattern,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isReturnStatement,\n  isSequenceExpression,\n  isSwitchStatement,\n  isTSArrayType,\n  isTSAsExpression,\n  isTSInstantiationExpression,\n  isTSIntersectionType,\n  isTSNonNullExpression,\n  isTSOptionalType,\n  isTSRestType,\n  isTSTypeAssertion,\n  isTSUnionType,\n  isTaggedTemplateExpression,\n  isThrowStatement,\n  isTypeAnnotation,\n  isUnaryLike,\n  isUnionTypeAnnotation,\n  isVariableDeclarator,\n  isWhileStatement,\n  isYieldExpression\n} = _t;\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"|>\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\n\nconst isClassExtendsClause = (node, parent) => isClass(parent, {\n  superClass: node\n});\n\nconst hasPostfixPart = (node, parent) => (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);\n\nfunction NullableTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent);\n}\n\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  if (printStack.length < 3) return;\n  return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\n\nfunction UpdateExpression(node, parent) {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, 1 | 2);\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return !node.async && isFirstInContext(printStack, 1);\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);\n}\n\nfunction OptionalIndexedAccessType(node, parent) {\n  return isIndexedAccessType(parent, {\n    objectType: node\n  });\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction TSUnionType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);\n}\n\nfunction TSInferType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent);\n}\n\nfunction TSInstantiationExpression(node, parent) {\n  return (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent) || isTSInstantiationExpression(parent)) && !!parent.typeParameters;\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (isVariableDeclarator(parent) || isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, 1 | 4);\n}\n\nfunction UnaryLike(node, parent) {\n  return hasPostfixPart(node, parent) || isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, 1 | 4);\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {\n    test: node\n  }) || isAwaitExpression(parent) || isTSTypeAssertion(parent) || isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction OptionalMemberExpression(node, parent) {\n  return isCallExpression(parent, {\n    callee: node\n  }) || isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction AssignmentExpression(node, parent) {\n  if (isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\n\nfunction LogicalExpression(node, parent) {\n  switch (node.operator) {\n    case \"||\":\n      if (!isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n\n    case \"&&\":\n      return isLogicalExpression(parent, {\n        operator: \"??\"\n      });\n\n    case \"??\":\n      return isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\n\nfunction Identifier(node, parent, printStack) {\n  var _node$extra;\n\n  if ((_node$extra = node.extra) != null && _node$extra.parenthesized && isAssignmentExpression(parent, {\n    left: node\n  }) && (isFunctionExpression(parent.right) || isClassExpression(parent.right)) && parent.right.id == null) {\n    return true;\n  }\n\n  if (node.name === \"let\") {\n    const isFollowedByBracket = isMemberExpression(parent, {\n      object: node,\n      computed: true\n    }) || isOptionalMemberExpression(parent, {\n      object: node,\n      computed: true,\n      optional: false\n    });\n    return isFirstInContext(printStack, isFollowedByBracket ? 1 | 8 | 16 | 32 : 32);\n  }\n\n  return node.name === \"async\" && isForOfStatement(parent) && node === parent.left;\n}\n\nfunction isFirstInContext(printStack, checkParam) {\n  const expressionStatement = checkParam & 1;\n  const arrowBody = checkParam & 2;\n  const exportDefault = checkParam & 4;\n  const forHead = checkParam & 8;\n  const forInHead = checkParam & 16;\n  const forOfHead = checkParam & 32;\n  let i = printStack.length - 1;\n  if (i <= 0) return;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n\n  while (i >= 0) {\n    if (expressionStatement && isExpressionStatement(parent, {\n      expression: node\n    }) || exportDefault && isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || arrowBody && isArrowFunctionExpression(parent, {\n      body: node\n    }) || forHead && isForStatement(parent, {\n      init: node\n    }) || forInHead && isForInStatement(parent, {\n      left: node\n    }) || forOfHead && isForOfStatement(parent, {\n      left: node\n    })) {\n      return true;\n    }\n\n    if (i > 0 && (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isUpdateExpression(parent) && !parent.prefix || isConditional(parent, {\n      test: node\n    }) || isBinary(parent, {\n      left: node\n    }) || isAssignmentExpression(parent, {\n      left: node\n    }))) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}