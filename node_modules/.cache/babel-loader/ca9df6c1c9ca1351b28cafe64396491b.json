{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\nexports.replaceWith = replaceWith;\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = require(\"../index\");\n\nvar _index2 = require(\"./index\");\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar _t = require(\"@babel/types\");\n\nvar _helperHoistVariables = require(\"@babel/helper-hoist-variables\");\n\nconst {\n  FUNCTION_TYPES,\n  arrowFunctionExpression,\n  assignmentExpression,\n  awaitExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  identifier,\n  inheritLeadingComments,\n  inheritTrailingComments,\n  inheritsComments,\n  isExpression,\n  isProgram,\n  isStatement,\n  removeComments,\n  returnStatement,\n  toSequenceExpression,\n  validate,\n  yieldExpression\n} = _t;\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  inheritLeadingComments(nodes[0], this.node);\n  inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n  let ast;\n\n  try {\n    replacement = `(${replacement})`;\n    ast = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  const expressionAST = ast.program.body[0].expression;\n\n  _index.default.removeProperties(expressionAST);\n\n  return this.replaceWith(expressionAST);\n}\n\nfunction replaceWith(replacementPath) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  let replacement = replacementPath instanceof _index2.default ? replacementPath.node : replacementPath;\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    inheritsComments(replacement, oldNode);\n    removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    validate(this.parent, this.key, [node]);\n  } else {\n    validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const nodesAsSequenceExpression = toSequenceExpression(nodes, this.scope);\n\n  if (nodesAsSequenceExpression) {\n    return this.replaceWith(nodesAsSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const isParentGenerator = functionParent == null ? void 0 : functionParent.is(\"generator\");\n  const container = arrowFunctionExpression([], blockStatement(nodes));\n  this.replaceWith(callExpression(container, []));\n  const callee = this.get(\"callee\");\n  (0, _helperHoistVariables.default)(callee.get(\"body\"), id => {\n    this.scope.push({\n      id\n    });\n  }, \"var\");\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", returnStatement(cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(assignmentExpression(\"=\", cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(returnStatement(path.node.expression));\n    }\n  }\n\n  callee.arrowFunctionToExpression();\n  const newCallee = callee;\n\n  const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", FUNCTION_TYPES);\n\n  const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get(\"callee.body\").node, \"YieldExpression\", FUNCTION_TYPES);\n\n  if (needToAwaitFunction) {\n    newCallee.set(\"async\", true);\n\n    if (!needToYieldFunction) {\n      this.replaceWith(awaitExpression(this.node));\n    }\n  }\n\n  if (needToYieldFunction) {\n    newCallee.set(\"generator\", true);\n    this.replaceWith(yieldExpression(this.node, true));\n  }\n\n  return newCallee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_replaceWith","replaceExpressionWithStatements","replaceInline","replaceWith","replaceWithMultiple","replaceWithSourceString","_codeFrame","require","_index","_index2","_cache","_parser","_t","_helperHoistVariables","FUNCTION_TYPES","arrowFunctionExpression","assignmentExpression","awaitExpression","blockStatement","callExpression","cloneNode","expressionStatement","identifier","inheritLeadingComments","inheritTrailingComments","inheritsComments","isExpression","isProgram","isStatement","removeComments","returnStatement","toSequenceExpression","validate","yieldExpression","nodes","_pathCache$get","resync","_verifyNodeList","node","length","path","get","parent","delete","container","key","paths","insertAfter","requeue","remove","replacement","ast","parse","err","loc","message","codeFrameColumns","start","line","column","code","expressionAST","program","body","expression","default","removeProperties","replacementPath","removed","Error","Array","isArray","nodePath","isNodeType","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","parentPath","isExportDefaultDeclaration","oldNode","type","setScope","_pathCache$get2","ReferenceError","inList","debug","set","nodesAsSequenceExpression","scope","functionParent","getFunctionParent","isParentAsync","is","isParentGenerator","callee","id","push","completionRecords","getCompletionRecords","isExpressionStatement","loop","findParent","isLoop","uid","getData","generateDeclaredUidIdentifier","pushContainer","setData","name","arrowFunctionToExpression","newCallee","needToAwaitFunction","hasType","needToYieldFunction","_containerInsertAfter"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/@babel/traverse/lib/path/replacement.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\nexports.replaceWith = replaceWith;\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = require(\"../index\");\n\nvar _index2 = require(\"./index\");\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar _t = require(\"@babel/types\");\n\nvar _helperHoistVariables = require(\"@babel/helper-hoist-variables\");\n\nconst {\n  FUNCTION_TYPES,\n  arrowFunctionExpression,\n  assignmentExpression,\n  awaitExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  identifier,\n  inheritLeadingComments,\n  inheritTrailingComments,\n  inheritsComments,\n  isExpression,\n  isProgram,\n  isStatement,\n  removeComments,\n  returnStatement,\n  toSequenceExpression,\n  validate,\n  yieldExpression\n} = _t;\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  inheritLeadingComments(nodes[0], this.node);\n  inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n  let ast;\n\n  try {\n    replacement = `(${replacement})`;\n    ast = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  const expressionAST = ast.program.body[0].expression;\n\n  _index.default.removeProperties(expressionAST);\n\n  return this.replaceWith(expressionAST);\n}\n\nfunction replaceWith(replacementPath) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  let replacement = replacementPath instanceof _index2.default ? replacementPath.node : replacementPath;\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    inheritsComments(replacement, oldNode);\n    removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    validate(this.parent, this.key, [node]);\n  } else {\n    validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const nodesAsSequenceExpression = toSequenceExpression(nodes, this.scope);\n\n  if (nodesAsSequenceExpression) {\n    return this.replaceWith(nodesAsSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const isParentGenerator = functionParent == null ? void 0 : functionParent.is(\"generator\");\n  const container = arrowFunctionExpression([], blockStatement(nodes));\n  this.replaceWith(callExpression(container, []));\n  const callee = this.get(\"callee\");\n  (0, _helperHoistVariables.default)(callee.get(\"body\"), id => {\n    this.scope.push({\n      id\n    });\n  }, \"var\");\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", returnStatement(cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(assignmentExpression(\"=\", cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(returnStatement(path.node.expression));\n    }\n  }\n\n  callee.arrowFunctionToExpression();\n  const newCallee = callee;\n\n  const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", FUNCTION_TYPES);\n\n  const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get(\"callee.body\").node, \"YieldExpression\", FUNCTION_TYPES);\n\n  if (needToAwaitFunction) {\n    newCallee.set(\"async\", true);\n\n    if (!needToYieldFunction) {\n      this.replaceWith(awaitExpression(this.node));\n    }\n  }\n\n  if (needToYieldFunction) {\n    newCallee.set(\"generator\", true);\n    this.replaceWith(yieldExpression(this.node, true));\n  }\n\n  return newCallee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}