{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TSAnyKeyword = TSAnyKeyword;\nexports.TSArrayType = TSArrayType;\nexports.TSAsExpression = TSAsExpression;\nexports.TSBigIntKeyword = TSBigIntKeyword;\nexports.TSBooleanKeyword = TSBooleanKeyword;\nexports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;\nexports.TSConditionalType = TSConditionalType;\nexports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;\nexports.TSConstructorType = TSConstructorType;\nexports.TSDeclareFunction = TSDeclareFunction;\nexports.TSDeclareMethod = TSDeclareMethod;\nexports.TSEnumDeclaration = TSEnumDeclaration;\nexports.TSEnumMember = TSEnumMember;\nexports.TSExportAssignment = TSExportAssignment;\nexports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;\nexports.TSExternalModuleReference = TSExternalModuleReference;\nexports.TSFunctionType = TSFunctionType;\nexports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;\nexports.TSImportType = TSImportType;\nexports.TSIndexSignature = TSIndexSignature;\nexports.TSIndexedAccessType = TSIndexedAccessType;\nexports.TSInferType = TSInferType;\nexports.TSInstantiationExpression = TSInstantiationExpression;\nexports.TSInterfaceBody = TSInterfaceBody;\nexports.TSInterfaceDeclaration = TSInterfaceDeclaration;\nexports.TSIntersectionType = TSIntersectionType;\nexports.TSIntrinsicKeyword = TSIntrinsicKeyword;\nexports.TSLiteralType = TSLiteralType;\nexports.TSMappedType = TSMappedType;\nexports.TSMethodSignature = TSMethodSignature;\nexports.TSModuleBlock = TSModuleBlock;\nexports.TSModuleDeclaration = TSModuleDeclaration;\nexports.TSNamedTupleMember = TSNamedTupleMember;\nexports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;\nexports.TSNeverKeyword = TSNeverKeyword;\nexports.TSNonNullExpression = TSNonNullExpression;\nexports.TSNullKeyword = TSNullKeyword;\nexports.TSNumberKeyword = TSNumberKeyword;\nexports.TSObjectKeyword = TSObjectKeyword;\nexports.TSOptionalType = TSOptionalType;\nexports.TSParameterProperty = TSParameterProperty;\nexports.TSParenthesizedType = TSParenthesizedType;\nexports.TSPropertySignature = TSPropertySignature;\nexports.TSQualifiedName = TSQualifiedName;\nexports.TSRestType = TSRestType;\nexports.TSStringKeyword = TSStringKeyword;\nexports.TSSymbolKeyword = TSSymbolKeyword;\nexports.TSThisType = TSThisType;\nexports.TSTupleType = TSTupleType;\nexports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;\nexports.TSTypeAnnotation = TSTypeAnnotation;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSTypeLiteral = TSTypeLiteral;\nexports.TSTypeOperator = TSTypeOperator;\nexports.TSTypeParameter = TSTypeParameter;\nexports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;\nexports.TSTypePredicate = TSTypePredicate;\nexports.TSTypeQuery = TSTypeQuery;\nexports.TSTypeReference = TSTypeReference;\nexports.TSUndefinedKeyword = TSUndefinedKeyword;\nexports.TSUnionType = TSUnionType;\nexports.TSUnknownKeyword = TSUnknownKeyword;\nexports.TSVoidKeyword = TSVoidKeyword;\nexports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;\nexports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;\nexports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;\nexports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;\nexports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;\n\nfunction TSTypeAnnotation(node) {\n  this.tokenChar(58);\n  this.space();\n  if (node.optional) this.tokenChar(63);\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSTypeParameterInstantiation(node, parent) {\n  this.tokenChar(60);\n  this.printList(node.params, node, {});\n\n  if (parent.type === \"ArrowFunctionExpression\" && node.params.length === 1) {\n    this.tokenChar(44);\n  }\n\n  this.tokenChar(62);\n}\n\nfunction TSTypeParameter(node) {\n  if (node.in) {\n    this.word(\"in\");\n    this.space();\n  }\n\n  if (node.out) {\n    this.word(\"out\");\n    this.space();\n  }\n\n  this.word(node.name);\n\n  if (node.constraint) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.constraint, node);\n  }\n\n  if (node.default) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.default, node);\n  }\n}\n\nfunction TSParameterProperty(node) {\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this._param(node.parameter);\n}\n\nfunction TSDeclareFunction(node) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this._functionHead(node);\n\n  this.tokenChar(59);\n}\n\nfunction TSDeclareMethod(node) {\n  this._classMethodHead(node);\n\n  this.tokenChar(59);\n}\n\nfunction TSQualifiedName(node) {\n  this.print(node.left, node);\n  this.tokenChar(46);\n  this.print(node.right, node);\n}\n\nfunction TSCallSignatureDeclaration(node) {\n  this.tsPrintSignatureDeclarationBase(node);\n  this.tokenChar(59);\n}\n\nfunction TSConstructSignatureDeclaration(node) {\n  this.word(\"new\");\n  this.space();\n  this.tsPrintSignatureDeclarationBase(node);\n  this.tokenChar(59);\n}\n\nfunction TSPropertySignature(node) {\n  const {\n    readonly,\n    initializer\n  } = node;\n\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.tsPrintPropertyOrMethodName(node);\n  this.print(node.typeAnnotation, node);\n\n  if (initializer) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(initializer, node);\n  }\n\n  this.tokenChar(59);\n}\n\nfunction tsPrintPropertyOrMethodName(node) {\n  if (node.computed) {\n    this.tokenChar(91);\n  }\n\n  this.print(node.key, node);\n\n  if (node.computed) {\n    this.tokenChar(93);\n  }\n\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n}\n\nfunction TSMethodSignature(node) {\n  const {\n    kind\n  } = node;\n\n  if (kind === \"set\" || kind === \"get\") {\n    this.word(kind);\n    this.space();\n  }\n\n  this.tsPrintPropertyOrMethodName(node);\n  this.tsPrintSignatureDeclarationBase(node);\n  this.tokenChar(59);\n}\n\nfunction TSIndexSignature(node) {\n  const {\n    readonly,\n    static: isStatic\n  } = node;\n\n  if (isStatic) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.tokenChar(91);\n\n  this._parameters(node.parameters, node);\n\n  this.tokenChar(93);\n  this.print(node.typeAnnotation, node);\n  this.tokenChar(59);\n}\n\nfunction TSAnyKeyword() {\n  this.word(\"any\");\n}\n\nfunction TSBigIntKeyword() {\n  this.word(\"bigint\");\n}\n\nfunction TSUnknownKeyword() {\n  this.word(\"unknown\");\n}\n\nfunction TSNumberKeyword() {\n  this.word(\"number\");\n}\n\nfunction TSObjectKeyword() {\n  this.word(\"object\");\n}\n\nfunction TSBooleanKeyword() {\n  this.word(\"boolean\");\n}\n\nfunction TSStringKeyword() {\n  this.word(\"string\");\n}\n\nfunction TSSymbolKeyword() {\n  this.word(\"symbol\");\n}\n\nfunction TSVoidKeyword() {\n  this.word(\"void\");\n}\n\nfunction TSUndefinedKeyword() {\n  this.word(\"undefined\");\n}\n\nfunction TSNullKeyword() {\n  this.word(\"null\");\n}\n\nfunction TSNeverKeyword() {\n  this.word(\"never\");\n}\n\nfunction TSIntrinsicKeyword() {\n  this.word(\"intrinsic\");\n}\n\nfunction TSThisType() {\n  this.word(\"this\");\n}\n\nfunction TSFunctionType(node) {\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nfunction TSConstructorType(node) {\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n\n  this.word(\"new\");\n  this.space();\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nfunction tsPrintFunctionOrConstructorType(node) {\n  const {\n    typeParameters\n  } = node;\n  const parameters = node.parameters;\n  this.print(typeParameters, node);\n  this.tokenChar(40);\n\n  this._parameters(parameters, node);\n\n  this.tokenChar(41);\n  this.space();\n  this.token(\"=>\");\n  this.space();\n  const returnType = node.typeAnnotation;\n  this.print(returnType.typeAnnotation, node);\n}\n\nfunction TSTypeReference(node) {\n  this.print(node.typeName, node, true);\n  this.print(node.typeParameters, node, true);\n}\n\nfunction TSTypePredicate(node) {\n  if (node.asserts) {\n    this.word(\"asserts\");\n    this.space();\n  }\n\n  this.print(node.parameterName);\n\n  if (node.typeAnnotation) {\n    this.space();\n    this.word(\"is\");\n    this.space();\n    this.print(node.typeAnnotation.typeAnnotation);\n  }\n}\n\nfunction TSTypeQuery(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.exprName);\n\n  if (node.typeParameters) {\n    this.print(node.typeParameters, node);\n  }\n}\n\nfunction TSTypeLiteral(node) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);\n}\n\nfunction tsPrintTypeLiteralOrInterfaceBody(members, node) {\n  tsPrintBraced(this, members, node);\n}\n\nfunction tsPrintBraced(printer, members, node) {\n  printer.token(\"{\");\n\n  if (members.length) {\n    printer.indent();\n    printer.newline();\n\n    for (const member of members) {\n      printer.print(member, node);\n      printer.newline();\n    }\n\n    printer.dedent();\n    printer.rightBrace();\n  } else {\n    printer.token(\"}\");\n  }\n}\n\nfunction TSArrayType(node) {\n  this.print(node.elementType, node, true);\n  this.token(\"[]\");\n}\n\nfunction TSTupleType(node) {\n  this.tokenChar(91);\n  this.printList(node.elementTypes, node);\n  this.tokenChar(93);\n}\n\nfunction TSOptionalType(node) {\n  this.print(node.typeAnnotation, node);\n  this.tokenChar(63);\n}\n\nfunction TSRestType(node) {\n  this.token(\"...\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSNamedTupleMember(node) {\n  this.print(node.label, node);\n  if (node.optional) this.tokenChar(63);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.elementType, node);\n}\n\nfunction TSUnionType(node) {\n  tsPrintUnionOrIntersectionType(this, node, \"|\");\n}\n\nfunction TSIntersectionType(node) {\n  tsPrintUnionOrIntersectionType(this, node, \"&\");\n}\n\nfunction tsPrintUnionOrIntersectionType(printer, node, sep) {\n  printer.printJoin(node.types, node, {\n    separator() {\n      this.space();\n      this.token(sep);\n      this.space();\n    }\n\n  });\n}\n\nfunction TSConditionalType(node) {\n  this.print(node.checkType);\n  this.space();\n  this.word(\"extends\");\n  this.space();\n  this.print(node.extendsType);\n  this.space();\n  this.tokenChar(63);\n  this.space();\n  this.print(node.trueType);\n  this.space();\n  this.tokenChar(58);\n  this.space();\n  this.print(node.falseType);\n}\n\nfunction TSInferType(node) {\n  this.token(\"infer\");\n  this.space();\n  this.print(node.typeParameter);\n}\n\nfunction TSParenthesizedType(node) {\n  this.tokenChar(40);\n  this.print(node.typeAnnotation, node);\n  this.tokenChar(41);\n}\n\nfunction TSTypeOperator(node) {\n  this.word(node.operator);\n  this.space();\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSIndexedAccessType(node) {\n  this.print(node.objectType, node, true);\n  this.tokenChar(91);\n  this.print(node.indexType, node);\n  this.tokenChar(93);\n}\n\nfunction TSMappedType(node) {\n  const {\n    nameType,\n    optional,\n    readonly,\n    typeParameter\n  } = node;\n  this.tokenChar(123);\n  this.space();\n\n  if (readonly) {\n    tokenIfPlusMinus(this, readonly);\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.tokenChar(91);\n  this.word(typeParameter.name);\n  this.space();\n  this.word(\"in\");\n  this.space();\n  this.print(typeParameter.constraint, typeParameter);\n\n  if (nameType) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(nameType, node);\n  }\n\n  this.tokenChar(93);\n\n  if (optional) {\n    tokenIfPlusMinus(this, optional);\n    this.tokenChar(63);\n  }\n\n  this.tokenChar(58);\n  this.space();\n  this.print(node.typeAnnotation, node);\n  this.space();\n  this.tokenChar(125);\n}\n\nfunction tokenIfPlusMinus(self, tok) {\n  if (tok !== true) {\n    self.token(tok);\n  }\n}\n\nfunction TSLiteralType(node) {\n  this.print(node.literal, node);\n}\n\nfunction TSExpressionWithTypeArguments(node) {\n  this.print(node.expression, node);\n  this.print(node.typeParameters, node);\n}\n\nfunction TSInterfaceDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    extends: extendz,\n    body\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"interface\");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n\n  if (extendz != null && extendz.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(extendz, node);\n  }\n\n  this.space();\n  this.print(body, node);\n}\n\nfunction TSInterfaceBody(node) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);\n}\n\nfunction TSTypeAliasDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    typeAnnotation\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"type\");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(typeAnnotation, node);\n  this.tokenChar(59);\n}\n\nfunction TSAsExpression(node) {\n  const {\n    expression,\n    typeAnnotation\n  } = node;\n  this.print(expression, node);\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(typeAnnotation, node);\n}\n\nfunction TSTypeAssertion(node) {\n  const {\n    typeAnnotation,\n    expression\n  } = node;\n  this.tokenChar(60);\n  this.print(typeAnnotation, node);\n  this.tokenChar(62);\n  this.space();\n  this.print(expression, node);\n}\n\nfunction TSInstantiationExpression(node) {\n  this.print(node.expression, node);\n  this.print(node.typeParameters, node);\n}\n\nfunction TSEnumDeclaration(node) {\n  const {\n    declare,\n    const: isConst,\n    id,\n    members\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (isConst) {\n    this.word(\"const\");\n    this.space();\n  }\n\n  this.word(\"enum\");\n  this.space();\n  this.print(id, node);\n  this.space();\n  tsPrintBraced(this, members, node);\n}\n\nfunction TSEnumMember(node) {\n  const {\n    id,\n    initializer\n  } = node;\n  this.print(id, node);\n\n  if (initializer) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(initializer, node);\n  }\n\n  this.tokenChar(44);\n}\n\nfunction TSModuleDeclaration(node) {\n  const {\n    declare,\n    id\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (!node.global) {\n    this.word(id.type === \"Identifier\" ? \"namespace\" : \"module\");\n    this.space();\n  }\n\n  this.print(id, node);\n\n  if (!node.body) {\n    this.tokenChar(59);\n    return;\n  }\n\n  let body = node.body;\n\n  while (body.type === \"TSModuleDeclaration\") {\n    this.tokenChar(46);\n    this.print(body.id, body);\n    body = body.body;\n  }\n\n  this.space();\n  this.print(body, node);\n}\n\nfunction TSModuleBlock(node) {\n  tsPrintBraced(this, node.body, node);\n}\n\nfunction TSImportType(node) {\n  const {\n    argument,\n    qualifier,\n    typeParameters\n  } = node;\n  this.word(\"import\");\n  this.tokenChar(40);\n  this.print(argument, node);\n  this.tokenChar(41);\n\n  if (qualifier) {\n    this.tokenChar(46);\n    this.print(qualifier, node);\n  }\n\n  if (typeParameters) {\n    this.print(typeParameters, node);\n  }\n}\n\nfunction TSImportEqualsDeclaration(node) {\n  const {\n    isExport,\n    id,\n    moduleReference\n  } = node;\n\n  if (isExport) {\n    this.word(\"export\");\n    this.space();\n  }\n\n  this.word(\"import\");\n  this.space();\n  this.print(id, node);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(moduleReference, node);\n  this.tokenChar(59);\n}\n\nfunction TSExternalModuleReference(node) {\n  this.token(\"require(\");\n  this.print(node.expression, node);\n  this.tokenChar(41);\n}\n\nfunction TSNonNullExpression(node) {\n  this.print(node.expression, node);\n  this.tokenChar(33);\n}\n\nfunction TSExportAssignment(node) {\n  this.word(\"export\");\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(node.expression, node);\n  this.tokenChar(59);\n}\n\nfunction TSNamespaceExportDeclaration(node) {\n  this.word(\"export\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.word(\"namespace\");\n  this.space();\n  this.print(node.id, node);\n}\n\nfunction tsPrintSignatureDeclarationBase(node) {\n  const {\n    typeParameters\n  } = node;\n  const parameters = node.parameters;\n  this.print(typeParameters, node);\n  this.tokenChar(40);\n\n  this._parameters(parameters, node);\n\n  this.tokenChar(41);\n  const returnType = node.typeAnnotation;\n  this.print(returnType, node);\n}\n\nfunction tsPrintClassMemberModifiers(node) {\n  const isField = node.type === \"ClassAccessorProperty\" || node.type === \"ClassProperty\";\n\n  if (isField && node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  if (node.override) {\n    this.word(\"override\");\n    this.space();\n  }\n\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n\n  if (isField && node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","TSAnyKeyword","TSArrayType","TSAsExpression","TSBigIntKeyword","TSBooleanKeyword","TSCallSignatureDeclaration","TSConditionalType","TSConstructSignatureDeclaration","TSConstructorType","TSDeclareFunction","TSDeclareMethod","TSEnumDeclaration","TSEnumMember","TSExportAssignment","TSExpressionWithTypeArguments","TSExternalModuleReference","TSFunctionType","TSImportEqualsDeclaration","TSImportType","TSIndexSignature","TSIndexedAccessType","TSInferType","TSInstantiationExpression","TSInterfaceBody","TSInterfaceDeclaration","TSIntersectionType","TSIntrinsicKeyword","TSLiteralType","TSMappedType","TSMethodSignature","TSModuleBlock","TSModuleDeclaration","TSNamedTupleMember","TSNamespaceExportDeclaration","TSNeverKeyword","TSNonNullExpression","TSNullKeyword","TSNumberKeyword","TSObjectKeyword","TSOptionalType","TSParameterProperty","TSParenthesizedType","TSPropertySignature","TSQualifiedName","TSRestType","TSStringKeyword","TSSymbolKeyword","TSThisType","TSTupleType","TSTypeAliasDeclaration","TSTypeAnnotation","TSTypeAssertion","TSTypeLiteral","TSTypeOperator","TSTypeParameter","TSTypeParameterDeclaration","TSTypeParameterInstantiation","TSTypePredicate","TSTypeQuery","TSTypeReference","TSUndefinedKeyword","TSUnionType","TSUnknownKeyword","TSVoidKeyword","tsPrintClassMemberModifiers","tsPrintFunctionOrConstructorType","tsPrintPropertyOrMethodName","tsPrintSignatureDeclarationBase","tsPrintTypeLiteralOrInterfaceBody","node","tokenChar","space","optional","print","typeAnnotation","parent","printList","params","type","length","in","word","out","name","constraint","default","accessibility","readonly","_param","parameter","declare","_functionHead","_classMethodHead","left","right","initializer","computed","key","kind","static","isStatic","_parameters","parameters","abstract","typeParameters","token","returnType","typeName","asserts","parameterName","exprName","members","tsPrintBraced","printer","indent","newline","member","dedent","rightBrace","elementType","elementTypes","label","tsPrintUnionOrIntersectionType","sep","printJoin","types","separator","checkType","extendsType","trueType","falseType","typeParameter","operator","objectType","indexType","nameType","tokenIfPlusMinus","self","tok","literal","expression","id","extends","extendz","body","const","isConst","global","argument","qualifier","isExport","moduleReference","isField","override"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/@babel/generator/lib/generators/typescript.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TSAnyKeyword = TSAnyKeyword;\nexports.TSArrayType = TSArrayType;\nexports.TSAsExpression = TSAsExpression;\nexports.TSBigIntKeyword = TSBigIntKeyword;\nexports.TSBooleanKeyword = TSBooleanKeyword;\nexports.TSCallSignatureDeclaration = TSCallSignatureDeclaration;\nexports.TSConditionalType = TSConditionalType;\nexports.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;\nexports.TSConstructorType = TSConstructorType;\nexports.TSDeclareFunction = TSDeclareFunction;\nexports.TSDeclareMethod = TSDeclareMethod;\nexports.TSEnumDeclaration = TSEnumDeclaration;\nexports.TSEnumMember = TSEnumMember;\nexports.TSExportAssignment = TSExportAssignment;\nexports.TSExpressionWithTypeArguments = TSExpressionWithTypeArguments;\nexports.TSExternalModuleReference = TSExternalModuleReference;\nexports.TSFunctionType = TSFunctionType;\nexports.TSImportEqualsDeclaration = TSImportEqualsDeclaration;\nexports.TSImportType = TSImportType;\nexports.TSIndexSignature = TSIndexSignature;\nexports.TSIndexedAccessType = TSIndexedAccessType;\nexports.TSInferType = TSInferType;\nexports.TSInstantiationExpression = TSInstantiationExpression;\nexports.TSInterfaceBody = TSInterfaceBody;\nexports.TSInterfaceDeclaration = TSInterfaceDeclaration;\nexports.TSIntersectionType = TSIntersectionType;\nexports.TSIntrinsicKeyword = TSIntrinsicKeyword;\nexports.TSLiteralType = TSLiteralType;\nexports.TSMappedType = TSMappedType;\nexports.TSMethodSignature = TSMethodSignature;\nexports.TSModuleBlock = TSModuleBlock;\nexports.TSModuleDeclaration = TSModuleDeclaration;\nexports.TSNamedTupleMember = TSNamedTupleMember;\nexports.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;\nexports.TSNeverKeyword = TSNeverKeyword;\nexports.TSNonNullExpression = TSNonNullExpression;\nexports.TSNullKeyword = TSNullKeyword;\nexports.TSNumberKeyword = TSNumberKeyword;\nexports.TSObjectKeyword = TSObjectKeyword;\nexports.TSOptionalType = TSOptionalType;\nexports.TSParameterProperty = TSParameterProperty;\nexports.TSParenthesizedType = TSParenthesizedType;\nexports.TSPropertySignature = TSPropertySignature;\nexports.TSQualifiedName = TSQualifiedName;\nexports.TSRestType = TSRestType;\nexports.TSStringKeyword = TSStringKeyword;\nexports.TSSymbolKeyword = TSSymbolKeyword;\nexports.TSThisType = TSThisType;\nexports.TSTupleType = TSTupleType;\nexports.TSTypeAliasDeclaration = TSTypeAliasDeclaration;\nexports.TSTypeAnnotation = TSTypeAnnotation;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSTypeLiteral = TSTypeLiteral;\nexports.TSTypeOperator = TSTypeOperator;\nexports.TSTypeParameter = TSTypeParameter;\nexports.TSTypeParameterDeclaration = exports.TSTypeParameterInstantiation = TSTypeParameterInstantiation;\nexports.TSTypePredicate = TSTypePredicate;\nexports.TSTypeQuery = TSTypeQuery;\nexports.TSTypeReference = TSTypeReference;\nexports.TSUndefinedKeyword = TSUndefinedKeyword;\nexports.TSUnionType = TSUnionType;\nexports.TSUnknownKeyword = TSUnknownKeyword;\nexports.TSVoidKeyword = TSVoidKeyword;\nexports.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;\nexports.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;\nexports.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;\nexports.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;\nexports.tsPrintTypeLiteralOrInterfaceBody = tsPrintTypeLiteralOrInterfaceBody;\n\nfunction TSTypeAnnotation(node) {\n  this.tokenChar(58);\n  this.space();\n  if (node.optional) this.tokenChar(63);\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSTypeParameterInstantiation(node, parent) {\n  this.tokenChar(60);\n  this.printList(node.params, node, {});\n\n  if (parent.type === \"ArrowFunctionExpression\" && node.params.length === 1) {\n    this.tokenChar(44);\n  }\n\n  this.tokenChar(62);\n}\n\nfunction TSTypeParameter(node) {\n  if (node.in) {\n    this.word(\"in\");\n    this.space();\n  }\n\n  if (node.out) {\n    this.word(\"out\");\n    this.space();\n  }\n\n  this.word(node.name);\n\n  if (node.constraint) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.print(node.constraint, node);\n  }\n\n  if (node.default) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(node.default, node);\n  }\n}\n\nfunction TSParameterProperty(node) {\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this._param(node.parameter);\n}\n\nfunction TSDeclareFunction(node) {\n  if (node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this._functionHead(node);\n\n  this.tokenChar(59);\n}\n\nfunction TSDeclareMethod(node) {\n  this._classMethodHead(node);\n\n  this.tokenChar(59);\n}\n\nfunction TSQualifiedName(node) {\n  this.print(node.left, node);\n  this.tokenChar(46);\n  this.print(node.right, node);\n}\n\nfunction TSCallSignatureDeclaration(node) {\n  this.tsPrintSignatureDeclarationBase(node);\n  this.tokenChar(59);\n}\n\nfunction TSConstructSignatureDeclaration(node) {\n  this.word(\"new\");\n  this.space();\n  this.tsPrintSignatureDeclarationBase(node);\n  this.tokenChar(59);\n}\n\nfunction TSPropertySignature(node) {\n  const {\n    readonly,\n    initializer\n  } = node;\n\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.tsPrintPropertyOrMethodName(node);\n  this.print(node.typeAnnotation, node);\n\n  if (initializer) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(initializer, node);\n  }\n\n  this.tokenChar(59);\n}\n\nfunction tsPrintPropertyOrMethodName(node) {\n  if (node.computed) {\n    this.tokenChar(91);\n  }\n\n  this.print(node.key, node);\n\n  if (node.computed) {\n    this.tokenChar(93);\n  }\n\n  if (node.optional) {\n    this.tokenChar(63);\n  }\n}\n\nfunction TSMethodSignature(node) {\n  const {\n    kind\n  } = node;\n\n  if (kind === \"set\" || kind === \"get\") {\n    this.word(kind);\n    this.space();\n  }\n\n  this.tsPrintPropertyOrMethodName(node);\n  this.tsPrintSignatureDeclarationBase(node);\n  this.tokenChar(59);\n}\n\nfunction TSIndexSignature(node) {\n  const {\n    readonly,\n    static: isStatic\n  } = node;\n\n  if (isStatic) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  if (readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.tokenChar(91);\n\n  this._parameters(node.parameters, node);\n\n  this.tokenChar(93);\n  this.print(node.typeAnnotation, node);\n  this.tokenChar(59);\n}\n\nfunction TSAnyKeyword() {\n  this.word(\"any\");\n}\n\nfunction TSBigIntKeyword() {\n  this.word(\"bigint\");\n}\n\nfunction TSUnknownKeyword() {\n  this.word(\"unknown\");\n}\n\nfunction TSNumberKeyword() {\n  this.word(\"number\");\n}\n\nfunction TSObjectKeyword() {\n  this.word(\"object\");\n}\n\nfunction TSBooleanKeyword() {\n  this.word(\"boolean\");\n}\n\nfunction TSStringKeyword() {\n  this.word(\"string\");\n}\n\nfunction TSSymbolKeyword() {\n  this.word(\"symbol\");\n}\n\nfunction TSVoidKeyword() {\n  this.word(\"void\");\n}\n\nfunction TSUndefinedKeyword() {\n  this.word(\"undefined\");\n}\n\nfunction TSNullKeyword() {\n  this.word(\"null\");\n}\n\nfunction TSNeverKeyword() {\n  this.word(\"never\");\n}\n\nfunction TSIntrinsicKeyword() {\n  this.word(\"intrinsic\");\n}\n\nfunction TSThisType() {\n  this.word(\"this\");\n}\n\nfunction TSFunctionType(node) {\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nfunction TSConstructorType(node) {\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n\n  this.word(\"new\");\n  this.space();\n  this.tsPrintFunctionOrConstructorType(node);\n}\n\nfunction tsPrintFunctionOrConstructorType(node) {\n  const {\n    typeParameters\n  } = node;\n  const parameters = node.parameters;\n  this.print(typeParameters, node);\n  this.tokenChar(40);\n\n  this._parameters(parameters, node);\n\n  this.tokenChar(41);\n  this.space();\n  this.token(\"=>\");\n  this.space();\n  const returnType = node.typeAnnotation;\n  this.print(returnType.typeAnnotation, node);\n}\n\nfunction TSTypeReference(node) {\n  this.print(node.typeName, node, true);\n  this.print(node.typeParameters, node, true);\n}\n\nfunction TSTypePredicate(node) {\n  if (node.asserts) {\n    this.word(\"asserts\");\n    this.space();\n  }\n\n  this.print(node.parameterName);\n\n  if (node.typeAnnotation) {\n    this.space();\n    this.word(\"is\");\n    this.space();\n    this.print(node.typeAnnotation.typeAnnotation);\n  }\n}\n\nfunction TSTypeQuery(node) {\n  this.word(\"typeof\");\n  this.space();\n  this.print(node.exprName);\n\n  if (node.typeParameters) {\n    this.print(node.typeParameters, node);\n  }\n}\n\nfunction TSTypeLiteral(node) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.members, node);\n}\n\nfunction tsPrintTypeLiteralOrInterfaceBody(members, node) {\n  tsPrintBraced(this, members, node);\n}\n\nfunction tsPrintBraced(printer, members, node) {\n  printer.token(\"{\");\n\n  if (members.length) {\n    printer.indent();\n    printer.newline();\n\n    for (const member of members) {\n      printer.print(member, node);\n      printer.newline();\n    }\n\n    printer.dedent();\n    printer.rightBrace();\n  } else {\n    printer.token(\"}\");\n  }\n}\n\nfunction TSArrayType(node) {\n  this.print(node.elementType, node, true);\n  this.token(\"[]\");\n}\n\nfunction TSTupleType(node) {\n  this.tokenChar(91);\n  this.printList(node.elementTypes, node);\n  this.tokenChar(93);\n}\n\nfunction TSOptionalType(node) {\n  this.print(node.typeAnnotation, node);\n  this.tokenChar(63);\n}\n\nfunction TSRestType(node) {\n  this.token(\"...\");\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSNamedTupleMember(node) {\n  this.print(node.label, node);\n  if (node.optional) this.tokenChar(63);\n  this.tokenChar(58);\n  this.space();\n  this.print(node.elementType, node);\n}\n\nfunction TSUnionType(node) {\n  tsPrintUnionOrIntersectionType(this, node, \"|\");\n}\n\nfunction TSIntersectionType(node) {\n  tsPrintUnionOrIntersectionType(this, node, \"&\");\n}\n\nfunction tsPrintUnionOrIntersectionType(printer, node, sep) {\n  printer.printJoin(node.types, node, {\n    separator() {\n      this.space();\n      this.token(sep);\n      this.space();\n    }\n\n  });\n}\n\nfunction TSConditionalType(node) {\n  this.print(node.checkType);\n  this.space();\n  this.word(\"extends\");\n  this.space();\n  this.print(node.extendsType);\n  this.space();\n  this.tokenChar(63);\n  this.space();\n  this.print(node.trueType);\n  this.space();\n  this.tokenChar(58);\n  this.space();\n  this.print(node.falseType);\n}\n\nfunction TSInferType(node) {\n  this.token(\"infer\");\n  this.space();\n  this.print(node.typeParameter);\n}\n\nfunction TSParenthesizedType(node) {\n  this.tokenChar(40);\n  this.print(node.typeAnnotation, node);\n  this.tokenChar(41);\n}\n\nfunction TSTypeOperator(node) {\n  this.word(node.operator);\n  this.space();\n  this.print(node.typeAnnotation, node);\n}\n\nfunction TSIndexedAccessType(node) {\n  this.print(node.objectType, node, true);\n  this.tokenChar(91);\n  this.print(node.indexType, node);\n  this.tokenChar(93);\n}\n\nfunction TSMappedType(node) {\n  const {\n    nameType,\n    optional,\n    readonly,\n    typeParameter\n  } = node;\n  this.tokenChar(123);\n  this.space();\n\n  if (readonly) {\n    tokenIfPlusMinus(this, readonly);\n    this.word(\"readonly\");\n    this.space();\n  }\n\n  this.tokenChar(91);\n  this.word(typeParameter.name);\n  this.space();\n  this.word(\"in\");\n  this.space();\n  this.print(typeParameter.constraint, typeParameter);\n\n  if (nameType) {\n    this.space();\n    this.word(\"as\");\n    this.space();\n    this.print(nameType, node);\n  }\n\n  this.tokenChar(93);\n\n  if (optional) {\n    tokenIfPlusMinus(this, optional);\n    this.tokenChar(63);\n  }\n\n  this.tokenChar(58);\n  this.space();\n  this.print(node.typeAnnotation, node);\n  this.space();\n  this.tokenChar(125);\n}\n\nfunction tokenIfPlusMinus(self, tok) {\n  if (tok !== true) {\n    self.token(tok);\n  }\n}\n\nfunction TSLiteralType(node) {\n  this.print(node.literal, node);\n}\n\nfunction TSExpressionWithTypeArguments(node) {\n  this.print(node.expression, node);\n  this.print(node.typeParameters, node);\n}\n\nfunction TSInterfaceDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    extends: extendz,\n    body\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"interface\");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n\n  if (extendz != null && extendz.length) {\n    this.space();\n    this.word(\"extends\");\n    this.space();\n    this.printList(extendz, node);\n  }\n\n  this.space();\n  this.print(body, node);\n}\n\nfunction TSInterfaceBody(node) {\n  this.tsPrintTypeLiteralOrInterfaceBody(node.body, node);\n}\n\nfunction TSTypeAliasDeclaration(node) {\n  const {\n    declare,\n    id,\n    typeParameters,\n    typeAnnotation\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  this.word(\"type\");\n  this.space();\n  this.print(id, node);\n  this.print(typeParameters, node);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(typeAnnotation, node);\n  this.tokenChar(59);\n}\n\nfunction TSAsExpression(node) {\n  const {\n    expression,\n    typeAnnotation\n  } = node;\n  this.print(expression, node);\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.print(typeAnnotation, node);\n}\n\nfunction TSTypeAssertion(node) {\n  const {\n    typeAnnotation,\n    expression\n  } = node;\n  this.tokenChar(60);\n  this.print(typeAnnotation, node);\n  this.tokenChar(62);\n  this.space();\n  this.print(expression, node);\n}\n\nfunction TSInstantiationExpression(node) {\n  this.print(node.expression, node);\n  this.print(node.typeParameters, node);\n}\n\nfunction TSEnumDeclaration(node) {\n  const {\n    declare,\n    const: isConst,\n    id,\n    members\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (isConst) {\n    this.word(\"const\");\n    this.space();\n  }\n\n  this.word(\"enum\");\n  this.space();\n  this.print(id, node);\n  this.space();\n  tsPrintBraced(this, members, node);\n}\n\nfunction TSEnumMember(node) {\n  const {\n    id,\n    initializer\n  } = node;\n  this.print(id, node);\n\n  if (initializer) {\n    this.space();\n    this.tokenChar(61);\n    this.space();\n    this.print(initializer, node);\n  }\n\n  this.tokenChar(44);\n}\n\nfunction TSModuleDeclaration(node) {\n  const {\n    declare,\n    id\n  } = node;\n\n  if (declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (!node.global) {\n    this.word(id.type === \"Identifier\" ? \"namespace\" : \"module\");\n    this.space();\n  }\n\n  this.print(id, node);\n\n  if (!node.body) {\n    this.tokenChar(59);\n    return;\n  }\n\n  let body = node.body;\n\n  while (body.type === \"TSModuleDeclaration\") {\n    this.tokenChar(46);\n    this.print(body.id, body);\n    body = body.body;\n  }\n\n  this.space();\n  this.print(body, node);\n}\n\nfunction TSModuleBlock(node) {\n  tsPrintBraced(this, node.body, node);\n}\n\nfunction TSImportType(node) {\n  const {\n    argument,\n    qualifier,\n    typeParameters\n  } = node;\n  this.word(\"import\");\n  this.tokenChar(40);\n  this.print(argument, node);\n  this.tokenChar(41);\n\n  if (qualifier) {\n    this.tokenChar(46);\n    this.print(qualifier, node);\n  }\n\n  if (typeParameters) {\n    this.print(typeParameters, node);\n  }\n}\n\nfunction TSImportEqualsDeclaration(node) {\n  const {\n    isExport,\n    id,\n    moduleReference\n  } = node;\n\n  if (isExport) {\n    this.word(\"export\");\n    this.space();\n  }\n\n  this.word(\"import\");\n  this.space();\n  this.print(id, node);\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(moduleReference, node);\n  this.tokenChar(59);\n}\n\nfunction TSExternalModuleReference(node) {\n  this.token(\"require(\");\n  this.print(node.expression, node);\n  this.tokenChar(41);\n}\n\nfunction TSNonNullExpression(node) {\n  this.print(node.expression, node);\n  this.tokenChar(33);\n}\n\nfunction TSExportAssignment(node) {\n  this.word(\"export\");\n  this.space();\n  this.tokenChar(61);\n  this.space();\n  this.print(node.expression, node);\n  this.tokenChar(59);\n}\n\nfunction TSNamespaceExportDeclaration(node) {\n  this.word(\"export\");\n  this.space();\n  this.word(\"as\");\n  this.space();\n  this.word(\"namespace\");\n  this.space();\n  this.print(node.id, node);\n}\n\nfunction tsPrintSignatureDeclarationBase(node) {\n  const {\n    typeParameters\n  } = node;\n  const parameters = node.parameters;\n  this.print(typeParameters, node);\n  this.tokenChar(40);\n\n  this._parameters(parameters, node);\n\n  this.tokenChar(41);\n  const returnType = node.typeAnnotation;\n  this.print(returnType, node);\n}\n\nfunction tsPrintClassMemberModifiers(node) {\n  const isField = node.type === \"ClassAccessorProperty\" || node.type === \"ClassProperty\";\n\n  if (isField && node.declare) {\n    this.word(\"declare\");\n    this.space();\n  }\n\n  if (node.accessibility) {\n    this.word(node.accessibility);\n    this.space();\n  }\n\n  if (node.static) {\n    this.word(\"static\");\n    this.space();\n  }\n\n  if (node.override) {\n    this.word(\"override\");\n    this.space();\n  }\n\n  if (node.abstract) {\n    this.word(\"abstract\");\n    this.space();\n  }\n\n  if (isField && node.readonly) {\n    this.word(\"readonly\");\n    this.space();\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}