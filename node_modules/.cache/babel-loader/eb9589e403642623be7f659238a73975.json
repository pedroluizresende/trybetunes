{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst arrayUnion = require('array-union');\n\nconst merge2 = require('merge2');\n\nconst fastGlob = require('fast-glob');\n\nconst dirGlob = require('dir-glob');\n\nconst gitignore = require('./gitignore');\n\nconst {\n  FilterStream,\n  UniqueStream\n} = require('./stream-utils');\n\nconst DEFAULT_FILTER = () => false;\n\nconst isNegative = pattern => pattern[0] === '!';\n\nconst assertPatternsInput = patterns => {\n  if (!patterns.every(pattern => typeof pattern === 'string')) {\n    throw new TypeError('Patterns must be a string or an array of strings');\n  }\n};\n\nconst checkCwdOption = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  if (!options.cwd) {\n    return;\n  }\n\n  let stat;\n\n  try {\n    stat = fs.statSync(options.cwd);\n  } catch {\n    return;\n  }\n\n  if (!stat.isDirectory()) {\n    throw new Error('The `cwd` option must be a path to a directory');\n  }\n};\n\nconst getPathString = p => p.stats instanceof fs.Stats ? p.path : p;\n\nconst generateGlobTasks = (patterns, taskOptions) => {\n  patterns = arrayUnion([].concat(patterns));\n  assertPatternsInput(patterns);\n  checkCwdOption(taskOptions);\n  const globTasks = [];\n  taskOptions = {\n    ignore: [],\n    expandDirectories: true,\n    ...taskOptions\n  };\n\n  for (const [index, pattern] of patterns.entries()) {\n    if (isNegative(pattern)) {\n      continue;\n    }\n\n    const ignore = patterns.slice(index).filter(pattern => isNegative(pattern)).map(pattern => pattern.slice(1));\n    const options = { ...taskOptions,\n      ignore: taskOptions.ignore.concat(ignore)\n    };\n    globTasks.push({\n      pattern,\n      options\n    });\n  }\n\n  return globTasks;\n};\n\nconst globDirs = (task, fn) => {\n  let options = {};\n\n  if (task.options.cwd) {\n    options.cwd = task.options.cwd;\n  }\n\n  if (Array.isArray(task.options.expandDirectories)) {\n    options = { ...options,\n      files: task.options.expandDirectories\n    };\n  } else if (typeof task.options.expandDirectories === 'object') {\n    options = { ...options,\n      ...task.options.expandDirectories\n    };\n  }\n\n  return fn(task.pattern, options);\n};\n\nconst getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];\n\nconst getFilterSync = options => {\n  return options && options.gitignore ? gitignore.sync({\n    cwd: options.cwd,\n    ignore: options.ignore\n  }) : DEFAULT_FILTER;\n};\n\nconst globToTask = task => glob => {\n  const {\n    options\n  } = task;\n\n  if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {\n    options.ignore = dirGlob.sync(options.ignore);\n  }\n\n  return {\n    pattern: glob,\n    options\n  };\n};\n\nmodule.exports = async (patterns, options) => {\n  const globTasks = generateGlobTasks(patterns, options);\n\n  const getFilter = async () => {\n    return options && options.gitignore ? gitignore({\n      cwd: options.cwd,\n      ignore: options.ignore\n    }) : DEFAULT_FILTER;\n  };\n\n  const getTasks = async () => {\n    const tasks = await Promise.all(globTasks.map(async task => {\n      const globs = await getPattern(task, dirGlob);\n      return Promise.all(globs.map(globToTask(task)));\n    }));\n    return arrayUnion(...tasks);\n  };\n\n  const [filter, tasks] = await Promise.all([getFilter(), getTasks()]);\n  const paths = await Promise.all(tasks.map(task => fastGlob(task.pattern, task.options)));\n  return arrayUnion(...paths).filter(path_ => !filter(getPathString(path_)));\n};\n\nmodule.exports.sync = (patterns, options) => {\n  const globTasks = generateGlobTasks(patterns, options);\n  const tasks = [];\n\n  for (const task of globTasks) {\n    const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));\n    tasks.push(...newTask);\n  }\n\n  const filter = getFilterSync(options);\n  let matches = [];\n\n  for (const task of tasks) {\n    matches = arrayUnion(matches, fastGlob.sync(task.pattern, task.options));\n  }\n\n  return matches.filter(path_ => !filter(path_));\n};\n\nmodule.exports.stream = (patterns, options) => {\n  const globTasks = generateGlobTasks(patterns, options);\n  const tasks = [];\n\n  for (const task of globTasks) {\n    const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));\n    tasks.push(...newTask);\n  }\n\n  const filter = getFilterSync(options);\n  const filterStream = new FilterStream(p => !filter(p));\n  const uniqueStream = new UniqueStream();\n  return merge2(tasks.map(task => fastGlob.stream(task.pattern, task.options))).pipe(filterStream).pipe(uniqueStream);\n};\n\nmodule.exports.generateGlobTasks = generateGlobTasks;\n\nmodule.exports.hasMagic = (patterns, options) => [].concat(patterns).some(pattern => fastGlob.isDynamicPattern(pattern, options));\n\nmodule.exports.gitignore = gitignore;","map":{"version":3,"names":["fs","require","arrayUnion","merge2","fastGlob","dirGlob","gitignore","FilterStream","UniqueStream","DEFAULT_FILTER","isNegative","pattern","assertPatternsInput","patterns","every","TypeError","checkCwdOption","options","cwd","stat","statSync","isDirectory","Error","getPathString","p","stats","Stats","path","generateGlobTasks","taskOptions","concat","globTasks","ignore","expandDirectories","index","entries","slice","filter","map","push","globDirs","task","fn","Array","isArray","files","getPattern","getFilterSync","sync","globToTask","glob","module","exports","getFilter","getTasks","tasks","Promise","all","globs","paths","path_","newTask","matches","stream","filterStream","uniqueStream","pipe","hasMagic","some","isDynamicPattern"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/globby/index.js"],"sourcesContent":["'use strict';\nconst fs = require('fs');\nconst arrayUnion = require('array-union');\nconst merge2 = require('merge2');\nconst fastGlob = require('fast-glob');\nconst dirGlob = require('dir-glob');\nconst gitignore = require('./gitignore');\nconst {FilterStream, UniqueStream} = require('./stream-utils');\n\nconst DEFAULT_FILTER = () => false;\n\nconst isNegative = pattern => pattern[0] === '!';\n\nconst assertPatternsInput = patterns => {\n\tif (!patterns.every(pattern => typeof pattern === 'string')) {\n\t\tthrow new TypeError('Patterns must be a string or an array of strings');\n\t}\n};\n\nconst checkCwdOption = (options = {}) => {\n\tif (!options.cwd) {\n\t\treturn;\n\t}\n\n\tlet stat;\n\ttry {\n\t\tstat = fs.statSync(options.cwd);\n\t} catch {\n\t\treturn;\n\t}\n\n\tif (!stat.isDirectory()) {\n\t\tthrow new Error('The `cwd` option must be a path to a directory');\n\t}\n};\n\nconst getPathString = p => p.stats instanceof fs.Stats ? p.path : p;\n\nconst generateGlobTasks = (patterns, taskOptions) => {\n\tpatterns = arrayUnion([].concat(patterns));\n\tassertPatternsInput(patterns);\n\tcheckCwdOption(taskOptions);\n\n\tconst globTasks = [];\n\n\ttaskOptions = {\n\t\tignore: [],\n\t\texpandDirectories: true,\n\t\t...taskOptions\n\t};\n\n\tfor (const [index, pattern] of patterns.entries()) {\n\t\tif (isNegative(pattern)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst ignore = patterns\n\t\t\t.slice(index)\n\t\t\t.filter(pattern => isNegative(pattern))\n\t\t\t.map(pattern => pattern.slice(1));\n\n\t\tconst options = {\n\t\t\t...taskOptions,\n\t\t\tignore: taskOptions.ignore.concat(ignore)\n\t\t};\n\n\t\tglobTasks.push({pattern, options});\n\t}\n\n\treturn globTasks;\n};\n\nconst globDirs = (task, fn) => {\n\tlet options = {};\n\tif (task.options.cwd) {\n\t\toptions.cwd = task.options.cwd;\n\t}\n\n\tif (Array.isArray(task.options.expandDirectories)) {\n\t\toptions = {\n\t\t\t...options,\n\t\t\tfiles: task.options.expandDirectories\n\t\t};\n\t} else if (typeof task.options.expandDirectories === 'object') {\n\t\toptions = {\n\t\t\t...options,\n\t\t\t...task.options.expandDirectories\n\t\t};\n\t}\n\n\treturn fn(task.pattern, options);\n};\n\nconst getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];\n\nconst getFilterSync = options => {\n\treturn options && options.gitignore ?\n\t\tgitignore.sync({cwd: options.cwd, ignore: options.ignore}) :\n\t\tDEFAULT_FILTER;\n};\n\nconst globToTask = task => glob => {\n\tconst {options} = task;\n\tif (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {\n\t\toptions.ignore = dirGlob.sync(options.ignore);\n\t}\n\n\treturn {\n\t\tpattern: glob,\n\t\toptions\n\t};\n};\n\nmodule.exports = async (patterns, options) => {\n\tconst globTasks = generateGlobTasks(patterns, options);\n\n\tconst getFilter = async () => {\n\t\treturn options && options.gitignore ?\n\t\t\tgitignore({cwd: options.cwd, ignore: options.ignore}) :\n\t\t\tDEFAULT_FILTER;\n\t};\n\n\tconst getTasks = async () => {\n\t\tconst tasks = await Promise.all(globTasks.map(async task => {\n\t\t\tconst globs = await getPattern(task, dirGlob);\n\t\t\treturn Promise.all(globs.map(globToTask(task)));\n\t\t}));\n\n\t\treturn arrayUnion(...tasks);\n\t};\n\n\tconst [filter, tasks] = await Promise.all([getFilter(), getTasks()]);\n\tconst paths = await Promise.all(tasks.map(task => fastGlob(task.pattern, task.options)));\n\n\treturn arrayUnion(...paths).filter(path_ => !filter(getPathString(path_)));\n};\n\nmodule.exports.sync = (patterns, options) => {\n\tconst globTasks = generateGlobTasks(patterns, options);\n\n\tconst tasks = [];\n\tfor (const task of globTasks) {\n\t\tconst newTask = getPattern(task, dirGlob.sync).map(globToTask(task));\n\t\ttasks.push(...newTask);\n\t}\n\n\tconst filter = getFilterSync(options);\n\n\tlet matches = [];\n\tfor (const task of tasks) {\n\t\tmatches = arrayUnion(matches, fastGlob.sync(task.pattern, task.options));\n\t}\n\n\treturn matches.filter(path_ => !filter(path_));\n};\n\nmodule.exports.stream = (patterns, options) => {\n\tconst globTasks = generateGlobTasks(patterns, options);\n\n\tconst tasks = [];\n\tfor (const task of globTasks) {\n\t\tconst newTask = getPattern(task, dirGlob.sync).map(globToTask(task));\n\t\ttasks.push(...newTask);\n\t}\n\n\tconst filter = getFilterSync(options);\n\tconst filterStream = new FilterStream(p => !filter(p));\n\tconst uniqueStream = new UniqueStream();\n\n\treturn merge2(tasks.map(task => fastGlob.stream(task.pattern, task.options)))\n\t\t.pipe(filterStream)\n\t\t.pipe(uniqueStream);\n};\n\nmodule.exports.generateGlobTasks = generateGlobTasks;\n\nmodule.exports.hasMagic = (patterns, options) => []\n\t.concat(patterns)\n\t.some(pattern => fastGlob.isDynamicPattern(pattern, options));\n\nmodule.exports.gitignore = gitignore;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}