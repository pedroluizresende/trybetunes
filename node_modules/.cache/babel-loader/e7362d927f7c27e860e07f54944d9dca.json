{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isBindingIdentifier = isBindingIdentifier;\nexports.isBlockScoped = isBlockScoped;\nexports.isExistentialTypeParam = isExistentialTypeParam;\nexports.isExpression = isExpression;\nexports.isFlow = isFlow;\nexports.isForAwaitStatement = isForAwaitStatement;\nexports.isGenerated = isGenerated;\nexports.isNumericLiteralTypeAnnotation = isNumericLiteralTypeAnnotation;\nexports.isPure = isPure;\nexports.isReferenced = isReferenced;\nexports.isReferencedIdentifier = isReferencedIdentifier;\nexports.isReferencedMemberExpression = isReferencedMemberExpression;\nexports.isRestProperty = isRestProperty;\nexports.isScope = isScope;\nexports.isSpreadProperty = isSpreadProperty;\nexports.isStatement = isStatement;\nexports.isUser = isUser;\nexports.isVar = isVar;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isBinding,\n  isBlockScoped: nodeIsBlockScoped,\n  isExportDeclaration,\n  isExpression: nodeIsExpression,\n  isFlow: nodeIsFlow,\n  isForStatement,\n  isForXStatement,\n  isIdentifier,\n  isImportDeclaration,\n  isImportSpecifier,\n  isJSXIdentifier,\n  isJSXMemberExpression,\n  isMemberExpression,\n  isRestElement: nodeIsRestElement,\n  isReferenced: nodeIsReferenced,\n  isScope: nodeIsScope,\n  isStatement: nodeIsStatement,\n  isVar: nodeIsVar,\n  isVariableDeclaration,\n  react\n} = _t;\nconst {\n  isCompatTag\n} = react;\n\nfunction isReferencedIdentifier(opts) {\n  const {\n    node,\n    parent\n  } = this;\n\n  if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {\n    if (isJSXIdentifier(node, opts)) {\n      if (isCompatTag(node.name)) return false;\n    } else {\n      return false;\n    }\n  }\n\n  return nodeIsReferenced(node, parent, this.parentPath.parent);\n}\n\nfunction isReferencedMemberExpression() {\n  const {\n    node,\n    parent\n  } = this;\n  return isMemberExpression(node) && nodeIsReferenced(node, parent);\n}\n\nfunction isBindingIdentifier() {\n  const {\n    node,\n    parent\n  } = this;\n  const grandparent = this.parentPath.parent;\n  return isIdentifier(node) && isBinding(node, parent, grandparent);\n}\n\nfunction isStatement() {\n  const {\n    node,\n    parent\n  } = this;\n\n  if (nodeIsStatement(node)) {\n    if (isVariableDeclaration(node)) {\n      if (isForXStatement(parent, {\n        left: node\n      })) return false;\n      if (isForStatement(parent, {\n        init: node\n      })) return false;\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction isExpression() {\n  if (this.isIdentifier()) {\n    return this.isReferencedIdentifier();\n  } else {\n    return nodeIsExpression(this.node);\n  }\n}\n\nfunction isScope() {\n  return nodeIsScope(this.node, this.parent);\n}\n\nfunction isReferenced() {\n  return nodeIsReferenced(this.node, this.parent);\n}\n\nfunction isBlockScoped() {\n  return nodeIsBlockScoped(this.node);\n}\n\nfunction isVar() {\n  return nodeIsVar(this.node);\n}\n\nfunction isUser() {\n  return this.node && !!this.node.loc;\n}\n\nfunction isGenerated() {\n  return !this.isUser();\n}\n\nfunction isPure(constantsOnly) {\n  return this.scope.isPure(this.node, constantsOnly);\n}\n\nfunction isFlow() {\n  const {\n    node\n  } = this;\n\n  if (nodeIsFlow(node)) {\n    return true;\n  } else if (isImportDeclaration(node)) {\n    return node.importKind === \"type\" || node.importKind === \"typeof\";\n  } else if (isExportDeclaration(node)) {\n    return node.exportKind === \"type\";\n  } else if (isImportSpecifier(node)) {\n    return node.importKind === \"type\" || node.importKind === \"typeof\";\n  } else {\n    return false;\n  }\n}\n\nfunction isRestProperty() {\n  return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectPattern();\n}\n\nfunction isSpreadProperty() {\n  return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectExpression();\n}\n\nfunction isForAwaitStatement() {\n  return isForStatement(this.node, {\n    await: true\n  });\n}\n\nfunction isExistentialTypeParam() {\n  throw new Error(\"`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.\");\n}\n\nfunction isNumericLiteralTypeAnnotation() {\n  throw new Error(\"`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.\");\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","isBindingIdentifier","isBlockScoped","isExistentialTypeParam","isExpression","isFlow","isForAwaitStatement","isGenerated","isNumericLiteralTypeAnnotation","isPure","isReferenced","isReferencedIdentifier","isReferencedMemberExpression","isRestProperty","isScope","isSpreadProperty","isStatement","isUser","isVar","_t","require","isBinding","nodeIsBlockScoped","isExportDeclaration","nodeIsExpression","nodeIsFlow","isForStatement","isForXStatement","isIdentifier","isImportDeclaration","isImportSpecifier","isJSXIdentifier","isJSXMemberExpression","isMemberExpression","isRestElement","nodeIsRestElement","nodeIsReferenced","nodeIsScope","nodeIsStatement","nodeIsVar","isVariableDeclaration","react","isCompatTag","opts","node","parent","name","parentPath","grandparent","left","init","loc","constantsOnly","scope","importKind","exportKind","isObjectPattern","isObjectExpression","await","Error"],"sources":["/home/pedroresende/projetos/trybe/frontend/sd-026-b-project-trybetunes/node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isBindingIdentifier = isBindingIdentifier;\nexports.isBlockScoped = isBlockScoped;\nexports.isExistentialTypeParam = isExistentialTypeParam;\nexports.isExpression = isExpression;\nexports.isFlow = isFlow;\nexports.isForAwaitStatement = isForAwaitStatement;\nexports.isGenerated = isGenerated;\nexports.isNumericLiteralTypeAnnotation = isNumericLiteralTypeAnnotation;\nexports.isPure = isPure;\nexports.isReferenced = isReferenced;\nexports.isReferencedIdentifier = isReferencedIdentifier;\nexports.isReferencedMemberExpression = isReferencedMemberExpression;\nexports.isRestProperty = isRestProperty;\nexports.isScope = isScope;\nexports.isSpreadProperty = isSpreadProperty;\nexports.isStatement = isStatement;\nexports.isUser = isUser;\nexports.isVar = isVar;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isBinding,\n  isBlockScoped: nodeIsBlockScoped,\n  isExportDeclaration,\n  isExpression: nodeIsExpression,\n  isFlow: nodeIsFlow,\n  isForStatement,\n  isForXStatement,\n  isIdentifier,\n  isImportDeclaration,\n  isImportSpecifier,\n  isJSXIdentifier,\n  isJSXMemberExpression,\n  isMemberExpression,\n  isRestElement: nodeIsRestElement,\n  isReferenced: nodeIsReferenced,\n  isScope: nodeIsScope,\n  isStatement: nodeIsStatement,\n  isVar: nodeIsVar,\n  isVariableDeclaration,\n  react\n} = _t;\nconst {\n  isCompatTag\n} = react;\n\nfunction isReferencedIdentifier(opts) {\n  const {\n    node,\n    parent\n  } = this;\n\n  if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {\n    if (isJSXIdentifier(node, opts)) {\n      if (isCompatTag(node.name)) return false;\n    } else {\n      return false;\n    }\n  }\n\n  return nodeIsReferenced(node, parent, this.parentPath.parent);\n}\n\nfunction isReferencedMemberExpression() {\n  const {\n    node,\n    parent\n  } = this;\n  return isMemberExpression(node) && nodeIsReferenced(node, parent);\n}\n\nfunction isBindingIdentifier() {\n  const {\n    node,\n    parent\n  } = this;\n  const grandparent = this.parentPath.parent;\n  return isIdentifier(node) && isBinding(node, parent, grandparent);\n}\n\nfunction isStatement() {\n  const {\n    node,\n    parent\n  } = this;\n\n  if (nodeIsStatement(node)) {\n    if (isVariableDeclaration(node)) {\n      if (isForXStatement(parent, {\n        left: node\n      })) return false;\n      if (isForStatement(parent, {\n        init: node\n      })) return false;\n    }\n\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction isExpression() {\n  if (this.isIdentifier()) {\n    return this.isReferencedIdentifier();\n  } else {\n    return nodeIsExpression(this.node);\n  }\n}\n\nfunction isScope() {\n  return nodeIsScope(this.node, this.parent);\n}\n\nfunction isReferenced() {\n  return nodeIsReferenced(this.node, this.parent);\n}\n\nfunction isBlockScoped() {\n  return nodeIsBlockScoped(this.node);\n}\n\nfunction isVar() {\n  return nodeIsVar(this.node);\n}\n\nfunction isUser() {\n  return this.node && !!this.node.loc;\n}\n\nfunction isGenerated() {\n  return !this.isUser();\n}\n\nfunction isPure(constantsOnly) {\n  return this.scope.isPure(this.node, constantsOnly);\n}\n\nfunction isFlow() {\n  const {\n    node\n  } = this;\n\n  if (nodeIsFlow(node)) {\n    return true;\n  } else if (isImportDeclaration(node)) {\n    return node.importKind === \"type\" || node.importKind === \"typeof\";\n  } else if (isExportDeclaration(node)) {\n    return node.exportKind === \"type\";\n  } else if (isImportSpecifier(node)) {\n    return node.importKind === \"type\" || node.importKind === \"typeof\";\n  } else {\n    return false;\n  }\n}\n\nfunction isRestProperty() {\n  return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectPattern();\n}\n\nfunction isSpreadProperty() {\n  return nodeIsRestElement(this.node) && this.parentPath && this.parentPath.isObjectExpression();\n}\n\nfunction isForAwaitStatement() {\n  return isForStatement(this.node, {\n    await: true\n  });\n}\n\nfunction isExistentialTypeParam() {\n  throw new Error(\"`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.\");\n}\n\nfunction isNumericLiteralTypeAnnotation() {\n  throw new Error(\"`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.\");\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}